<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/my-hugo-blog/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=my-hugo-blog/livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>改訂新版プロになるためのWeb技術入門 | nyuusen blog</title>
<meta name="keywords" content="">
<meta name="description" content="参考にしたもの
https://www.youtube.com/live/5WZDiKol8k4?si=snrgHWB_KgGl3jTe
3章 WWWの基本要素とその発展

データ交換にHTMLは適さない(プログラムで取り扱うのが困難)
そんな背景があり登場したのがXML
どういうデータ構造なのかの決まりをスキーマという
XMLではDOCTYPE宣言でdtdファイルでスキーマを指定できる
スキーマレスのJSONやYAMLが流行ったが、結局JSONスキーマが流行ったり、流行は繰り返される
XMLは人が扱うには複雑ではあるが、今でもExcelやe-taxなどコンピュータが読み取るデータとしては
多く利用される
そこからXHTMLも開発されたが、制約が多かったりあまり歓迎されなかった(流行らなかった)

4章 HTTPクライアントとHTTPサーバー

CGI: リクエストパスに応じてプログラムを起動する、今ではあまり見かけないが、このあとの発展に重要
動的にHTMLを返す、テンプレートエンジンの登場
上記を礎に、ブラウザなのでインストール不要であり、自由度の高いUIを実現できるWebアプリケーションが発展していくことになる

5章 URLとHTTP

URLからwww.が消えたのは、クラウドの台頭とサブドメインを気軽にはやせることができるようになり、昔のようにホストとWebサーバの結びつきが弱くなったため
開発時にウェルナウンポートを使用すると起動のたびにsudo権限が必要なため、8080のようなポートを使うことが多い
ブラウザはURLパスに含まれる拡張子ではなく、MIMEタイプ(Content-Type)を見てどのように扱うかを決めている
GETリクエストでリソース状態を変更できるような実装すべきじゃない理由は、検索クローラによるアクセスでリソースが意図せず変化してしまうことを避けるということも理由にある
よく見るフォーム再送信の確認ダイアログはPOSTリクエストが二重に行われることによる、不利益を避けるため

6章 従来型のWebアプリケーション

従来型アプリケーションをSPAとの対比という意味で昨今はMPAと呼ぶことが多い（当時からMPAと呼んでいたわけではなかった）
コンピュータの世界で、一連の処理の流れにある背景情報(ユーザ名とか)をコンテキストという
HTTPはステートレスである

一連の流れをセッションという
ブラウザでそのセッション（状態）を管理するのがCookieである


Cookie

Cookieの送信条件は「同じサイトにアクセスした時にそのサイトのCookieを渡す」

同じサイトかは、オリジン（ホスト/スキーム/ポート）で判断する


ただそれ以外にも、サーバーからSet-Cookieヘッダでレスポンスするときに以下のような属性(細かな送信条件)を設定することが可能

Expires/Max-Age

有効期限を表す
どちらも設定されている場合はMax-Ageが優先される
どちらも設定されていない場合はセッションクッキーと呼ばれ、ブラウザが終了するまで有効となる

だが近年のいくつかのブラウザは起動時にタブを復元する機能があり、その際にクッキーも復元される


Domain

どのサーバに対してアクセスした時にクッキーを送信すべきかを設定する

つまり、サーバからクライアントへの送信条件の制御


example.comと指定した場合は、sub.example.comのようなサブドメインも含まれる

未指定の場合は、上記のようなサブドメインはCookieは送信されない


例えば親ドメインで発行したクッキーを、サブドメインにあるサーバに送ってほしい時とかに使用する


HttpOnly

JSからのアクセスを禁止する


外部への漏洩を防ぐために推奨される設定

Domain: 未指定（発行したドメインだけに送信されるようにする）
Secure: HTTPS通信時のみ
HttpOnly: JSからアクセス禁止させる
SameSite: Lax or Strict


DomainとSameSiteの違い

Domainは送信先の制限、SameSiteは送信元の制限
Domain指定なし:

同一ドメインしかCookieを送信しない


Domainにexample.comを設定:

sub.example.comにもCookieを送信する


SameSite指定なし(Lax):

一部のクロスサイトリクエスト（GETメソッドのナビゲーションなど）でもCookieを送信する


SameSiteにStrictを設定:

同一サイトのみCookieを送信する
malicious.comというサイトからexample.comへのアクセス時はCookieを送信しないといったイメージ


SameSiteにNoneを設定:

いかなるクロスサイトのリクエストでもCookieを送信する


まとめると、

Domainは、どこにCookieを送信するかの設定
SameSiteは、どこからCookieを送信するかの設定










セッション

Cookieを用いてセッションを管理する
セッションの盗用(セッションハイジャック)を防ぐ方法として

固定や推測されやすい値を使用しない




サードパーティクッキーと個人情報保護

あるサイトAに訪問した時に広告画像をクリックした際に、このユーザー(ブラウザ)はこの広告をクリックしたよというCookieをセットする
別のサイトBにアクセスし、広告画像を表示する際に、広告側にはこのユーザーが過去にクリックした広告情報をCookieから取得し、異なるサイト間でも同じような広告を表示させるという仕組み


セッションとユーザー管理

セッションベースでのToDoアプリ例を見ると、セッション単位＝ブラウザ単位となるので、ユーザー情報を異なるブラウザで保持させることができない問題がある
ここで登場するのが「認証」という仕組みになる



7章 SPAへの進化
(この章の背景を補足)">
<meta name="author" content="nyuusen">
<link rel="canonical" href="http://localhost:1313/my-hugo-blog/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/">
<link crossorigin="anonymous" href="/my-hugo-blog/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/my-hugo-blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/my-hugo-blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/my-hugo-blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/my-hugo-blog/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/my-hugo-blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/my-hugo-blog/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="http://localhost:1313/my-hugo-blog/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/">
  <meta property="og:site_name" content="nyuusen blog">
  <meta property="og:title" content="改訂新版プロになるためのWeb技術入門">
  <meta property="og:description" content="参考にしたもの https://www.youtube.com/live/5WZDiKol8k4?si=snrgHWB_KgGl3jTe
3章 WWWの基本要素とその発展 データ交換にHTMLは適さない(プログラムで取り扱うのが困難) そんな背景があり登場したのがXML どういうデータ構造なのかの決まりをスキーマという XMLではDOCTYPE宣言でdtdファイルでスキーマを指定できる スキーマレスのJSONやYAMLが流行ったが、結局JSONスキーマが流行ったり、流行は繰り返される XMLは人が扱うには複雑ではあるが、今でもExcelやe-taxなどコンピュータが読み取るデータとしては 多く利用される そこからXHTMLも開発されたが、制約が多かったりあまり歓迎されなかった(流行らなかった) 4章 HTTPクライアントとHTTPサーバー CGI: リクエストパスに応じてプログラムを起動する、今ではあまり見かけないが、このあとの発展に重要 動的にHTMLを返す、テンプレートエンジンの登場 上記を礎に、ブラウザなのでインストール不要であり、自由度の高いUIを実現できるWebアプリケーションが発展していくことになる 5章 URLとHTTP URLからwww.が消えたのは、クラウドの台頭とサブドメインを気軽にはやせることができるようになり、昔のようにホストとWebサーバの結びつきが弱くなったため 開発時にウェルナウンポートを使用すると起動のたびにsudo権限が必要なため、8080のようなポートを使うことが多い ブラウザはURLパスに含まれる拡張子ではなく、MIMEタイプ(Content-Type)を見てどのように扱うかを決めている GETリクエストでリソース状態を変更できるような実装すべきじゃない理由は、検索クローラによるアクセスでリソースが意図せず変化してしまうことを避けるということも理由にある よく見るフォーム再送信の確認ダイアログはPOSTリクエストが二重に行われることによる、不利益を避けるため 6章 従来型のWebアプリケーション 従来型アプリケーションをSPAとの対比という意味で昨今はMPAと呼ぶことが多い（当時からMPAと呼んでいたわけではなかった） コンピュータの世界で、一連の処理の流れにある背景情報(ユーザ名とか)をコンテキストという HTTPはステートレスである 一連の流れをセッションという ブラウザでそのセッション（状態）を管理するのがCookieである Cookie Cookieの送信条件は「同じサイトにアクセスした時にそのサイトのCookieを渡す」 同じサイトかは、オリジン（ホスト/スキーム/ポート）で判断する ただそれ以外にも、サーバーからSet-Cookieヘッダでレスポンスするときに以下のような属性(細かな送信条件)を設定することが可能 Expires/Max-Age 有効期限を表す どちらも設定されている場合はMax-Ageが優先される どちらも設定されていない場合はセッションクッキーと呼ばれ、ブラウザが終了するまで有効となる だが近年のいくつかのブラウザは起動時にタブを復元する機能があり、その際にクッキーも復元される Domain どのサーバに対してアクセスした時にクッキーを送信すべきかを設定する つまり、サーバからクライアントへの送信条件の制御 example.comと指定した場合は、sub.example.comのようなサブドメインも含まれる 未指定の場合は、上記のようなサブドメインはCookieは送信されない 例えば親ドメインで発行したクッキーを、サブドメインにあるサーバに送ってほしい時とかに使用する HttpOnly JSからのアクセスを禁止する 外部への漏洩を防ぐために推奨される設定 Domain: 未指定（発行したドメインだけに送信されるようにする） Secure: HTTPS通信時のみ HttpOnly: JSからアクセス禁止させる SameSite: Lax or Strict DomainとSameSiteの違い Domainは送信先の制限、SameSiteは送信元の制限 Domain指定なし: 同一ドメインしかCookieを送信しない Domainにexample.comを設定: sub.example.comにもCookieを送信する SameSite指定なし(Lax): 一部のクロスサイトリクエスト（GETメソッドのナビゲーションなど）でもCookieを送信する SameSiteにStrictを設定: 同一サイトのみCookieを送信する malicious.comというサイトからexample.comへのアクセス時はCookieを送信しないといったイメージ SameSiteにNoneを設定: いかなるクロスサイトのリクエストでもCookieを送信する まとめると、 Domainは、どこにCookieを送信するかの設定 SameSiteは、どこからCookieを送信するかの設定 セッション Cookieを用いてセッションを管理する セッションの盗用(セッションハイジャック)を防ぐ方法として 固定や推測されやすい値を使用しない サードパーティクッキーと個人情報保護 あるサイトAに訪問した時に広告画像をクリックした際に、このユーザー(ブラウザ)はこの広告をクリックしたよというCookieをセットする 別のサイトBにアクセスし、広告画像を表示する際に、広告側にはこのユーザーが過去にクリックした広告情報をCookieから取得し、異なるサイト間でも同じような広告を表示させるという仕組み セッションとユーザー管理 セッションベースでのToDoアプリ例を見ると、セッション単位＝ブラウザ単位となるので、ユーザー情報を異なるブラウザで保持させることができない問題がある ここで登場するのが「認証」という仕組みになる 7章 SPAへの進化 (この章の背景を補足)">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-05-19T23:08:39+09:00">
    <meta property="article:modified_time" content="2025-05-19T23:08:39+09:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="改訂新版プロになるためのWeb技術入門">
<meta name="twitter:description" content="参考にしたもの
https://www.youtube.com/live/5WZDiKol8k4?si=snrgHWB_KgGl3jTe
3章 WWWの基本要素とその発展

データ交換にHTMLは適さない(プログラムで取り扱うのが困難)
そんな背景があり登場したのがXML
どういうデータ構造なのかの決まりをスキーマという
XMLではDOCTYPE宣言でdtdファイルでスキーマを指定できる
スキーマレスのJSONやYAMLが流行ったが、結局JSONスキーマが流行ったり、流行は繰り返される
XMLは人が扱うには複雑ではあるが、今でもExcelやe-taxなどコンピュータが読み取るデータとしては
多く利用される
そこからXHTMLも開発されたが、制約が多かったりあまり歓迎されなかった(流行らなかった)

4章 HTTPクライアントとHTTPサーバー

CGI: リクエストパスに応じてプログラムを起動する、今ではあまり見かけないが、このあとの発展に重要
動的にHTMLを返す、テンプレートエンジンの登場
上記を礎に、ブラウザなのでインストール不要であり、自由度の高いUIを実現できるWebアプリケーションが発展していくことになる

5章 URLとHTTP

URLからwww.が消えたのは、クラウドの台頭とサブドメインを気軽にはやせることができるようになり、昔のようにホストとWebサーバの結びつきが弱くなったため
開発時にウェルナウンポートを使用すると起動のたびにsudo権限が必要なため、8080のようなポートを使うことが多い
ブラウザはURLパスに含まれる拡張子ではなく、MIMEタイプ(Content-Type)を見てどのように扱うかを決めている
GETリクエストでリソース状態を変更できるような実装すべきじゃない理由は、検索クローラによるアクセスでリソースが意図せず変化してしまうことを避けるということも理由にある
よく見るフォーム再送信の確認ダイアログはPOSTリクエストが二重に行われることによる、不利益を避けるため

6章 従来型のWebアプリケーション

従来型アプリケーションをSPAとの対比という意味で昨今はMPAと呼ぶことが多い（当時からMPAと呼んでいたわけではなかった）
コンピュータの世界で、一連の処理の流れにある背景情報(ユーザ名とか)をコンテキストという
HTTPはステートレスである

一連の流れをセッションという
ブラウザでそのセッション（状態）を管理するのがCookieである


Cookie

Cookieの送信条件は「同じサイトにアクセスした時にそのサイトのCookieを渡す」

同じサイトかは、オリジン（ホスト/スキーム/ポート）で判断する


ただそれ以外にも、サーバーからSet-Cookieヘッダでレスポンスするときに以下のような属性(細かな送信条件)を設定することが可能

Expires/Max-Age

有効期限を表す
どちらも設定されている場合はMax-Ageが優先される
どちらも設定されていない場合はセッションクッキーと呼ばれ、ブラウザが終了するまで有効となる

だが近年のいくつかのブラウザは起動時にタブを復元する機能があり、その際にクッキーも復元される


Domain

どのサーバに対してアクセスした時にクッキーを送信すべきかを設定する

つまり、サーバからクライアントへの送信条件の制御


example.comと指定した場合は、sub.example.comのようなサブドメインも含まれる

未指定の場合は、上記のようなサブドメインはCookieは送信されない


例えば親ドメインで発行したクッキーを、サブドメインにあるサーバに送ってほしい時とかに使用する


HttpOnly

JSからのアクセスを禁止する


外部への漏洩を防ぐために推奨される設定

Domain: 未指定（発行したドメインだけに送信されるようにする）
Secure: HTTPS通信時のみ
HttpOnly: JSからアクセス禁止させる
SameSite: Lax or Strict


DomainとSameSiteの違い

Domainは送信先の制限、SameSiteは送信元の制限
Domain指定なし:

同一ドメインしかCookieを送信しない


Domainにexample.comを設定:

sub.example.comにもCookieを送信する


SameSite指定なし(Lax):

一部のクロスサイトリクエスト（GETメソッドのナビゲーションなど）でもCookieを送信する


SameSiteにStrictを設定:

同一サイトのみCookieを送信する
malicious.comというサイトからexample.comへのアクセス時はCookieを送信しないといったイメージ


SameSiteにNoneを設定:

いかなるクロスサイトのリクエストでもCookieを送信する


まとめると、

Domainは、どこにCookieを送信するかの設定
SameSiteは、どこからCookieを送信するかの設定










セッション

Cookieを用いてセッションを管理する
セッションの盗用(セッションハイジャック)を防ぐ方法として

固定や推測されやすい値を使用しない




サードパーティクッキーと個人情報保護

あるサイトAに訪問した時に広告画像をクリックした際に、このユーザー(ブラウザ)はこの広告をクリックしたよというCookieをセットする
別のサイトBにアクセスし、広告画像を表示する際に、広告側にはこのユーザーが過去にクリックした広告情報をCookieから取得し、異なるサイト間でも同じような広告を表示させるという仕組み


セッションとユーザー管理

セッションベースでのToDoアプリ例を見ると、セッション単位＝ブラウザ単位となるので、ユーザー情報を異なるブラウザで保持させることができない問題がある
ここで登場するのが「認証」という仕組みになる



7章 SPAへの進化
(この章の背景を補足)">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/my-hugo-blog/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "改訂新版プロになるためのWeb技術入門",
      "item": "http://localhost:1313/my-hugo-blog/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "改訂新版プロになるためのWeb技術入門",
  "name": "改訂新版プロになるためのWeb技術入門",
  "description": "参考にしたもの https://www.youtube.com/live/5WZDiKol8k4?si=snrgHWB_KgGl3jTe\n3章 WWWの基本要素とその発展 データ交換にHTMLは適さない(プログラムで取り扱うのが困難) そんな背景があり登場したのがXML どういうデータ構造なのかの決まりをスキーマという XMLではDOCTYPE宣言でdtdファイルでスキーマを指定できる スキーマレスのJSONやYAMLが流行ったが、結局JSONスキーマが流行ったり、流行は繰り返される XMLは人が扱うには複雑ではあるが、今でもExcelやe-taxなどコンピュータが読み取るデータとしては 多く利用される そこからXHTMLも開発されたが、制約が多かったりあまり歓迎されなかった(流行らなかった) 4章 HTTPクライアントとHTTPサーバー CGI: リクエストパスに応じてプログラムを起動する、今ではあまり見かけないが、このあとの発展に重要 動的にHTMLを返す、テンプレートエンジンの登場 上記を礎に、ブラウザなのでインストール不要であり、自由度の高いUIを実現できるWebアプリケーションが発展していくことになる 5章 URLとHTTP URLからwww.が消えたのは、クラウドの台頭とサブドメインを気軽にはやせることができるようになり、昔のようにホストとWebサーバの結びつきが弱くなったため 開発時にウェルナウンポートを使用すると起動のたびにsudo権限が必要なため、8080のようなポートを使うことが多い ブラウザはURLパスに含まれる拡張子ではなく、MIMEタイプ(Content-Type)を見てどのように扱うかを決めている GETリクエストでリソース状態を変更できるような実装すべきじゃない理由は、検索クローラによるアクセスでリソースが意図せず変化してしまうことを避けるということも理由にある よく見るフォーム再送信の確認ダイアログはPOSTリクエストが二重に行われることによる、不利益を避けるため 6章 従来型のWebアプリケーション 従来型アプリケーションをSPAとの対比という意味で昨今はMPAと呼ぶことが多い（当時からMPAと呼んでいたわけではなかった） コンピュータの世界で、一連の処理の流れにある背景情報(ユーザ名とか)をコンテキストという HTTPはステートレスである 一連の流れをセッションという ブラウザでそのセッション（状態）を管理するのがCookieである Cookie Cookieの送信条件は「同じサイトにアクセスした時にそのサイトのCookieを渡す」 同じサイトかは、オリジン（ホスト/スキーム/ポート）で判断する ただそれ以外にも、サーバーからSet-Cookieヘッダでレスポンスするときに以下のような属性(細かな送信条件)を設定することが可能 Expires/Max-Age 有効期限を表す どちらも設定されている場合はMax-Ageが優先される どちらも設定されていない場合はセッションクッキーと呼ばれ、ブラウザが終了するまで有効となる だが近年のいくつかのブラウザは起動時にタブを復元する機能があり、その際にクッキーも復元される Domain どのサーバに対してアクセスした時にクッキーを送信すべきかを設定する つまり、サーバからクライアントへの送信条件の制御 example.comと指定した場合は、sub.example.comのようなサブドメインも含まれる 未指定の場合は、上記のようなサブドメインはCookieは送信されない 例えば親ドメインで発行したクッキーを、サブドメインにあるサーバに送ってほしい時とかに使用する HttpOnly JSからのアクセスを禁止する 外部への漏洩を防ぐために推奨される設定 Domain: 未指定（発行したドメインだけに送信されるようにする） Secure: HTTPS通信時のみ HttpOnly: JSからアクセス禁止させる SameSite: Lax or Strict DomainとSameSiteの違い Domainは送信先の制限、SameSiteは送信元の制限 Domain指定なし: 同一ドメインしかCookieを送信しない Domainにexample.comを設定: sub.example.comにもCookieを送信する SameSite指定なし(Lax): 一部のクロスサイトリクエスト（GETメソッドのナビゲーションなど）でもCookieを送信する SameSiteにStrictを設定: 同一サイトのみCookieを送信する malicious.comというサイトからexample.comへのアクセス時はCookieを送信しないといったイメージ SameSiteにNoneを設定: いかなるクロスサイトのリクエストでもCookieを送信する まとめると、 Domainは、どこにCookieを送信するかの設定 SameSiteは、どこからCookieを送信するかの設定 セッション Cookieを用いてセッションを管理する セッションの盗用(セッションハイジャック)を防ぐ方法として 固定や推測されやすい値を使用しない サードパーティクッキーと個人情報保護 あるサイトAに訪問した時に広告画像をクリックした際に、このユーザー(ブラウザ)はこの広告をクリックしたよというCookieをセットする 別のサイトBにアクセスし、広告画像を表示する際に、広告側にはこのユーザーが過去にクリックした広告情報をCookieから取得し、異なるサイト間でも同じような広告を表示させるという仕組み セッションとユーザー管理 セッションベースでのToDoアプリ例を見ると、セッション単位＝ブラウザ単位となるので、ユーザー情報を異なるブラウザで保持させることができない問題がある ここで登場するのが「認証」という仕組みになる 7章 SPAへの進化 (この章の背景を補足)\n",
  "keywords": [
    
  ],
  "articleBody": "参考にしたもの https://www.youtube.com/live/5WZDiKol8k4?si=snrgHWB_KgGl3jTe\n3章 WWWの基本要素とその発展 データ交換にHTMLは適さない(プログラムで取り扱うのが困難) そんな背景があり登場したのがXML どういうデータ構造なのかの決まりをスキーマという XMLではDOCTYPE宣言でdtdファイルでスキーマを指定できる スキーマレスのJSONやYAMLが流行ったが、結局JSONスキーマが流行ったり、流行は繰り返される XMLは人が扱うには複雑ではあるが、今でもExcelやe-taxなどコンピュータが読み取るデータとしては 多く利用される そこからXHTMLも開発されたが、制約が多かったりあまり歓迎されなかった(流行らなかった) 4章 HTTPクライアントとHTTPサーバー CGI: リクエストパスに応じてプログラムを起動する、今ではあまり見かけないが、このあとの発展に重要 動的にHTMLを返す、テンプレートエンジンの登場 上記を礎に、ブラウザなのでインストール不要であり、自由度の高いUIを実現できるWebアプリケーションが発展していくことになる 5章 URLとHTTP URLからwww.が消えたのは、クラウドの台頭とサブドメインを気軽にはやせることができるようになり、昔のようにホストとWebサーバの結びつきが弱くなったため 開発時にウェルナウンポートを使用すると起動のたびにsudo権限が必要なため、8080のようなポートを使うことが多い ブラウザはURLパスに含まれる拡張子ではなく、MIMEタイプ(Content-Type)を見てどのように扱うかを決めている GETリクエストでリソース状態を変更できるような実装すべきじゃない理由は、検索クローラによるアクセスでリソースが意図せず変化してしまうことを避けるということも理由にある よく見るフォーム再送信の確認ダイアログはPOSTリクエストが二重に行われることによる、不利益を避けるため 6章 従来型のWebアプリケーション 従来型アプリケーションをSPAとの対比という意味で昨今はMPAと呼ぶことが多い（当時からMPAと呼んでいたわけではなかった） コンピュータの世界で、一連の処理の流れにある背景情報(ユーザ名とか)をコンテキストという HTTPはステートレスである 一連の流れをセッションという ブラウザでそのセッション（状態）を管理するのがCookieである Cookie Cookieの送信条件は「同じサイトにアクセスした時にそのサイトのCookieを渡す」 同じサイトかは、オリジン（ホスト/スキーム/ポート）で判断する ただそれ以外にも、サーバーからSet-Cookieヘッダでレスポンスするときに以下のような属性(細かな送信条件)を設定することが可能 Expires/Max-Age 有効期限を表す どちらも設定されている場合はMax-Ageが優先される どちらも設定されていない場合はセッションクッキーと呼ばれ、ブラウザが終了するまで有効となる だが近年のいくつかのブラウザは起動時にタブを復元する機能があり、その際にクッキーも復元される Domain どのサーバに対してアクセスした時にクッキーを送信すべきかを設定する つまり、サーバからクライアントへの送信条件の制御 example.comと指定した場合は、sub.example.comのようなサブドメインも含まれる 未指定の場合は、上記のようなサブドメインはCookieは送信されない 例えば親ドメインで発行したクッキーを、サブドメインにあるサーバに送ってほしい時とかに使用する HttpOnly JSからのアクセスを禁止する 外部への漏洩を防ぐために推奨される設定 Domain: 未指定（発行したドメインだけに送信されるようにする） Secure: HTTPS通信時のみ HttpOnly: JSからアクセス禁止させる SameSite: Lax or Strict DomainとSameSiteの違い Domainは送信先の制限、SameSiteは送信元の制限 Domain指定なし: 同一ドメインしかCookieを送信しない Domainにexample.comを設定: sub.example.comにもCookieを送信する SameSite指定なし(Lax): 一部のクロスサイトリクエスト（GETメソッドのナビゲーションなど）でもCookieを送信する SameSiteにStrictを設定: 同一サイトのみCookieを送信する malicious.comというサイトからexample.comへのアクセス時はCookieを送信しないといったイメージ SameSiteにNoneを設定: いかなるクロスサイトのリクエストでもCookieを送信する まとめると、 Domainは、どこにCookieを送信するかの設定 SameSiteは、どこからCookieを送信するかの設定 セッション Cookieを用いてセッションを管理する セッションの盗用(セッションハイジャック)を防ぐ方法として 固定や推測されやすい値を使用しない サードパーティクッキーと個人情報保護 あるサイトAに訪問した時に広告画像をクリックした際に、このユーザー(ブラウザ)はこの広告をクリックしたよというCookieをセットする 別のサイトBにアクセスし、広告画像を表示する際に、広告側にはこのユーザーが過去にクリックした広告情報をCookieから取得し、異なるサイト間でも同じような広告を表示させるという仕組み セッションとユーザー管理 セッションベースでのToDoアプリ例を見ると、セッション単位＝ブラウザ単位となるので、ユーザー情報を異なるブラウザで保持させることができない問題がある ここで登場するのが「認証」という仕組みになる 7章 SPAへの進化 (この章の背景を補足)\n第2次ブラウザ戦争を経てGoogleがV8というJSエンジンを開発し、JSがとても速く実行できるようになった\nその結果、こんな速いならサーバーサイドでも使えるんじゃね？となり、Nodeが登場\n従来型の遷移が多く遅い・サーバからの通知ができない問題を解決したのがSPA\nRIA(Flash)が流行りきらなかった理由としてクローズドな技術だったことが挙げられる。以降は標準化された技術の積み重ねで進化してきている\nDOM\nブラウザはHTMLを読み込むと、内部でDOMというツリー状のデータ構造を構築する このDOMがJavaScriptからHTMLを操作するための仕様 イベントドリブンプログラミング\n一般的なプログラムは逐次処理で上から下に記述された順で処理されるが、GUIのようなユーザー操作が基点となる処理では、逐次処理の書き方が複雑になる そこで生まれたのがイベントドリブンで、ユーザ操作などのイベントを起点とし、そのイベントが発生したときに実行すべき処理を、そのイベントと紐づけて記述する。これをイベントハンドラやイベントリスナと呼ぶ。 JSでは、addEventListnerで関数登録できる JavaScriptは、ブラウザ戦争やブラウザ間の互換性差異に課題があった背景があり、ECMAScriptという標準化団体が標準化を進めた\nこれにより、各ブラウザに内蔵されるJavaScriptエンジンは異なるものの、ECMAScriptに準拠しているため、互換性が保たれている 同期処理から非同期処理へ\n同期処理だと、処理中にブラウザでの操作がブロックされ、体験があまりよくない XMLHttpRequest\nXMLとついているが、実際にはXMLと強い結びつきはない 事実JSONでやり取りすることが多い XMLとJSON\nXMLは構造化されたデータをテキストでやり取りできるが、パース処理が比較的重いのが欠点 XMLの代わりとなったのがJSONで、JSの文法をそのまま使ってデータ表現をしている（のでパースが楽） ReactやVue.jsの存在\nDOM APIのみを使って、JSで画面を構築するのは結構大変なので、表題のようなFWを使用する SPAでは画面表示内容を全てJSで構築する フラグメントによる状態変化の表現\nSPAはURLパスが変わらないので、ブックマークやブラウザの戻る進むができない フラグメントは、見出しごとにアンカーを定義して、フラグメントでそれを参照するみたいなやつ URLのフラグメント部はサーバーへ送信されない（リクエストが発生しない） JSからはlocationオブジェクトで参照可能 SPAではフラグメントを活用することで、状態ごとにURLパスを変えることができる（というよりは、フラグメントを元に表示状態を復元している） SPAの課題\n検索エンジンとの相性の悪さ SPAはHTMLがほとんど空っぽなので（JSで構築するので）クローラが(JS実行前の何もない状態の)HTMLを解析しても適切にインデックスが構築できない また、URLのフラグメント部はインデックス対象にならないので、フラグメント部に固有の商品ID的なものを埋め込んでも、商品固有のインデックスを構築できない ただ、現在はJSでレンダリングされたページでもある程度読み取れるように、クローラが改善されている 初期表示の遅さ JSで必要な情報をAPIから収集したり、その上で画面を構築していくので、どうしても初期描画が遅くなる SPAの課題に対するアプローチ\nHistoryAPIによる画面遷移 HTML5で登場したブラウザのAPI アドレスバーに表示させるURLや履歴をJSから操作できる SPAの非同期通信を活用した高速な画面切り替えという強みを残しつつ、URL変更に伴う擬似的な画面遷移を実現できるようになった 実装的には、aタグリンククリック時のイベントリスナのコールバック関数の中で、e.preventDefault();を実行し、ブラウザが本来行うページ遷移機能を奪い、JSでHistoryAPIを実行する もし仮にURLパスが含まれた状態でリロードされてもきちんとページが返るように、サーバ側ではindex.htmlを返すように実装する必要がある HistoryAPIとフラグメント方式は一長一短 アプリケーション内の画面を検索エンジンにインデックスさせる必要がないなら、フラグメント方式でも良い（実際Gmailはフラグメント方式） フラグメント方式は、サーバ側での実装考慮が不要であり、実現方法が簡単 HistoryAPI方式は、サーバ側での考慮必要で実装が複雑だが、検索エンジンとの相性が良い サーバーサイドレンダリングへの回帰 HistoryAPIにより、SPAでもフラグメントに頼らず、画面とURLを一致させられるようになったものの、JSが実行されるまではページ内容がわからない＝検索エンジンがインデックスできないという問題がある それに加えて、初期表示の遅さという2つの課題を解決するものとしてサーバーサイドレンダリング これは初期表示に限って、HTMLをサーバー側で生成して返すというもの ちなみに初期表示の遅さは色々な要因があり、JSのコードを1つにまとめて、変数名や関数名を短くするミニファイ等がある AltJS\nJSはES2015まで停滞していた、サーバーサイドとは異なりブラウザで唯一動く言語の停滞はクライアントサイドの開発においては大きな影響がある そんな中、JSにトランスパイル言語を開発することで、それらをAltJSと呼ぶ 生き残ったのがTypeScriptとなる 8章 WebAPI SPAの普及により、URLがコンテンツを返すではなく、アプリケーション・プログラムの関数呼び出しの位置付けに変化 インターネットを経由したAPIの呼び出し、すなわちWebAPIが普及していった COBRAとSOAPを経て、WebAPIの普及へ WebAPIは設計の自由度が高いので、1つの指針を示したのがRESTになる RESTをWebAPIに当てはめて具体化する（リソース指向アーキテクチャ） さまざまな情報の集まりをリソースと表現する RESTに基づいたAPIは、リソースに対する操作を提供するという考え方で、次の4つの特性を持つ リソースの示し方：リソースを表すURLがあり、URLによってリソースにアクセスできる /addとかではなく、/todoというリソースを指す場所 リソースのたどり方：あるリソースから別のリソースを辿ることができる リソースの操作方法：リソースに対して何をしたいかはHTTPメソッドで表現する リソース操作の手順：リソース操作に手順は不要で、一度のやり取りで求められる結果が得られる ステートレスは、サーバーに状態を持たせてしまうとシステム規模に応じてサーバー台数を増やしにくくなってしまうため POSTとHTTPステータスの使い分け POSTメソッドには、以下の2つの役割がある 子リソースの新規追加（TODOリストへの追加等、フォルダの中に新規ファイルを1つ作成するイメージ） 既存リソースへの追加（既にあるファイルに追記するイメージ） 子リソースへの追加の場合は、201 CreatedでLocationヘッダに作成したリソースのURLを返すべきとされている 一方、既存リソースへの追加の場合は、対象が既に存在しているため、200 OKを返すだけで良いとされている オーバーロードPOST 本来使用したいメソッドが使えない場合、POSTリクエストのヘッダにX-HTTP-Method-Overrideとして本来使用したいメソッド(DELETE等)を設定する手法もある なお、X-で始まるヘッダは非標準のカスタムヘッダを意味する 再注目されるRPCスタイル RESTに則ったAPIでは「オーバー/アンダーフェッチング」「N＋1問題」がある（つまり欲しい情報を手に入れるのに足りなかった理、逆に多すぎるというケースがあると理解） そこで注目されたのが「GraphQL」である QueryLanguageなので、SQLと立て付けは同じで、SQLはデータを対象とし、GraphQLはオブジェクトを対象とする 問い合わせ対象となるデータ構造を「スキーマ」として問い合わせパターンを定義する 問い合わせパターンを「クエリ」と表現し、パラメータ部分（どのデータが欲しいか等）はクライアント側で自由に決められる /graphqlという1つのエンドポイントに、クエリ文字列をPOSTメソッドを送信する Mutationというデータ更新の場合も同じ（クエリをURLに含めることができず、ボディにセットする必要があるためこの仕組みになっている） 欲しいデータを指定できるので、「オーバー/アンダーフェッチング」「N＋1問題」も解決 GraphQLは、SOAPのようなRPCに近い仕組みになっている SOAPは、RESTによって駆逐されてしまったが、結局APIだけでは全てのニーズを満たすことができなかった どっちがダメではなく相互補完である 9章 サーバプッシュ技術 サーバプッシュ技術の歴史 当初のWWWで新たな情報を取得するためには同じURLにアクセスしてコンテンツを取得する必要があった これをPull型通信と呼ぶ これに対して、サーバからクライアントに情報を送信することをサーバプッシュと呼ぶ メタリフレッシュによる擬似サーバプッシュ 初期のWWWで使用されていたのがmeta refreshというHTMLの機能 meta要素に従って、URLを再ロードさせる 簡単ではあるが、即時性が求められるシーンでは現実的な手段ではないし、ページリロードが走るのでUX的にも良くなかった 通信量の削減 ブラウザキャッシュという仕組み サーバ側がコンテンツ提供時にキャッシュ有効期間をきめ、その期間内はブラウザ側で保持し、それを表示に使用することで通信量を削減する Ajaxによるポーリング setInterval関数で定期ポーリング 定期的にFetchを行い、変更が必要な情報だけをJSONで取得することで、ページ全体のHTMLを返すよりも通信量を削減できる Comet(ロングポーリング) これは、クライアントがリクエストを送り、サーバはしばらく待ってからレスポンスを返すことでプッシュ風に見せる手法（今や古典的） キャッシュやAjaxでは即時性を向上させるのが難しい HTTPレスポンスの返し方を工夫することで、HTTPの枠組みの中で即時性を向上させる技術「Comet」が登場した Cometとは？ 意図的にレスポンスを保留し、通知すべき情報が変化が発生して初めてレスポンスを返す サーバは待ち時間が発生するがAjaxによる非同期通信であればユーザーに影響はない クライアント側はレスポンスを受け取ったらすぐにリクエストを送り（以下ループ） Cometの問題点 一度サーバから情報を送信すると再接続が必要なので、高頻度で更新されるような場合はネットワークやサーバに負荷がかかる また、一定時間経過すると、ブラウザや途中経過のプロキシサーバによって、通信が切断される 即時性の面でも、レスポンスを返し、再度接続されるまでの間は、すぐに通知ができない という問題点を抱えたが、既存の技術を使ってプッシュ技術が実現できるので、長く使われた Server-sent eventsによるプッシュ配信 Cometは既存の技術を使用し、無理矢理実現している感があった そんな状況で、HTML5で関連のAPIの1つとして制定されたのがServer-sent events Cometによるロングポーリングを1歩進めたHTTPストリーミング ロングポーリングでは1度レスポンスを返すと再接続が必要という課題があったが、HTTPストリーミングではレスポンスを少しずつ返すことで、一度のリクエストに対してサーバからの通知を連続して行うことができる これはHTTP1.1で追加されたチャンク転送という機能に基づいている チャンク転送 chunkとは塊のこと リクエストやレスポンスをいくつかの塊に分割して送信する機能 チャンク転送でレスポンスを返すには、Transfer-Encoding: chunkedというヘッダを返し、以下のような形式でデータの塊を少しづつ返す データを全て送信したら、最後に0を送信して、転送終了の合図とする クライアントはすべてのデータを持つことなく、チャンク単位で受け取って処理ができるので、総量が分からないデータを送信するのに役立つ Server-sent events(SSE) SSEとは、サーバーからクライアントへの一方向リアルタイム通信を実現する技術で、クライアントはJavaScriptのEventSourceというAPIを使い、サーバーからのイベントストリームを受け取る 普通のHTTPリクエストを送った後、サーバーがContent-Type: text/event-streamでストリームを送り続ける あくまでMIMEタイプtextで、UTF-8エンコードされたテキストを配信するので、バイナリには向いてない（Base64エンコードしてテキストに変換して送ることは可能ではあるが、サイズ膨らむし非効率なので..） SSEの考え方はチャンク転送と同じだが、レスポンスの返し方が少し異なる Content-Type: text/event-streamというヘッダが、SSEによる応答を表す ついでにConnection: keep-aliveも必要で、これはリクエストを受信したサーバがレスポンスを返した後も通信を持続させることをお願いするもの SSEでは、サーバから通知する情報をチャンクとして返すが、個々をイベントと呼ぶ イベントの連なりによって構成される応答全体を「イベント・ストリーム」と呼ぶ チャンク転送とは異なり、サーバーかクライアントのどちらかが通信を止めない限り、通信が続く チャンク転送のような最後に0を送信して終わり合図みたいなものはないので、必要であれば終了を表す合図を決めても良い SSEの受信処理 チャンク転送と異なり、受信側であるブラウザは標準APIで受信を簡単に処理できる（EventSourceオブジェクト） SSEのメリット 標準APIで扱えるので、Comet等に比べると手軽に利用できる HTTPで通信するので、FWやプロキシなど通信経路上の機器の設定変更等が不要 注意点 多くのブラウザではサーバ側の負荷をかけない目的で、同一ドメインのサーバーに対する同時接続は6つまで SSEのサーバー側の送信処理 レスポンス自体は簡単だが、内部処理は少し難しくなる… サーバーがブラウザからリクエストを受信するとサーバーはイベントを送信し続ける必要があるが、その間にもサーバー側はToDoの取得や追加のリクエストを処理することができる ToDoの追加や更新があった時に、それをサーバー内部でSSEの送信処理に通知する必要がある これを実現するには「並行処理」という手法が必要で、この本で紹介されているサーバー実装はGoで書かれているため、ゴルーチンを起動し、チャネルでゴルーチン同士で情報伝達を行っている WebSocket CometもSSEも、クライアントからリクエストを送信する必要があるというHTTP本来の性質は変わっておらず、双方向通信ができないという点やオーバーヘッド（TCP接続処理やヘッダ）が大きいという点に改善の余地があった そんな中生まれたのが双方向・高頻度・大量の通信を実現するWebSocketという新たなプロトコル Comet、SSEはあくまで既存のHTTPに則っていたのに対し、ほとんど別のプロトコルとして作られた(httpではなくws) 最初はHTTPで通信を始め、プロトコルアップグレードという仕組みでWebSocketに切り替える HTTPと比較すると、ヘッダ相当の情報のやり取りがなく、送受信に伴いオーバーヘッドがとても少ないのが特徴 HTTPは毎回封筒に入れてやり取り、WebSocketは電話を繋げっぱなしでやり取りみたいなイメージ イメージは以下 ((SSE), HTTP) — TCP — IP HTTP |→| WebSockets — TCP — IP WebSocketのハンドシェイク 通信を始める時のハンドシェイクでプロトコルアップグレードという仕組みを使用する これは簡単にいうと最初はHTTPで通信を開始し、ここから別の言葉で話しましょうと別のプロトコルに切り替えるもの HTTPリクエストヘッダにConnection: Upgrade, Upgrade: websocketを指定することで、クライアントがWebSocket通信を希望することがわかる WebSocket上でどのような通信をするかはアプリケーションに委ねられている WebSocket上での通信の取り決めは「サブプロトコル」といい、クライアントが希望するサブプロトコルをSec-WebSocket-Protocolヘッダで通知できるようになっている Sec-WebSocket-Keyヘッダは、クライアントとサーバーが互いにWebSocketに対応していることを確認するためのもので、クライアントからはnonceと呼ばれるランダムに生成した文字列をセットする サーバーからの応答 クライアントからのアップグレード要求に対し、101を返す（その要求を了承したことを示す） クライアントから受け取ったSec-WebSocket-Keyの値(nonce)を、規定通りに変換した値をレスポンスヘッダSec-WebSocket-Acceptにセットすることで、サーバーがWebSocketに対応していることを確認する 規定通りに変換: nonceをSHA-1ハッシュ化→Base64エンコード 秘匿性はないが、WebSocketではないサーバーに対して、WebSocket通信を始めてしまうような事故を防ぐため アップグレード後は常時接続となり、双方向にいつでもデータを送ることが可能となる（つまりサーバー側からのプッシュ配信も可能） プロトコルアップグレードの必要性 一般的なサーバ側のセキュリティ設定として80番/443番ポートを防ぐことが多く、仮にWebSocketが別のポートを使用してしまうと、経路の途中で遮断されてしまう可能性があるため WebSocketの課題 SSEと同じようにTCPコネクションが接続しっぱなしになるので、ブラウザ側の同時接続数の制限を受けることもあるし、サーバー側もより多くのクライアントから接続を受け付ける必要がある あくまでHTTPのフリをしているため、ハンドシェイク以降の通信はHTTPではないため、プロキシの処理内容によっては遮断されてしまうことがある プロキシサーバーがある環境では、プロキシサーバーが仲介する通信はHTTP前提で作られていることが多いので、ハンドシェイク以降の通信ができなくなる可能性がある 負荷分散の問題: 1つのサーバーと長時間のTCP接続を行うと、均等に負荷分散されず、特定のサーバーに偏る可能性がある 認証の問題 認証の（標準的な）仕組みがない そのため、アプリケーション側で実装してあげる必要がある 具体的には、WebSocketの通信ではHTTPヘッダーを送らないので、最初の通信でJWTを送るとかいう形で、アプリケーション側で独自実装する形となる 同一オリジンポリシーの制約がない このようになっている背景として、WebSocketは、WebアプリだけではなくネイティブアプリやIoT機器からの接続も想定されているため、Webブラウザ限定のSOPルールに縛られない仕様になっているみたい 対策としては、サーバー側でOriginヘッダを検証する必要がある（Originヘッダはブラウザが自動的に付与するのでJSで改変することはできない） SSEとWebSocketの使い分け ※これは個人的に気になったことのメモ\nSSEが向いているケース ニュース速報配信・株価リアルタイム表示・SNSの新着投稿ありの通知 つまり、サーバーからの一方向の通信でテキスト情報をやり取りしたいシーンで採用される WebSocketが向いているケース チャット、ゲームなどの画像のストリーミングや音声のリアルタイム配信などが向いている つまり、双方向・低レイテンシー・バイナリ対応が求められるシーンで採用される 付録 2進数と16進数 16進数を表記する場合は先頭に0x（ゼロエックス）をつける 16進数はHEXと表現することもある 16進数は4ビットを1桁で表現できるので、4ビット単位で区切って簡潔に表現できたり、2桁でバイト単位を表現できたりとできたりと2進数との相性が良い 16進数がよく使われるシーン 文字コード パーセントエンコーディングやUnicodeのコードポイント表記 カラーコード IPv6アドレス MACアドレス テキストとバイナリ コンピュータ内部での文字列は数字に割り当てられる 例えばAであれば「65」 この対応は、ASCIIと呼ばれ、アメリカの国内規格として制定されたので、この対応表に含まれるのは大小アルファベットと数字といくつかの記号のみ ASCII文字は95種類しかないので、1バイトの範囲に十分収まる テキストデータの符号化方式 コンピュータで文字を数値として表現することを「符号化方式」という 現在はUTF-8という符号化方式に統一されている HTTPではテキストデータでやり取りされており、人間が見て理解しやすいというメリットがある一方、通信効率が悪いというデメリットがある 文字コード 現代のコンピュータは、世界中の文字を扱えるようになっているため、文字コードの仕組みや体系は複雑になっている 日本国内では、日本語を取り扱う文字コードとして「Shift_JIS」が主流だったが、WWWの普及と世界中のコンピュータが情報を交換するようになり、単一の文字コード体系で世界中の文字を扱えるようになる必要が出てきたが、現在はUnicodeという体系に統一されている UTF-8とUnicodeについて Unicodeは、文字の番号表（この文字はU+XXXXだというやつ） 世界中の文字に通し番号を振った辞書 元々は各国独自で文字コードを作っていた（日本はShift_JIS）が、異なる国の文字が混ざったときに文字化けが発生するので、世界共通のUnicodeに統一された UTF-8は、符号化方式の1つでであり、その番号(U+XXXX)をバイト列に変換するルール UTF＝Unicode Transformation Format Unicodeコードポイントを変換するフォーマット・ルールのこと バイト列: 複数バイトが連なったもの（01100001 01100010 01100011（= “abc”）） 軽さや処理効率に応じてUTF-16や32があるが、Webでは軽さ重視のためUTF-8が採用されることが多い（多分ネットワーク経由でやり取りするときに少ないバイト列で表現できた方がデータ量が削減できるからという意味だと思う＋UTF-8は、複数バイトの順番をどう並べるかのビッグ/リトルエンディアンを気にしなくて良いという理由もある） UTF-8では、英数(ASCII文字)は1バイト、日本語は3バイトとなっている 文字境界の判別＝どこからどこまでを1文字とするかは、先頭のビットパターンで区別している（1バイト文字なら先頭ビットが0,2バイト文字なら先頭ビットが110…） 大前提として、 ネットワークは光のON/OFF、ストレージはセルがチャージされているかどうか、つまり0か1というビット単位でしか処理ができない（ハードウェアレイヤの都合） じゃあビットでやり取りすれば良いじゃんという話だが、それでは処理効率が悪い だからコンピュータ内部（CPUやメモリ等）では8ビットを1バイトを最小単位として処理するように設計されている 1バイト＝8ビットである理由は、2の8乗＝256通りであり、英数字などを扱うのにちょうどよかったため これに伴い、通信プロトコルとかでも1バイト単位で送信するようになっている UnicodeとUTF-8の役割 まずコンピュータにはUnicodeの文字と番号が紐づいた表があり、番号から文字を割り出して、実際に文字を表示している じゃあその番号はどのように出されるかというと、ネットワークやストレージを介したデータはバイト列で通信・保存されているので、そのバイト列からデコード処理を行なって番号を割り出している じゃあそのバイト列は？という部分は、UTF-8なりで符号化（エンコードしてバイト列に変換）を行われているものになる HTTPでやりとりするときやHTMLでは、Content-Typeでcharsetを指定することで、中身はこのルール(符号化方式)でエンコードしているよということを伝えている それを見て、コンピュータ側でデコード処理をしている（デコード結果の番号からUnicodeの表を見て、人間がわかる文字を表示している） ファイル周りではBOM(Byte Order Mark)をつけることで、このファイルは何のエンコードだよという WindowsのExcelでファイルを開く場合、これがないとShift_JISと誤認されて、文字化けが発生する可能性がある 符号化文字集合 現在コンピュータで扱える文字数は約15万 基本的にはASCIIと同じで、一つ一つの文字に数字を割り当てて識別している 「符号化文字集合」というのは、扱える文字の集合（ASCIIなら英数）の中で、識別用の数値を割り振ったもの つまり、そのままだが「文字集合を符号化したもの」 「符合位置（コードポイント）」と言うのが、その個々の文字を示す数値のこと 符号化文字集合は「文字コード」呼ばれることが多いが、文字コード自体が文脈によって様々な意味を持つので、正確に表現すると「符号化文字集合」となる 20世紀後半までは、各国や地域が独自にしており、Unicodeが普及するまでは統一されていなかった フォント 符号化文字集合は、単なる対応表なので、実際に表示・印刷するには「フォント」が必要となる 同じ文字コードでもフォントが異なれば見た目も異なる Unicode WWWやソフトウェアの普及により、世界で共通で使える文字コードが良いねとなり、それが今でも使われている「Unicode」である 当初Unicodeは2バイトで世界の全ての文字を表現しようとしたが、それでは足りないことが発覚し、拡張された 毎年更新されている U+7DB2のようなU+で始まり16進数の形でコードポイントを表記する 文字符号化方式(エンコーディング) Unicodeの登場により、単一の体系で文字が表現できるようになった ただUnicodeのコードポイントをそのまま列挙するとメモリ効率が悪いという問題がある Unicodeの範囲はU+0000~U+10FFFFで、21ビットある 「A」はUnicodeでもASCIIと同じU+00041であり、利用頻度の高い文字が比較的前半に配置されている なので列挙すると、U+00041``U+00042のようにゼロが多くなってしまうことが多い そこでUnicodeでは、テキストデータの保存や交換用に、コードポイントを少し変形した形で表現する その代表的なのが「UTF-8」である（Unicode Transformation Format） UTF-8は、ASCIIと同じU+0000~U+007Fの範囲は1バイトで表し、それ以外の範囲はものによっては、2〜4バイトで表現する このようにすることでASCIIとの互換性を持たせるためで、ASCII文字だけで構成されるテキストデータはUTF-8でも同じデータになるため、使い勝手が良くなる 文字符号化方式はなぜ生まれたか 背景として、コンピュータが扱うべき文字が増加したというのがある ASCII時代は、扱う文字が少なかったため、符号化文字集合と符号化文字方式を区別する必要がなく、単に文字コードと言われていた しかしWWWの普及により、さまざまな体系の文字コードを扱う必要が生じ、符号化文字集合と符号化文字方式を分けて考えるようになった UTF-8が登場する前は、Shift_JISやEUC-JPというような文字符号化方式があり、対象とする文字符号化集合はいずれもJIS X 0208であった 筆者の考えとして「文字コード」という言葉が両者それぞれを指すことがあるのは上記のような流れからだと考えているそう（どちらを指しているかは会話の文脈で変わる） 改行コード 文字コードには、目に見える文字だけではなく、画面表示を制御する「制御文字」もある 改行コードもその1種で、歴史的背景から「CR+LF」(Windows)と「LF」(MacやLinux)の2パターンがある やり取りする双方で改行コードを取り決めておく必要がある まとめ コンピュータの世界では、あらゆる文字とそれの対比となるコードポイントを符号化文字集合（Unicode）という形で、あらゆる文字を取り扱えるようにしている そのコードポイントをどう画面に表示するというのは、フォントデータとして保持している Unicodeは、コンピュータが保存・通信を行う時のメモリ効率が良くないという課題がある その課題を解消するのが、文字符号化方式（エンコーディング）であり、代表としてUTF-8がある つまりコンピュータがテキストファイルを保存したり、テキストデータを通信する時は、UTF-8エンコーディングした状態のものが扱っている（メモリ効率のため） つまり逆にそれを開いたり、受け取るときは同じ方式でデコードする必要がある これが異なると文字化けする 防ぐために、HTTPヘッダを使用して相手に伝えたりしている ",
  "wordCount" : "428",
  "inLanguage": "en",
  "datePublished": "2025-05-19T23:08:39+09:00",
  "dateModified": "2025-05-19T23:08:39+09:00",
  "author":{
    "@type": "Person",
    "name": "nyuusen"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/my-hugo-blog/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "nyuusen blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/my-hugo-blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/my-hugo-blog/" accesskey="h" title="nyuusen blog (Alt + H)">nyuusen blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      改訂新版プロになるためのWeb技術入門
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="35" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h1>
    <div class="post-meta"><span title='2025-05-19 23:08:39 +0900 JST'>May 19, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;nyuusen

</div>
  </header> 
  <div class="post-content"><h2 id="参考にしたもの">参考にしたもの<a hidden class="anchor" aria-hidden="true" href="#参考にしたもの">#</a></h2>
<p><a href="https://www.youtube.com/live/5WZDiKol8k4?si=snrgHWB_KgGl3jTe">https://www.youtube.com/live/5WZDiKol8k4?si=snrgHWB_KgGl3jTe</a></p>
<h2 id="3章-wwwの基本要素とその発展">3章 WWWの基本要素とその発展<a hidden class="anchor" aria-hidden="true" href="#3章-wwwの基本要素とその発展">#</a></h2>
<ul>
<li>データ交換にHTMLは適さない(プログラムで取り扱うのが困難)</li>
<li>そんな背景があり登場したのがXML</li>
<li>どういうデータ構造なのかの決まりをスキーマという</li>
<li>XMLではDOCTYPE宣言でdtdファイルでスキーマを指定できる</li>
<li>スキーマレスのJSONやYAMLが流行ったが、結局JSONスキーマが流行ったり、流行は繰り返される</li>
<li>XMLは人が扱うには複雑ではあるが、今でもExcelやe-taxなどコンピュータが読み取るデータとしては
多く利用される</li>
<li>そこからXHTMLも開発されたが、制約が多かったりあまり歓迎されなかった(流行らなかった)</li>
</ul>
<h2 id="4章-httpクライアントとhttpサーバー">4章 HTTPクライアントとHTTPサーバー<a hidden class="anchor" aria-hidden="true" href="#4章-httpクライアントとhttpサーバー">#</a></h2>
<ul>
<li>CGI: リクエストパスに応じてプログラムを起動する、今ではあまり見かけないが、このあとの発展に重要</li>
<li>動的にHTMLを返す、テンプレートエンジンの登場</li>
<li>上記を礎に、ブラウザなのでインストール不要であり、自由度の高いUIを実現できるWebアプリケーションが発展していくことになる</li>
</ul>
<h2 id="5章-urlとhttp">5章 URLとHTTP<a hidden class="anchor" aria-hidden="true" href="#5章-urlとhttp">#</a></h2>
<ul>
<li>URLからwww.が消えたのは、クラウドの台頭とサブドメインを気軽にはやせることができるようになり、昔のようにホストとWebサーバの結びつきが弱くなったため</li>
<li>開発時にウェルナウンポートを使用すると起動のたびにsudo権限が必要なため、8080のようなポートを使うことが多い</li>
<li>ブラウザはURLパスに含まれる拡張子ではなく、MIMEタイプ(Content-Type)を見てどのように扱うかを決めている</li>
<li>GETリクエストでリソース状態を変更できるような実装すべきじゃない理由は、検索クローラによるアクセスでリソースが意図せず変化してしまうことを避けるということも理由にある</li>
<li>よく見るフォーム再送信の確認ダイアログはPOSTリクエストが二重に行われることによる、不利益を避けるため</li>
</ul>
<h2 id="6章-従来型のwebアプリケーション">6章 従来型のWebアプリケーション<a hidden class="anchor" aria-hidden="true" href="#6章-従来型のwebアプリケーション">#</a></h2>
<ul>
<li>従来型アプリケーションをSPAとの対比という意味で昨今はMPAと呼ぶことが多い（当時からMPAと呼んでいたわけではなかった）</li>
<li>コンピュータの世界で、一連の処理の流れにある背景情報(ユーザ名とか)をコンテキストという</li>
<li>HTTPはステートレスである
<ul>
<li>一連の流れをセッションという</li>
<li>ブラウザでそのセッション（状態）を管理するのがCookieである</li>
</ul>
</li>
<li>Cookie
<ul>
<li>Cookieの送信条件は「同じサイトにアクセスした時にそのサイトのCookieを渡す」
<ul>
<li>同じサイトかは、オリジン（ホスト/スキーム/ポート）で判断する</li>
</ul>
</li>
<li>ただそれ以外にも、サーバーからSet-Cookieヘッダでレスポンスするときに以下のような属性(細かな送信条件)を設定することが可能
<ul>
<li>Expires/Max-Age
<ul>
<li>有効期限を表す</li>
<li>どちらも設定されている場合はMax-Ageが優先される</li>
<li>どちらも設定されていない場合はセッションクッキーと呼ばれ、ブラウザが終了するまで有効となる
<ul>
<li>だが近年のいくつかのブラウザは起動時にタブを復元する機能があり、その際にクッキーも復元される</li>
</ul>
</li>
<li>Domain
<ul>
<li>どのサーバに対してアクセスした時にクッキーを送信すべきかを設定する
<ul>
<li>つまり、サーバからクライアントへの送信条件の制御</li>
</ul>
</li>
<li>example.comと指定した場合は、sub.example.comのようなサブドメインも含まれる
<ul>
<li>未指定の場合は、上記のようなサブドメインはCookieは送信されない</li>
</ul>
</li>
<li>例えば親ドメインで発行したクッキーを、サブドメインにあるサーバに送ってほしい時とかに使用する</li>
</ul>
</li>
<li>HttpOnly
<ul>
<li>JSからのアクセスを禁止する</li>
</ul>
</li>
<li>外部への漏洩を防ぐために推奨される設定
<ul>
<li>Domain: 未指定（発行したドメインだけに送信されるようにする）</li>
<li>Secure: HTTPS通信時のみ</li>
<li>HttpOnly: JSからアクセス禁止させる</li>
<li>SameSite: Lax or Strict</li>
</ul>
</li>
<li>DomainとSameSiteの違い
<ul>
<li>Domainは送信先の制限、SameSiteは送信元の制限</li>
<li>Domain指定なし:
<ul>
<li>同一ドメインしかCookieを送信しない</li>
</ul>
</li>
<li>Domainにexample.comを設定:
<ul>
<li>sub.example.comにもCookieを送信する</li>
</ul>
</li>
<li>SameSite指定なし(Lax):
<ul>
<li>一部のクロスサイトリクエスト（GETメソッドのナビゲーションなど）でもCookieを送信する</li>
</ul>
</li>
<li>SameSiteにStrictを設定:
<ul>
<li>同一サイトのみCookieを送信する</li>
<li>malicious.comというサイトからexample.comへのアクセス時はCookieを送信しないといったイメージ</li>
</ul>
</li>
<li>SameSiteにNoneを設定:
<ul>
<li>いかなるクロスサイトのリクエストでもCookieを送信する</li>
</ul>
</li>
<li>まとめると、
<ul>
<li>Domainは、どこにCookieを送信するかの設定</li>
<li>SameSiteは、どこからCookieを送信するかの設定</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>セッション
<ul>
<li>Cookieを用いてセッションを管理する</li>
<li>セッションの盗用(セッションハイジャック)を防ぐ方法として
<ul>
<li>固定や推測されやすい値を使用しない</li>
</ul>
</li>
</ul>
</li>
<li>サードパーティクッキーと個人情報保護
<ul>
<li>あるサイトAに訪問した時に広告画像をクリックした際に、このユーザー(ブラウザ)はこの広告をクリックしたよというCookieをセットする</li>
<li>別のサイトBにアクセスし、広告画像を表示する際に、広告側にはこのユーザーが過去にクリックした広告情報をCookieから取得し、異なるサイト間でも同じような広告を表示させるという仕組み</li>
</ul>
</li>
<li>セッションとユーザー管理
<ul>
<li>セッションベースでのToDoアプリ例を見ると、セッション単位＝ブラウザ単位となるので、ユーザー情報を異なるブラウザで保持させることができない問題がある</li>
<li>ここで登場するのが「認証」という仕組みになる</li>
</ul>
</li>
</ul>
<h2 id="7章-spaへの進化">7章 SPAへの進化<a hidden class="anchor" aria-hidden="true" href="#7章-spaへの進化">#</a></h2>
<p>(この章の背景を補足)</p>
<ul>
<li>
<p>第2次ブラウザ戦争を経てGoogleがV8というJSエンジンを開発し、JSがとても速く実行できるようになった</p>
</li>
<li>
<p>その結果、こんな速いならサーバーサイドでも使えるんじゃね？となり、Nodeが登場</p>
</li>
<li>
<p>従来型の遷移が多く遅い・サーバからの通知ができない問題を解決したのがSPA</p>
</li>
<li>
<p>RIA(Flash)が流行りきらなかった理由としてクローズドな技術だったことが挙げられる。以降は標準化された技術の積み重ねで進化してきている</p>
</li>
<li>
<p>DOM</p>
<ul>
<li>ブラウザはHTMLを読み込むと、内部でDOMというツリー状のデータ構造を構築する</li>
<li>このDOMがJavaScriptからHTMLを操作するための仕様</li>
</ul>
</li>
<li>
<p>イベントドリブンプログラミング</p>
<ul>
<li>一般的なプログラムは逐次処理で上から下に記述された順で処理されるが、GUIのようなユーザー操作が基点となる処理では、逐次処理の書き方が複雑になる</li>
<li>そこで生まれたのがイベントドリブンで、ユーザ操作などのイベントを起点とし、そのイベントが発生したときに実行すべき処理を、そのイベントと紐づけて記述する。これをイベントハンドラやイベントリスナと呼ぶ。</li>
<li>JSでは、addEventListnerで関数登録できる</li>
</ul>
</li>
<li>
<p>JavaScriptは、ブラウザ戦争やブラウザ間の互換性差異に課題があった背景があり、ECMAScriptという標準化団体が標準化を進めた</p>
<ul>
<li>これにより、各ブラウザに内蔵されるJavaScriptエンジンは異なるものの、ECMAScriptに準拠しているため、互換性が保たれている</li>
</ul>
</li>
<li>
<p>同期処理から非同期処理へ</p>
<ul>
<li>同期処理だと、処理中にブラウザでの操作がブロックされ、体験があまりよくない</li>
</ul>
</li>
<li>
<p>XMLHttpRequest</p>
<ul>
<li>XMLとついているが、実際にはXMLと強い結びつきはない</li>
<li>事実JSONでやり取りすることが多い</li>
</ul>
</li>
<li>
<p>XMLとJSON</p>
<ul>
<li>XMLは構造化されたデータをテキストでやり取りできるが、パース処理が比較的重いのが欠点</li>
<li>XMLの代わりとなったのがJSONで、JSの文法をそのまま使ってデータ表現をしている（のでパースが楽）</li>
</ul>
</li>
<li>
<p>ReactやVue.jsの存在</p>
<ul>
<li>DOM APIのみを使って、JSで画面を構築するのは結構大変なので、表題のようなFWを使用する</li>
<li>SPAでは画面表示内容を全てJSで構築する</li>
</ul>
</li>
<li>
<p>フラグメントによる状態変化の表現</p>
<ul>
<li>SPAはURLパスが変わらないので、ブックマークやブラウザの戻る進むができない</li>
<li>フラグメントは、見出しごとにアンカーを定義して、フラグメントでそれを参照するみたいなやつ</li>
<li>URLのフラグメント部はサーバーへ送信されない（リクエストが発生しない）</li>
<li>JSからはlocationオブジェクトで参照可能</li>
<li>SPAではフラグメントを活用することで、状態ごとにURLパスを変えることができる（というよりは、フラグメントを元に表示状態を復元している）</li>
</ul>
</li>
<li>
<p>SPAの課題</p>
<ul>
<li>検索エンジンとの相性の悪さ
<ul>
<li>SPAはHTMLがほとんど空っぽなので（JSで構築するので）クローラが(JS実行前の何もない状態の)HTMLを解析しても適切にインデックスが構築できない</li>
<li>また、URLのフラグメント部はインデックス対象にならないので、フラグメント部に固有の商品ID的なものを埋め込んでも、商品固有のインデックスを構築できない</li>
<li>ただ、現在はJSでレンダリングされたページでもある程度読み取れるように、クローラが改善されている</li>
</ul>
</li>
<li>初期表示の遅さ
<ul>
<li>JSで必要な情報をAPIから収集したり、その上で画面を構築していくので、どうしても初期描画が遅くなる</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SPAの課題に対するアプローチ</p>
<ul>
<li>HistoryAPIによる画面遷移
<ul>
<li>HTML5で登場したブラウザのAPI</li>
<li>アドレスバーに表示させるURLや履歴をJSから操作できる</li>
<li>SPAの非同期通信を活用した高速な画面切り替えという強みを残しつつ、URL変更に伴う擬似的な画面遷移を実現できるようになった</li>
<li>実装的には、aタグリンククリック時のイベントリスナのコールバック関数の中で、<code>e.preventDefault();</code>を実行し、ブラウザが本来行うページ遷移機能を奪い、JSでHistoryAPIを実行する</li>
<li>もし仮にURLパスが含まれた状態でリロードされてもきちんとページが返るように、サーバ側ではindex.htmlを返すように実装する必要がある</li>
<li>HistoryAPIとフラグメント方式は一長一短
<ul>
<li>アプリケーション内の画面を検索エンジンにインデックスさせる必要がないなら、フラグメント方式でも良い（実際Gmailはフラグメント方式）</li>
<li>フラグメント方式は、サーバ側での実装考慮が不要であり、実現方法が簡単</li>
<li>HistoryAPI方式は、サーバ側での考慮必要で実装が複雑だが、検索エンジンとの相性が良い</li>
</ul>
</li>
</ul>
</li>
<li>サーバーサイドレンダリングへの回帰
<ul>
<li>HistoryAPIにより、SPAでもフラグメントに頼らず、画面とURLを一致させられるようになったものの、JSが実行されるまではページ内容がわからない＝検索エンジンがインデックスできないという問題がある</li>
<li>それに加えて、初期表示の遅さという2つの課題を解決するものとしてサーバーサイドレンダリング</li>
<li>これは初期表示に限って、HTMLをサーバー側で生成して返すというもの</li>
<li>ちなみに初期表示の遅さは色々な要因があり、JSのコードを1つにまとめて、変数名や関数名を短くするミニファイ等がある</li>
</ul>
</li>
</ul>
</li>
<li>
<p>AltJS</p>
<ul>
<li>JSはES2015まで停滞していた、サーバーサイドとは異なりブラウザで唯一動く言語の停滞はクライアントサイドの開発においては大きな影響がある</li>
<li>そんな中、JSにトランスパイル言語を開発することで、それらをAltJSと呼ぶ</li>
<li>生き残ったのがTypeScriptとなる</li>
</ul>
</li>
</ul>
<h2 id="8章-webapi">8章 WebAPI<a hidden class="anchor" aria-hidden="true" href="#8章-webapi">#</a></h2>
<ul>
<li>SPAの普及により、URLがコンテンツを返すではなく、アプリケーション・プログラムの関数呼び出しの位置付けに変化</li>
<li>インターネットを経由したAPIの呼び出し、すなわちWebAPIが普及していった</li>
<li>COBRAとSOAPを経て、WebAPIの普及へ</li>
<li>WebAPIは設計の自由度が高いので、1つの指針を示したのがRESTになる</li>
<li>RESTをWebAPIに当てはめて具体化する（リソース指向アーキテクチャ）
<ul>
<li>さまざまな情報の集まりをリソースと表現する</li>
<li>RESTに基づいたAPIは、リソースに対する操作を提供するという考え方で、次の4つの特性を持つ
<ul>
<li>リソースの示し方：リソースを表すURLがあり、URLによってリソースにアクセスできる
<ul>
<li>/addとかではなく、/todoというリソースを指す場所</li>
</ul>
</li>
<li>リソースのたどり方：あるリソースから別のリソースを辿ることができる</li>
<li>リソースの操作方法：リソースに対して何をしたいかはHTTPメソッドで表現する</li>
<li>リソース操作の手順：リソース操作に手順は不要で、一度のやり取りで求められる結果が得られる
<ul>
<li>ステートレスは、サーバーに状態を持たせてしまうとシステム規模に応じてサーバー台数を増やしにくくなってしまうため</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>POSTとHTTPステータスの使い分け
<ul>
<li>POSTメソッドには、以下の2つの役割がある
<ul>
<li>子リソースの新規追加（TODOリストへの追加等、フォルダの中に新規ファイルを1つ作成するイメージ）</li>
<li>既存リソースへの追加（既にあるファイルに追記するイメージ）</li>
</ul>
</li>
<li>子リソースへの追加の場合は、201 CreatedでLocationヘッダに作成したリソースのURLを返すべきとされている</li>
<li>一方、既存リソースへの追加の場合は、対象が既に存在しているため、200 OKを返すだけで良いとされている</li>
</ul>
</li>
<li>オーバーロードPOST
<ul>
<li>本来使用したいメソッドが使えない場合、POSTリクエストのヘッダに<code>X-HTTP-Method-Override</code>として本来使用したいメソッド(DELETE等)を設定する手法もある</li>
<li>なお、<code>X-</code>で始まるヘッダは非標準のカスタムヘッダを意味する</li>
</ul>
</li>
<li>再注目されるRPCスタイル
<ul>
<li>RESTに則ったAPIでは「オーバー/アンダーフェッチング」「N＋1問題」がある（つまり欲しい情報を手に入れるのに足りなかった理、逆に多すぎるというケースがあると理解）</li>
<li>そこで注目されたのが「GraphQL」である
<ul>
<li>QueryLanguageなので、SQLと立て付けは同じで、SQLはデータを対象とし、GraphQLはオブジェクトを対象とする</li>
<li>問い合わせ対象となるデータ構造を「スキーマ」として問い合わせパターンを定義する</li>
<li>問い合わせパターンを「クエリ」と表現し、パラメータ部分（どのデータが欲しいか等）はクライアント側で自由に決められる</li>
<li>/graphqlという1つのエンドポイントに、クエリ文字列をPOSTメソッドを送信する
<ul>
<li>Mutationというデータ更新の場合も同じ（クエリをURLに含めることができず、ボディにセットする必要があるためこの仕組みになっている）</li>
</ul>
</li>
<li>欲しいデータを指定できるので、「オーバー/アンダーフェッチング」「N＋1問題」も解決</li>
</ul>
</li>
<li>GraphQLは、SOAPのようなRPCに近い仕組みになっている
<ul>
<li>SOAPは、RESTによって駆逐されてしまったが、結局APIだけでは全てのニーズを満たすことができなかった</li>
<li>どっちがダメではなく相互補完である</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="9章-サーバプッシュ技術">9章 サーバプッシュ技術<a hidden class="anchor" aria-hidden="true" href="#9章-サーバプッシュ技術">#</a></h2>
<h3 id="サーバプッシュ技術の歴史">サーバプッシュ技術の歴史<a hidden class="anchor" aria-hidden="true" href="#サーバプッシュ技術の歴史">#</a></h3>
<ul>
<li>当初のWWWで新たな情報を取得するためには同じURLにアクセスしてコンテンツを取得する必要があった
<ul>
<li>これをPull型通信と呼ぶ</li>
</ul>
</li>
<li>これに対して、サーバからクライアントに情報を送信することをサーバプッシュと呼ぶ</li>
</ul>
<h3 id="メタリフレッシュによる擬似サーバプッシュ">メタリフレッシュによる擬似サーバプッシュ<a hidden class="anchor" aria-hidden="true" href="#メタリフレッシュによる擬似サーバプッシュ">#</a></h3>
<ul>
<li>初期のWWWで使用されていたのがmeta refreshというHTMLの機能</li>
<li>meta要素に従って、URLを再ロードさせる</li>
<li>簡単ではあるが、即時性が求められるシーンでは現実的な手段ではないし、ページリロードが走るのでUX的にも良くなかった</li>
</ul>
<h3 id="通信量の削減">通信量の削減<a hidden class="anchor" aria-hidden="true" href="#通信量の削減">#</a></h3>
<ul>
<li>ブラウザキャッシュという仕組み</li>
<li>サーバ側がコンテンツ提供時にキャッシュ有効期間をきめ、その期間内はブラウザ側で保持し、それを表示に使用することで通信量を削減する</li>
</ul>
<h3 id="ajaxによるポーリング">Ajaxによるポーリング<a hidden class="anchor" aria-hidden="true" href="#ajaxによるポーリング">#</a></h3>
<ul>
<li>setInterval関数で定期ポーリング</li>
<li>定期的にFetchを行い、変更が必要な情報だけをJSONで取得することで、ページ全体のHTMLを返すよりも通信量を削減できる</li>
</ul>
<h3 id="cometロングポーリング">Comet(ロングポーリング)<a hidden class="anchor" aria-hidden="true" href="#cometロングポーリング">#</a></h3>
<ul>
<li>これは、クライアントがリクエストを送り、サーバはしばらく待ってからレスポンスを返すことでプッシュ風に見せる手法（今や古典的）</li>
<li>キャッシュやAjaxでは即時性を向上させるのが難しい</li>
<li>HTTPレスポンスの返し方を工夫することで、HTTPの枠組みの中で即時性を向上させる技術「Comet」が登場した</li>
<li>Cometとは？
<ul>
<li>意図的にレスポンスを保留し、通知すべき情報が変化が発生して初めてレスポンスを返す</li>
<li>サーバは待ち時間が発生するがAjaxによる非同期通信であればユーザーに影響はない</li>
<li>クライアント側はレスポンスを受け取ったらすぐにリクエストを送り（以下ループ）</li>
</ul>
</li>
<li>Cometの問題点
<ul>
<li>一度サーバから情報を送信すると再接続が必要なので、高頻度で更新されるような場合はネットワークやサーバに負荷がかかる</li>
<li>また、一定時間経過すると、ブラウザや途中経過のプロキシサーバによって、通信が切断される</li>
<li>即時性の面でも、レスポンスを返し、再度接続されるまでの間は、すぐに通知ができない</li>
</ul>
</li>
<li>という問題点を抱えたが、既存の技術を使ってプッシュ技術が実現できるので、長く使われた</li>
</ul>
<h3 id="server-sent-eventsによるプッシュ配信">Server-sent eventsによるプッシュ配信<a hidden class="anchor" aria-hidden="true" href="#server-sent-eventsによるプッシュ配信">#</a></h3>
<ul>
<li>Cometは既存の技術を使用し、無理矢理実現している感があった</li>
<li>そんな状況で、HTML5で関連のAPIの1つとして制定されたのがServer-sent events</li>
<li>Cometによるロングポーリングを1歩進めたHTTPストリーミング</li>
<li>ロングポーリングでは1度レスポンスを返すと再接続が必要という課題があったが、HTTPストリーミングではレスポンスを少しずつ返すことで、一度のリクエストに対してサーバからの通知を連続して行うことができる</li>
<li>これはHTTP1.1で追加されたチャンク転送という機能に基づいている</li>
</ul>
<h3 id="チャンク転送">チャンク転送<a hidden class="anchor" aria-hidden="true" href="#チャンク転送">#</a></h3>
<ul>
<li>chunkとは塊のこと</li>
<li>リクエストやレスポンスをいくつかの塊に分割して送信する機能</li>
<li>チャンク転送でレスポンスを返すには、<code>Transfer-Encoding: chunked</code>というヘッダを返し、以下のような形式でデータの塊を少しづつ返す
<pre tabindex="0"><code>  &lt;chunk size(16進数)&gt;
  &lt;data&gt;
  &lt;blank line&gt;
</code></pre></li>
<li>データを全て送信したら、最後に0を送信して、転送終了の合図とする</li>
<li>クライアントはすべてのデータを持つことなく、チャンク単位で受け取って処理ができるので、総量が分からないデータを送信するのに役立つ</li>
</ul>
<h3 id="server-sent-eventssse">Server-sent events(SSE)<a hidden class="anchor" aria-hidden="true" href="#server-sent-eventssse">#</a></h3>
<ul>
<li>SSEとは、サーバーからクライアントへの一方向リアルタイム通信を実現する技術で、クライアントはJavaScriptのEventSourceというAPIを使い、サーバーからのイベントストリームを受け取る
<ul>
<li>普通のHTTPリクエストを送った後、サーバーが<code>Content-Type: text/event-stream</code>でストリームを送り続ける</li>
<li>あくまでMIMEタイプtextで、UTF-8エンコードされたテキストを配信するので、バイナリには向いてない（Base64エンコードしてテキストに変換して送ることは可能ではあるが、サイズ膨らむし非効率なので..）</li>
</ul>
</li>
<li>SSEの考え方はチャンク転送と同じだが、レスポンスの返し方が少し異なる</li>
<li><code>Content-Type: text/event-stream</code>というヘッダが、SSEによる応答を表す
<ul>
<li>ついでにConnection: keep-aliveも必要で、これはリクエストを受信したサーバがレスポンスを返した後も通信を持続させることをお願いするもの</li>
</ul>
</li>
<li>SSEでは、サーバから通知する情報をチャンクとして返すが、個々をイベントと呼ぶ</li>
<li>イベントの連なりによって構成される応答全体を「イベント・ストリーム」と呼ぶ</li>
<li>チャンク転送とは異なり、サーバーかクライアントのどちらかが通信を止めない限り、通信が続く
<ul>
<li>チャンク転送のような最後に0を送信して終わり合図みたいなものはないので、必要であれば終了を表す合図を決めても良い</li>
</ul>
</li>
<li>SSEの受信処理
<ul>
<li>チャンク転送と異なり、受信側であるブラウザは標準APIで受信を簡単に処理できる（EventSourceオブジェクト）</li>
</ul>
</li>
<li>SSEのメリット
<ul>
<li>標準APIで扱えるので、Comet等に比べると手軽に利用できる</li>
<li>HTTPで通信するので、FWやプロキシなど通信経路上の機器の設定変更等が不要</li>
</ul>
</li>
<li>注意点
<ul>
<li>多くのブラウザではサーバ側の負荷をかけない目的で、同一ドメインのサーバーに対する同時接続は6つまで</li>
</ul>
</li>
<li>SSEのサーバー側の送信処理
<ul>
<li>レスポンス自体は簡単だが、内部処理は少し難しくなる&hellip;</li>
<li>サーバーがブラウザからリクエストを受信するとサーバーはイベントを送信し続ける必要があるが、その間にもサーバー側はToDoの取得や追加のリクエストを処理することができる</li>
<li>ToDoの追加や更新があった時に、それをサーバー内部でSSEの送信処理に通知する必要がある
<ul>
<li>これを実現するには「並行処理」という手法が必要で、この本で紹介されているサーバー実装はGoで書かれているため、ゴルーチンを起動し、チャネルでゴルーチン同士で情報伝達を行っている</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="websocket">WebSocket<a hidden class="anchor" aria-hidden="true" href="#websocket">#</a></h3>
<ul>
<li>CometもSSEも、クライアントからリクエストを送信する必要があるというHTTP本来の性質は変わっておらず、双方向通信ができないという点やオーバーヘッド（TCP接続処理やヘッダ）が大きいという点に改善の余地があった</li>
<li>そんな中生まれたのが双方向・高頻度・大量の通信を実現するWebSocketという新たなプロトコル
<ul>
<li>Comet、SSEはあくまで既存のHTTPに則っていたのに対し、ほとんど別のプロトコルとして作られた(httpではなくws)</li>
<li>最初はHTTPで通信を始め、プロトコルアップグレードという仕組みでWebSocketに切り替える</li>
<li>HTTPと比較すると、ヘッダ相当の情報のやり取りがなく、送受信に伴いオーバーヘッドがとても少ないのが特徴
<ul>
<li>HTTPは毎回封筒に入れてやり取り、WebSocketは電話を繋げっぱなしでやり取りみたいなイメージ</li>
</ul>
</li>
<li>イメージは以下
<ul>
<li>((SSE), HTTP) &mdash; TCP &mdash; IP</li>
<li>HTTP |→| WebSockets &mdash; TCP &mdash; IP</li>
</ul>
</li>
</ul>
</li>
<li>WebSocketのハンドシェイク
<ul>
<li>通信を始める時のハンドシェイクでプロトコルアップグレードという仕組みを使用する</li>
<li>これは簡単にいうと最初はHTTPで通信を開始し、ここから別の言葉で話しましょうと別のプロトコルに切り替えるもの
<ul>
<li>HTTPリクエストヘッダに<code>Connection: Upgrade</code>, <code>Upgrade: websocket</code>を指定することで、クライアントがWebSocket通信を希望することがわかる</li>
</ul>
</li>
<li>WebSocket上でどのような通信をするかはアプリケーションに委ねられている</li>
<li>WebSocket上での通信の取り決めは「サブプロトコル」といい、クライアントが希望するサブプロトコルを<code>Sec-WebSocket-Protocol</code>ヘッダで通知できるようになっている</li>
<li><code>Sec-WebSocket-Key</code>ヘッダは、クライアントとサーバーが互いにWebSocketに対応していることを確認するためのもので、クライアントからはnonceと呼ばれるランダムに生成した文字列をセットする</li>
</ul>
</li>
<li>サーバーからの応答
<ul>
<li>クライアントからのアップグレード要求に対し、101を返す（その要求を了承したことを示す）</li>
<li>クライアントから受け取った<code>Sec-WebSocket-Key</code>の値(nonce)を、規定通りに変換した値をレスポンスヘッダ<code>Sec-WebSocket-Accept</code>にセットすることで、サーバーがWebSocketに対応していることを確認する
<ul>
<li>規定通りに変換: nonceをSHA-1ハッシュ化→Base64エンコード</li>
<li>秘匿性はないが、WebSocketではないサーバーに対して、WebSocket通信を始めてしまうような事故を防ぐため</li>
</ul>
</li>
<li>アップグレード後は常時接続となり、双方向にいつでもデータを送ることが可能となる（つまりサーバー側からのプッシュ配信も可能）</li>
</ul>
</li>
<li>プロトコルアップグレードの必要性
<ul>
<li>一般的なサーバ側のセキュリティ設定として80番/443番ポートを防ぐことが多く、仮にWebSocketが別のポートを使用してしまうと、経路の途中で遮断されてしまう可能性があるため</li>
</ul>
</li>
<li>WebSocketの課題
<ul>
<li>SSEと同じようにTCPコネクションが接続しっぱなしになるので、ブラウザ側の同時接続数の制限を受けることもあるし、サーバー側もより多くのクライアントから接続を受け付ける必要がある</li>
<li>あくまでHTTPのフリをしているため、ハンドシェイク以降の通信はHTTPではないため、プロキシの処理内容によっては遮断されてしまうことがある</li>
<li>プロキシサーバーがある環境では、プロキシサーバーが仲介する通信はHTTP前提で作られていることが多いので、ハンドシェイク以降の通信ができなくなる可能性がある</li>
<li>負荷分散の問題: 1つのサーバーと長時間のTCP接続を行うと、均等に負荷分散されず、特定のサーバーに偏る可能性がある</li>
<li>認証の問題
<ul>
<li>認証の（標準的な）仕組みがない
<ul>
<li>そのため、アプリケーション側で実装してあげる必要がある</li>
<li>具体的には、WebSocketの通信ではHTTPヘッダーを送らないので、最初の通信でJWTを送るとかいう形で、アプリケーション側で独自実装する形となる</li>
</ul>
</li>
<li>同一オリジンポリシーの制約がない
<ul>
<li>このようになっている背景として、WebSocketは、WebアプリだけではなくネイティブアプリやIoT機器からの接続も想定されているため、Webブラウザ限定のSOPルールに縛られない仕様になっているみたい</li>
<li>対策としては、サーバー側でOriginヘッダを検証する必要がある（Originヘッダはブラウザが自動的に付与するのでJSで改変することはできない）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="sseとwebsocketの使い分け">SSEとWebSocketの使い分け<a hidden class="anchor" aria-hidden="true" href="#sseとwebsocketの使い分け">#</a></h3>
<p>※これは個人的に気になったことのメモ</p>
<ul>
<li>SSEが向いているケース
<ul>
<li>ニュース速報配信・株価リアルタイム表示・SNSの新着投稿ありの通知</li>
<li>つまり、サーバーからの一方向の通信でテキスト情報をやり取りしたいシーンで採用される</li>
</ul>
</li>
<li>WebSocketが向いているケース
<ul>
<li>チャット、ゲームなどの画像のストリーミングや音声のリアルタイム配信などが向いている</li>
<li>つまり、双方向・低レイテンシー・バイナリ対応が求められるシーンで採用される</li>
</ul>
</li>
</ul>
<h2 id="付録">付録<a hidden class="anchor" aria-hidden="true" href="#付録">#</a></h2>
<h3 id="2進数と16進数">2進数と16進数<a hidden class="anchor" aria-hidden="true" href="#2進数と16進数">#</a></h3>
<ul>
<li>16進数を表記する場合は先頭に0x（ゼロエックス）をつける</li>
<li>16進数はHEXと表現することもある</li>
<li>16進数は4ビットを1桁で表現できるので、4ビット単位で区切って簡潔に表現できたり、2桁でバイト単位を表現できたりとできたりと2進数との相性が良い</li>
<li>16進数がよく使われるシーン
<ul>
<li>文字コード
<ul>
<li>パーセントエンコーディングやUnicodeのコードポイント表記</li>
</ul>
</li>
<li>カラーコード</li>
<li>IPv6アドレス</li>
<li>MACアドレス</li>
</ul>
</li>
</ul>
<h3 id="テキストとバイナリ">テキストとバイナリ<a hidden class="anchor" aria-hidden="true" href="#テキストとバイナリ">#</a></h3>
<ul>
<li>コンピュータ内部での文字列は数字に割り当てられる
<ul>
<li>例えばAであれば「65」</li>
<li>この対応は、ASCIIと呼ばれ、アメリカの国内規格として制定されたので、この対応表に含まれるのは大小アルファベットと数字といくつかの記号のみ</li>
<li>ASCII文字は95種類しかないので、1バイトの範囲に十分収まる</li>
</ul>
</li>
<li>テキストデータの符号化方式
<ul>
<li>コンピュータで文字を数値として表現することを「符号化方式」という</li>
</ul>
</li>
<li>現在はUTF-8という符号化方式に統一されている</li>
<li>HTTPではテキストデータでやり取りされており、人間が見て理解しやすいというメリットがある一方、通信効率が悪いというデメリットがある</li>
</ul>
<h3 id="文字コード">文字コード<a hidden class="anchor" aria-hidden="true" href="#文字コード">#</a></h3>
<ul>
<li>現代のコンピュータは、世界中の文字を扱えるようになっているため、文字コードの仕組みや体系は複雑になっている</li>
<li>日本国内では、日本語を取り扱う文字コードとして「Shift_JIS」が主流だったが、WWWの普及と世界中のコンピュータが情報を交換するようになり、単一の文字コード体系で世界中の文字を扱えるようになる必要が出てきたが、現在はUnicodeという体系に統一されている</li>
</ul>
<h3 id="utf-8とunicodeについて">UTF-8とUnicodeについて<a hidden class="anchor" aria-hidden="true" href="#utf-8とunicodeについて">#</a></h3>
<ul>
<li>Unicodeは、文字の番号表（この文字はU+XXXXだというやつ）
<ul>
<li>世界中の文字に通し番号を振った辞書</li>
<li>元々は各国独自で文字コードを作っていた（日本はShift_JIS）が、異なる国の文字が混ざったときに文字化けが発生するので、世界共通のUnicodeに統一された</li>
</ul>
</li>
<li>UTF-8は、符号化方式の1つでであり、その番号(U+XXXX)をバイト列に変換するルール
<ul>
<li>UTF＝Unicode Transformation Format Unicodeコードポイントを変換するフォーマット・ルールのこと</li>
<li>バイト列: 複数バイトが連なったもの（01100001 01100010 01100011（= &ldquo;abc&rdquo;））</li>
<li>軽さや処理効率に応じてUTF-16や32があるが、Webでは軽さ重視のためUTF-8が採用されることが多い（多分ネットワーク経由でやり取りするときに少ないバイト列で表現できた方がデータ量が削減できるからという意味だと思う＋UTF-8は、複数バイトの順番をどう並べるかのビッグ/リトルエンディアンを気にしなくて良いという理由もある）</li>
<li>UTF-8では、英数(ASCII文字)は1バイト、日本語は3バイトとなっている
<ul>
<li>文字境界の判別＝どこからどこまでを1文字とするかは、先頭のビットパターンで区別している（1バイト文字なら先頭ビットが<code>0</code>,2バイト文字なら先頭ビットが<code>110</code>&hellip;）</li>
</ul>
</li>
</ul>
</li>
<li>大前提として、
<ul>
<li>ネットワークは光のON/OFF、ストレージはセルがチャージされているかどうか、つまり0か1というビット単位でしか処理ができない（ハードウェアレイヤの都合）</li>
<li>じゃあビットでやり取りすれば良いじゃんという話だが、それでは処理効率が悪い</li>
<li>だからコンピュータ内部（CPUやメモリ等）では8ビットを1バイトを最小単位として処理するように設計されている</li>
<li>1バイト＝8ビットである理由は、2の8乗＝256通りであり、英数字などを扱うのにちょうどよかったため</li>
<li>これに伴い、通信プロトコルとかでも1バイト単位で送信するようになっている</li>
</ul>
</li>
<li>UnicodeとUTF-8の役割
<ul>
<li>まずコンピュータにはUnicodeの文字と番号が紐づいた表があり、番号から文字を割り出して、実際に文字を表示している</li>
<li>じゃあその番号はどのように出されるかというと、ネットワークやストレージを介したデータはバイト列で通信・保存されているので、そのバイト列からデコード処理を行なって番号を割り出している</li>
<li>じゃあそのバイト列は？という部分は、UTF-8なりで符号化（エンコードしてバイト列に変換）を行われているものになる
<ul>
<li>HTTPでやりとりするときやHTMLでは、<code>Content-Type</code>でcharsetを指定することで、中身はこのルール(符号化方式)でエンコードしているよということを伝えている</li>
<li>それを見て、コンピュータ側でデコード処理をしている（デコード結果の番号からUnicodeの表を見て、人間がわかる文字を表示している）</li>
<li>ファイル周りではBOM(Byte Order Mark)をつけることで、このファイルは何のエンコードだよという
<ul>
<li>WindowsのExcelでファイルを開く場合、これがないとShift_JISと誤認されて、文字化けが発生する可能性がある</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="符号化文字集合">符号化文字集合<a hidden class="anchor" aria-hidden="true" href="#符号化文字集合">#</a></h3>
<ul>
<li>現在コンピュータで扱える文字数は約15万</li>
<li>基本的にはASCIIと同じで、一つ一つの文字に数字を割り当てて識別している</li>
<li>「符号化文字集合」というのは、扱える文字の集合（ASCIIなら英数）の中で、識別用の数値を割り振ったもの
<ul>
<li>つまり、そのままだが「文字集合を符号化したもの」</li>
</ul>
</li>
<li>「符合位置（コードポイント）」と言うのが、その個々の文字を示す数値のこと</li>
<li>符号化文字集合は「文字コード」呼ばれることが多いが、文字コード自体が文脈によって様々な意味を持つので、正確に表現すると「符号化文字集合」となる</li>
<li>20世紀後半までは、各国や地域が独自にしており、Unicodeが普及するまでは統一されていなかった</li>
</ul>
<h3 id="フォント">フォント<a hidden class="anchor" aria-hidden="true" href="#フォント">#</a></h3>
<ul>
<li>符号化文字集合は、単なる対応表なので、実際に表示・印刷するには「フォント」が必要となる</li>
<li>同じ文字コードでもフォントが異なれば見た目も異なる</li>
</ul>
<h3 id="unicode">Unicode<a hidden class="anchor" aria-hidden="true" href="#unicode">#</a></h3>
<ul>
<li>WWWやソフトウェアの普及により、世界で共通で使える文字コードが良いねとなり、それが今でも使われている「Unicode」である</li>
<li>当初Unicodeは2バイトで世界の全ての文字を表現しようとしたが、それでは足りないことが発覚し、拡張された</li>
<li>毎年更新されている</li>
<li><code>U+7DB2</code>のようなU+で始まり16進数の形でコードポイントを表記する</li>
</ul>
<h3 id="文字符号化方式エンコーディング">文字符号化方式(エンコーディング)<a hidden class="anchor" aria-hidden="true" href="#文字符号化方式エンコーディング">#</a></h3>
<ul>
<li>Unicodeの登場により、単一の体系で文字が表現できるようになった</li>
<li>ただUnicodeのコードポイントをそのまま列挙するとメモリ効率が悪いという問題がある</li>
<li>Unicodeの範囲は<code>U+0000</code>~<code>U+10FFFF</code>で、21ビットある
<ul>
<li>「A」はUnicodeでもASCIIと同じ<code>U+00041</code>であり、利用頻度の高い文字が比較的前半に配置されている</li>
<li>なので列挙すると、<code>U+00041``U+00042</code>のようにゼロが多くなってしまうことが多い</li>
</ul>
</li>
<li>そこでUnicodeでは、テキストデータの保存や交換用に、コードポイントを少し変形した形で表現する</li>
<li>その代表的なのが「UTF-8」である（Unicode Transformation Format）
<ul>
<li>UTF-8は、ASCIIと同じU+0000~U+007Fの範囲は1バイトで表し、それ以外の範囲はものによっては、2〜4バイトで表現する
<ul>
<li>このようにすることでASCIIとの互換性を持たせるためで、ASCII文字だけで構成されるテキストデータはUTF-8でも同じデータになるため、使い勝手が良くなる</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="文字符号化方式はなぜ生まれたか">文字符号化方式はなぜ生まれたか<a hidden class="anchor" aria-hidden="true" href="#文字符号化方式はなぜ生まれたか">#</a></h3>
<ul>
<li>背景として、コンピュータが扱うべき文字が増加したというのがある</li>
<li>ASCII時代は、扱う文字が少なかったため、符号化文字集合と符号化文字方式を区別する必要がなく、単に文字コードと言われていた</li>
<li>しかしWWWの普及により、さまざまな体系の文字コードを扱う必要が生じ、符号化文字集合と符号化文字方式を分けて考えるようになった</li>
<li>UTF-8が登場する前は、Shift_JISやEUC-JPというような文字符号化方式があり、対象とする文字符号化集合はいずれもJIS X 0208であった</li>
<li>筆者の考えとして「文字コード」という言葉が両者それぞれを指すことがあるのは上記のような流れからだと考えているそう（どちらを指しているかは会話の文脈で変わる）</li>
</ul>
<h3 id="改行コード">改行コード<a hidden class="anchor" aria-hidden="true" href="#改行コード">#</a></h3>
<ul>
<li>文字コードには、目に見える文字だけではなく、画面表示を制御する「制御文字」もある</li>
<li>改行コードもその1種で、歴史的背景から「CR+LF」(Windows)と「LF」(MacやLinux)の2パターンがある</li>
<li>やり取りする双方で改行コードを取り決めておく必要がある</li>
</ul>
<h3 id="まとめ">まとめ<a hidden class="anchor" aria-hidden="true" href="#まとめ">#</a></h3>
<ul>
<li>コンピュータの世界では、あらゆる文字とそれの対比となるコードポイントを符号化文字集合（Unicode）という形で、あらゆる文字を取り扱えるようにしている</li>
<li>そのコードポイントをどう画面に表示するというのは、フォントデータとして保持している</li>
<li>Unicodeは、コンピュータが保存・通信を行う時のメモリ効率が良くないという課題がある</li>
<li>その課題を解消するのが、文字符号化方式（エンコーディング）であり、代表としてUTF-8がある</li>
<li>つまりコンピュータがテキストファイルを保存したり、テキストデータを通信する時は、UTF-8エンコーディングした状態のものが扱っている（メモリ効率のため）</li>
<li>つまり逆にそれを開いたり、受け取るときは同じ方式でデコードする必要がある
<ul>
<li>これが異なると文字化けする</li>
<li>防ぐために、HTTPヘッダを使用して相手に伝えたりしている</li>
</ul>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 改訂新版プロになるためのWeb技術入門 on x"
            href="https://x.com/intent/tweet/?text=%e6%94%b9%e8%a8%82%e6%96%b0%e7%89%88%e3%83%97%e3%83%ad%e3%81%ab%e3%81%aa%e3%82%8b%e3%81%9f%e3%82%81%e3%81%aeWeb%e6%8a%80%e8%a1%93%e5%85%a5%e9%96%80&amp;url=http%3a%2f%2flocalhost%3a1313%2fmy-hugo-blog%2fposts%2f008_%25E6%2594%25B9%25E8%25A8%2582%25E6%2596%25B0%25E7%2589%2588%25E3%2583%2597%25E3%2583%25AD%25E3%2581%25AB%25E3%2581%25AA%25E3%2582%258B%25E3%2581%259F%25E3%2582%2581%25E3%2581%25AEweb%25E6%258A%2580%25E8%25A1%2593%25E5%2585%25A5%25E9%2596%2580%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 改訂新版プロになるためのWeb技術入門 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fmy-hugo-blog%2fposts%2f008_%25E6%2594%25B9%25E8%25A8%2582%25E6%2596%25B0%25E7%2589%2588%25E3%2583%2597%25E3%2583%25AD%25E3%2581%25AB%25E3%2581%25AA%25E3%2582%258B%25E3%2581%259F%25E3%2582%2581%25E3%2581%25AEweb%25E6%258A%2580%25E8%25A1%2593%25E5%2585%25A5%25E9%2596%2580%2f&amp;title=%e6%94%b9%e8%a8%82%e6%96%b0%e7%89%88%e3%83%97%e3%83%ad%e3%81%ab%e3%81%aa%e3%82%8b%e3%81%9f%e3%82%81%e3%81%aeWeb%e6%8a%80%e8%a1%93%e5%85%a5%e9%96%80&amp;summary=%e6%94%b9%e8%a8%82%e6%96%b0%e7%89%88%e3%83%97%e3%83%ad%e3%81%ab%e3%81%aa%e3%82%8b%e3%81%9f%e3%82%81%e3%81%aeWeb%e6%8a%80%e8%a1%93%e5%85%a5%e9%96%80&amp;source=http%3a%2f%2flocalhost%3a1313%2fmy-hugo-blog%2fposts%2f008_%25E6%2594%25B9%25E8%25A8%2582%25E6%2596%25B0%25E7%2589%2588%25E3%2583%2597%25E3%2583%25AD%25E3%2581%25AB%25E3%2581%25AA%25E3%2582%258B%25E3%2581%259F%25E3%2582%2581%25E3%2581%25AEweb%25E6%258A%2580%25E8%25A1%2593%25E5%2585%25A5%25E9%2596%2580%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 改訂新版プロになるためのWeb技術入門 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fmy-hugo-blog%2fposts%2f008_%25E6%2594%25B9%25E8%25A8%2582%25E6%2596%25B0%25E7%2589%2588%25E3%2583%2597%25E3%2583%25AD%25E3%2581%25AB%25E3%2581%25AA%25E3%2582%258B%25E3%2581%259F%25E3%2582%2581%25E3%2581%25AEweb%25E6%258A%2580%25E8%25A1%2593%25E5%2585%25A5%25E9%2596%2580%2f&title=%e6%94%b9%e8%a8%82%e6%96%b0%e7%89%88%e3%83%97%e3%83%ad%e3%81%ab%e3%81%aa%e3%82%8b%e3%81%9f%e3%82%81%e3%81%aeWeb%e6%8a%80%e8%a1%93%e5%85%a5%e9%96%80">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 改訂新版プロになるためのWeb技術入門 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fmy-hugo-blog%2fposts%2f008_%25E6%2594%25B9%25E8%25A8%2582%25E6%2596%25B0%25E7%2589%2588%25E3%2583%2597%25E3%2583%25AD%25E3%2581%25AB%25E3%2581%25AA%25E3%2582%258B%25E3%2581%259F%25E3%2582%2581%25E3%2581%25AEweb%25E6%258A%2580%25E8%25A1%2593%25E5%2585%25A5%25E9%2596%2580%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 改訂新版プロになるためのWeb技術入門 on whatsapp"
            href="https://api.whatsapp.com/send?text=%e6%94%b9%e8%a8%82%e6%96%b0%e7%89%88%e3%83%97%e3%83%ad%e3%81%ab%e3%81%aa%e3%82%8b%e3%81%9f%e3%82%81%e3%81%aeWeb%e6%8a%80%e8%a1%93%e5%85%a5%e9%96%80%20-%20http%3a%2f%2flocalhost%3a1313%2fmy-hugo-blog%2fposts%2f008_%25E6%2594%25B9%25E8%25A8%2582%25E6%2596%25B0%25E7%2589%2588%25E3%2583%2597%25E3%2583%25AD%25E3%2581%25AB%25E3%2581%25AA%25E3%2582%258B%25E3%2581%259F%25E3%2582%2581%25E3%2581%25AEweb%25E6%258A%2580%25E8%25A1%2593%25E5%2585%25A5%25E9%2596%2580%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 改訂新版プロになるためのWeb技術入門 on telegram"
            href="https://telegram.me/share/url?text=%e6%94%b9%e8%a8%82%e6%96%b0%e7%89%88%e3%83%97%e3%83%ad%e3%81%ab%e3%81%aa%e3%82%8b%e3%81%9f%e3%82%81%e3%81%aeWeb%e6%8a%80%e8%a1%93%e5%85%a5%e9%96%80&amp;url=http%3a%2f%2flocalhost%3a1313%2fmy-hugo-blog%2fposts%2f008_%25E6%2594%25B9%25E8%25A8%2582%25E6%2596%25B0%25E7%2589%2588%25E3%2583%2597%25E3%2583%25AD%25E3%2581%25AB%25E3%2581%25AA%25E3%2582%258B%25E3%2581%259F%25E3%2582%2581%25E3%2581%25AEweb%25E6%258A%2580%25E8%25A1%2593%25E5%2585%25A5%25E9%2596%2580%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 改訂新版プロになるためのWeb技術入門 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%e6%94%b9%e8%a8%82%e6%96%b0%e7%89%88%e3%83%97%e3%83%ad%e3%81%ab%e3%81%aa%e3%82%8b%e3%81%9f%e3%82%81%e3%81%aeWeb%e6%8a%80%e8%a1%93%e5%85%a5%e9%96%80&u=http%3a%2f%2flocalhost%3a1313%2fmy-hugo-blog%2fposts%2f008_%25E6%2594%25B9%25E8%25A8%2582%25E6%2596%25B0%25E7%2589%2588%25E3%2583%2597%25E3%2583%25AD%25E3%2581%25AB%25E3%2581%25AA%25E3%2582%258B%25E3%2581%259F%25E3%2582%2581%25E3%2581%25AEweb%25E6%258A%2580%25E8%25A1%2593%25E5%2585%25A5%25E9%2596%2580%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/my-hugo-blog/">nyuusen blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
