<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>AWS設計スキルアップガイド | nyuusen blog</title>
<meta name="keywords" content="">
<meta name="description" content="AWS設計スキルアップガイド ――サービスの選定から、システム構成、運用・移行の設計まで：書籍案内｜技術評論社
2.クラウドのインフラ設計
クラウドで考えるセキュリティ

万が一の事故や障害が発生したときに「責任分界点」を定義しておくことで、責任の所在を明らかにできる
AWSでの「責任共有モデル」では、それぞれの責任について以下のように定義されている

AWS: サービスを提供するためのインフラストラクチャ
利用者: 選択したAWSサービスごとの適切なセキュリティを実装し、システムを保護する


AWS SecurityHubを使用することで、横断的にセキュリティの問題を検知することができる

3.システムの構成

AWSでシステムを構築する時にまず考えるべきは「アカウントをどの単位で発行するか」

AWSアカウントの運用例

単一のアカウントで運用するケース

注意ポイント

VPCをプロジェクトや環境ごとに分離する
プロジェクトや環境がわかるようにタグを活用する
VPCに関連のないサービスを使用する場合、IAMで権限を設定する


管理する請求先が1つになるメリットはあるが、誤操作等によるミスや事故リスクが上がるので、できればアカウントは分けて運用するのが良い


複数のアカウントで運用するケース

アカウントの統制を考慮する

AWS ControlTowerで一元管理
Organizationで多数のAWSアカウントを管理


ログインIDの統合を検討する(1つのユーザーアカウントで各AWSアカウントにログインできるようにする)

各環境のIAMロールで行う方法
AWS IAM Identity Center (SSO)を活用する方法
サードパーティIDaaSを活用する方法




(追記)

AWS ControlTowerを利用すると、マルチアカウント環境を一元的に整備してくれる
参考: スタートアップにおけるマルチアカウントの考え方と AWS Control Tower のすゝめ | AWS Startup ブログ



IAM

認証はIAMユーザー、認可はIAMポリシーで設定する

通常、ポリシーはグループもしくはロールに付与する
なぜなら、ユーザーにポリシーをアタッチすると、運用工数がかかる



IAMポリシー設計

デフォルトはすべて拒否なので、明示的に許可していく

どのリソース(Resource)に対して、どんな条件で(Conditions)、どんな動作(Action)を、許可/拒否する(Effect)かをJSONもしくはGUIで記述(選択)する


ポリシーはいくつか種類がある(使用頻度が高いものを抜粋)

アイデンティティベースのポリシー

アイデンティティ(ユーザー、グループ、ロール)にアタッチする
この中にも再利用可能な管理ポリシーとインラインポリシーが存在(管理ポリシー推奨)


リソースベースのポリシー

S3などのリソースにアタッチする


セッションポリシー

一時的にセッション単位でアクセスを許可するポリシー
AssumeRoleなどのAPIを利用する




ポリシー評価について

以下の順番で評価される



画像引用元: 【入門編】AWSにおけるアクセスポリシーの評価ロジックを整理してみる




明示的な拒否があれば、その拒否設定が適用される

拒否設定の後に、明示的な許可設定があったとしても、拒否設定が優先的に適用される


明示的な許可があれば許可となるが、なかった場合は暗黙的に拒否される



4.ネットワーク設計
オンプレミスとの比較

オンプレミスと比較すると、AWSにおけるネットワーク設計はある程度ざっくりでOK

名前解決

オンプレミス: 内部DNSを立てるか各サーバーのhostsファイルを利用して名前解決を行う
AWS: 自動でパブリックのDNS名が割り当てられ、マネージドのDNSで名前解決を行う


時刻同期

オンプレミス: システム内の時刻が同期するように同一のNTPサーバーを割り当てる
AWS: AmazonTimeSyncServiceで同期する(インターネット接続不要)

マネージドNTP
VPCで実行されているすべてのインスタンスの 169.254.169.123 IPアドレスで NTP を介して利用できる
最新バージョンのAmazonLinux2とAmazonLinuxAMIはデフォルトでAmazonTimeSyncServiceと同期してくれている

LambdaやECS on Fargate等のマネージドサービスではAWS側で時刻同期されているはずとのこと
AWSマネージドサービスの時刻同期はAWS側で行われているのか | AWS re:Post









VPCとサブネット

VPCはリージョンごとのサービスなので、リージョンを跨ぐことはできない
サブネットではいくつかのIPアドレスがAWSの予約枠として確保されている

ネットワークアドレス (最初のIPアドレス)

例: 10.0.0.0/24サブネットの場合、10.0.0.0がこのアドレスです。
役割: ネットワーク自体を表すためのアドレスであり、ルーティングやネットワーク構成で使用されます。


VPCルーター (2番目のIPアドレス)

例: 10.0.0.1がこのアドレスとなります（サブネットによって異なる場合もあり）。
役割: サブネット内での通信を管理する仮想ルーターです。インスタンス間の通信やインターネットゲートウェイ、VPN接続の経路制御など、サブネット内のルーティングに使用されます。


DNSサーバー (3番目のIPアドレス)

例: 10.0.0.2です。
役割: AWSが提供するDNSリゾルバーのIPアドレスです。VPC内のインスタンスがDNSクエリを行う際に使用します。独自のカスタムDNS設定を行わない限り、このアドレスがデフォルトでDNSリゾルバーとして機能します。


将来の用途のために予約されたアドレス (4番目のIPアドレス)

役割: 現時点で特定の用途が明確には指定されていませんが、AWSが今後の機能拡張や内部用途のために予約しています。


ブロードキャストアドレス (最後のIPアドレス)

例: 10.0.0.255/24サブネットの場合、10.0.0.255がこのアドレスです。
役割: ブロードキャスト通信のために予約されていますが、AWSのVPCではブロードキャスト通信はサポートされていないため、実際に使用することはありません。





セキュリティグループ・ネットワークACL・AWS Network Firewall

AWS Network Firewallは有料なのであまり使われない
セキュリティグループ(SG)→ネットワークACLと、フィルタの範囲を狭めて、シンプルな構成・運用にする
SGは、同一SGに所属しているノード同士の通信でも明示的に許可する必要がある

ルートテーブル

ルートテーブルは複数のサブネットで共有可能
サブネット作成時にルートテーブルも作成され、追加の設定なくVPC内の通信は可能

デフォルトで、VPC内の全てのサブネットに向けたローカルルートが設定されているため
ということは、同じVPC内のサブネットに存在するリソース間で通信を拒否したい場合は、セキュリティグループで設定する必要がある



VPCエンドポイント

異なるVPCやリージョンに配置されたAWSサービスへインターネットを経由せずに接続するサービス
ゲートウェイエンドポイント

ルートテーブルでAWSサービスへのルートを指定
費用かからない


インターフェイスエンドポイント

VPCのプライベートIPアドレスを使用してアクセスする
ENIとしてVPC内に配置され、それがサービスに接続するためのエンドポイントとして動作する
処理するデータ量に応じて課金される


例えばS3は、どちらでも接続可能だが、インターフェイスエンドポイントの方がセキュリティグループでトラフィックを制御できるため、セキュアである

VPC内のリソースがエンドポイントに対して、どのように通信できるかを詳細に制御ができるため、という意味(IPやプロトコル等の制限が可能)



VPCフローログ

VPC内のネットワークインターフェースに流れる情報をキャプチャし、ログに記録する
監査に必要なログを出力したり、通信がうまく通らない場合はトラブルシューティングとして出力したり
フローログは以下の3つの項目を指定する

フローログを取得するリソース(VPC/サブネット/ENIをもつELBやNATGateway等)
どんなトラフィックをキャプチャするか(許可、拒否、全て)
フローログの出力先(CloudWatch Logs/S3)



AWSにセキュアに接続する

AWS Client VPN
サイト間VPN
Direct Connect

5.コンピューティング
Lambda

イベント駆動型のアプリケーションで使いやすい
コールドスタートにかかる時間を短くする方法

VPC内にアクセスしない(ENI作成に10〜30秒かかるため)

VPC Lambdaと呼ばれてるやつ
Lambdaをパブリックサブネットに配置するとENIが作成されアタッチされる
そのENIに対し、パブリックIPを付与(アドレス関連付け)してやれば、Lambdaからアウトバウンドの通信ができるらしい


メモリ増やす(メモリ量に比例してCPUも増加する)
コード量を短くする

関数の初期化や依存解決の速度の向上が見込まれるため





Lambdaのセキュリティ

IAMを最小限にする

特定の条件下で特定のリソースに対して実行できるアクションのみ定義する
基本的には複数のLambda関数でIAMロールで共有しない



Lambdaの監視

Lambda関数をデプロイすると自動でCloudWatch Logsと連携する＋レイテンシやエラー率などのメトリクスも自動で発行する

エラーを検知できるようにアラートを設定しておくと良い
特にDuration(所要時間)やThrottles(同時実行上限を超えて制限した数)は、エラーが発生する前に適切検知できるようにしておく



EC2

インスタンスタイプの書式

Amazon EC2 インスタンスタイプの命名規則 - Amazon EC2
オプション

コンピューティング最適化: CPU大きめ
メモリ最適化: メモリ大きめ





AMI

インスタンス起動するのに必要なOSやボリューム・アプリケーションを含むテンプレート
OSのライセンス費用はEC2の利用料金に含まれている(オンプレと異なる点であり、メリットである)

インスタンスの費用削減

リザーブドインスタンス

時間単位の費用を削減できる
1年や3年の長期使用を約束する
インスタンスクラスの変更しない場合、または負荷増加の際にオンデマンドインスタンスやスポットインスタンスで対応できる場合に検討する
実際の使用有無に関わらず、購入した条件に応じた期間の費用が発生する


SavingsPlans

これも1年や3年の長期使用を約束する
リザーブドインスタンスとの違いは、LambdaやFargateでも使用可能である点、インスタンスファミリーやプラットフォームなどを指定しなくて良い

逆にRDSやElasiCacheでは使用できないので注意


3種類がある
インスタンスタイプや構成を柔軟に変更する予定がある場合は、SavingsPlansを検討する


スポットインスタンス

AWSクラウド内の使用されていないEC2キャパシティを活用し、中断される可能性がある
なので、本番環境で常時起動するサーバーではなく、ECS実行環境やCICDのビルド環境、バッチに適用する
本番環境で適用する場合は、AutoScalingグループでオンデマンドインスタンスとスポットインスタンスの割合を指定する等して、中断が影響しないようにする

中断の2分前にAWSから警告が来るので、アプリケーションの安全な停止や、ログの退避などは自動で対応できるように実装する
インスタンスメタデータで中断対象か確認できる

インスタンスメタデータを取得できるAPIがあるっぽい
そこを定期的に叩くことで確認







T系インスタンスの注意点

汎用のT系はM系よりも安価でありよく選定されるが、バーストパフォーマンスインスタンスであることは十分に理解が必要
バーストパフォーマンスインスタンスとは

ベースラインと呼ばれるCPU使用率がある
そのベースラインに対して、下回る間はクレジットを獲得し、超える間は消費する

1CPUクレジット=1vCPU×100%使用率×1分
つまり、1vCPUを50%使用率で2分使用すると、1クレジット消費するということ


24時間の間で、獲得したクレジットよりも消費するクレジットが多い場合に、その分のvCPU費用が発生する
T系インスタンスの各タイプで、1時間あたりに受け取るクレジットや蓄積可能なクレジット、ベースライン使用率は決められている


CPUクレジットの消費タイプには以下の2種類がある

Standard: 残高が0になると、ベースライン使用率以下でのみ使用可能となる
Unlimited: Standardのような制約はない代わりに、CPUクレジットが0になった後は、vCPU時間ごとに均一追加料金が発生する（他のインスタンスタイプの利用料金を超える可能性がある）


重要なのは、CPU使用率を監視すること

CloudWatchメトリクスで参照可能
バーストインスタンスの CPU クレジットをモニタリングする - Amazon Elastic Compute Cloud


参考: バーストパフォーマンス(T系)インスタンスの特徴を理解して上手に利用しよう | AWS Startup ブログ

コンテナ

仮想化とコンテナの違い

ゲストOSの有無が大きな違い
仮想化はホストOSを介して、ハードウェアを制御するため、オーバーヘッドが大きい
コンテナは、アプリケーションの動作環境を隔離していて、カーネルはホストOSに依存するため、仮想化のように複数の異なるOSを稼働させることはできないが、逆に言えばOSがない分起動が早く、使用するリソースも少なくて済む



コンテナとEC2の違い

EC2上でコンテナを実行するのと、ECSやEKSなどのオーケストレーションツールを使用するのとでどのような違いがあるのかという問いと同義
EC2上で動かした場合、デプロイする時は、EC2アプリケーションを更新→AMIを取得→AutoScaling対象のAMIを変更するという、とても面倒な手作業が発生する

逆にロールバックの作業も面倒..
加えて、OS更新等の手作業も発生する


一方、ECSの場合は、コンテナやOSの障害や更新をAWS側が管理してくれる

CI/CDパイプラインを構築すれば、アプリケーション変更から適用まで迅速に行える
コンテナがプロセス落ちを管理し、再度デプロイしてくれる(Serviceがやっていることかな？)



コンテナを構成するサービスの特徴

複数の環境を有するシステム

再現性が高い特徴を活かせる


更新頻度が高いシステム
アクセス増減の発生が高いシステム
もはやこのご時世的にはあえてEC2を選択するケースはないのではと思う

コンテナサービスを作るときに気をつけること

障害発生することを前提とする

プロセスが落ちても、すぐに起動できるように
ECS Serviceを使えという話だと思う


環境差異は変数化する
ログ出力を1本化する

コンテナは実行環境であるホストOS上でプロセスとして動作し、他のプロセスから隔離されている
コンテナ内部でアプリケーションログを吐いても、プロセス停止した際などにログが残らなくなってしまう
ホストOSか別の領域に出力するように設定する

ちょっと調べた感じ、タスク定義でログドライバにawslogsを設定し、ロググループなども設定すれば、1つのロググループに出力されるようになるっぽい




1コンテナ1プロセスとする

1つのコンテナに複数のプロセスを稼働させることも可能だが、制御が難しいため



Amazon ECS

ECSの構成要素

クラスター：実行環境
タスク定義：指定のコンテナを動かす
サービス：全体の構成やデプロイ方法を設定


タスク定義

主な設定項目

Dockerイメージ
コンテナのCPUとメモリ
データボリューム
IAMロール
コンピューティング環境(EC2 or Fargate)




サービス

主な設定項目

連携するELBを指定
指定したタスク定義のタスク数
デプロイ方法(Blue/Green,ローリングアップデート)
実行環境(EC2,Fargate)で待ち受けるポートや、コンテナ側で待ち受けるポートも指定する


サービスはなくても動くけど、AutoScalingの実装等に必要


クラスター

主な設定項目

コンテナ実行環境のネットワークを指定
起動するインスタンスタイプやAMI、その数を指定


Fargateの場合は、ネットワーク作成とクラスター名のみを設定する



タスク定義の更新

コンテナイメージにつけるタグ名はlatestにするとタスク定義の修正が不要になる一方、コンテナイメージのバージョンがわからないのがで名rっと
デプロイ方法「ローリングアップデート」と「Blue/Greenデプロイメント」がある

ローリングアップデートの例

DesiredCountを4に、minimumHealthyPercentを0.5に設定した場合、4 * 0.5の2インスタンスが更新されたタスク定義を元に作成される


Blue/Greenデプロイメントの例

タスク定義を更新すると、新たにGreen環境が作成あれ、疎通に問題がなければ、LBのレイヤーで切り替えを行う（だからLBが必須）





データボリューム

ログや共通のデータはコンテナ外に領域を確保する
ECSで選択可能なデータボリュームは以下になる

EFS
FSx for Windows File Sever
Dockerボリューム

EC2のみ利用可能


バインドマウント

ホスト上のファイルやディレクトリをコンテナからマウントする


Fargate タスクエフェメラルストレージ

エフェメラルストレージ=一時的なストレージ
プロビジョニング時にECSタスクが受け取るもの
これらをマウントし、タスク定義内でvolumes、mountPointsおよびvolumesFromパラメータを使用しているコンテナ間で共有することが可能


Amazon ECS タスクのストレージオプション - Amazon Elastic Container Service



6.データベース
データベースの選択

どんな用途なのかと移行か新規なのか、複数の観点からの検討が必要

RDS

EC2同様に仮想サーバー上で実行される
EC2でもDBの構築は可能だが、RDSと異なり自動スケーリングや高可用性、OS・DBソフトウェアのパッチ適用などはユーザーが設計・実装・運用する必要がある

逆に、その辺りを自前で管理したい・RDSでサポートされていないパラメータをチューニングしたい・開発環境などで費用削減をしたいという場合はEC2でのDB構築が選択肢になる


リクエストのI/Oサイズやアクセスパターンにより、パフォーマンスが大きく変わる

シーケンシャルなアクセスでは、最大I/Oサイズに達するまで、単一のI/O操作に含められる
ランダムなアクセスでは、最大I/Oサイズに達しない小さいサイズでも、IOPSに個別カウントする

つまりランダムアクセスの場合はIOPSの消費が多いので、それを考慮してインスタンスクラスなどを決めようという話




パフォーマンスは、DBで最も重要な非機能要件になるので、机上確認だけでなく、実際に検証したり、CloudWatchメトリクスで確認したりして、ストレージタイプを選ぶと良い

マルチAZ構成

サポートされている機能は、リージョンやデータベースエンジンによって異なる
マルチAZデプロイすると、Read/WriteできるプライマリDBインスタンスとフェイルオーバー先となるスタンバイレプリカ(読み取り書き込みはできない)が別AZへデプロイされる
スタンバイレプリカは通常時は動作せず、プライマリに障害が発生した時にレプリカが昇格する
フェイルオーバーは60〜120秒

マルチAZ DBクラスタ

1つの読み取り/書き込みインスタンスと、2つ以上の読み取り専用スタンバイDBインスタンスで構成
読み取り/書き込みインスタンスに障害が発生したら、読み取り専用スタンバイDBインスタンスが昇格
書き込み専用DBインスタンス接続するクラスタエンドポイントと、読み取り専用に接続するリーダーエンドポイントがある

エンドポイントは、クラスタ内の対象インスタンスに接続できない場合に自動的に接続先を変更する


フェイルオーバーは35秒未満

RDS Proxy

RDSでは、アプリケーションからの接続を処理する際にメモリやCPUを消費する
頻繁に短時間でDB接続を繰り返すアプリケーションでは、DBの処理負荷を下げるためRDS Proxyを導入すると良い
RDSの最大接続数はパラメータグループのmax_connectionsで定義されており、手動変更は推奨されていない
そのため、同時接続数が上限に達しそうな場合は、上位のインスタンスクラスorRDS Proxyを検討する
RDS Proxyの特徴

フルマネージドサービス
アプリケーションとRDSの間に設置
VPC内の異なるAZにある2サブネットを選択して作成
RDS Proxyを間に配置することによる遅延は5ミリ秒程度
RDSのインスタンスレベルを上げずに済むので、コストや運用工数を抑えられる


RDS Proxyを採用するメリット

フェイルオーバーにかかる時間を短縮できる

数秒レベルでフェイルオーバーが完了する
RDS Proxyがない場合は、スタンバイの昇格とクラスタエンドポイントの更新後にアプリケーションが再接続するのに比べて、RDS Proxyがある場合はアプリケーションからの接続をプールし、RDS ProxyからRDSへの接続は処理中であったものを除いて保持・再利用するため

この箇所ちょっと引っかかったので調べてみた。
RDS Proxyの使用有無で、RDS側のフェイルオーバーにかかる時間は変わらないと思う
ただし、アプリケーションの視点で見た時に、RDS Proxyへのコネクションを再確立する必要がない

RDS ProxyーRDS間のコネクションの再確立のみで不要
なので、アプリケーション側からすると、再接続するオーバーヘッドがかからないので、フェイルオーバーにかかる時間を短縮できると表現されていると思われる(RDS側のDNS更新も待つ必要もない)








RDS Proxyを利用する際の注意点

IPアドレスの枯渇

IPアドレスを消費するのは、RDS Proxy-RDSの接続

RDS Proxy-RDSは、同じVPC内で通信するため、プライベートIPアドレスを使用する
RDS Proxyは、接続先RDSのインスタンスクラスと台数に応じて自動的に容量を増減し、場合によっては多くのIPアドレスを利用する


IPアドレスが枯渇するとうまくスケールができず、クエリ遅延やコネクション失敗が発生することがある
インスタンスクラスごとに確保すべき最小IPアドレス数が定められている
回避する方法としては、サブネットのIPアドレス範囲を広くすることが推奨される


セッション固定（ピン止め）による影響

特定のトランザクションやセッションが接続プール内の特定のバックエンド(DB)接続に固定される状態を指す
この状態になってしまうと、通常共有可能な接続が他のリクエストに再利用されなくなり、DBへの同時接続数が増え続け、最終的にはDB接続が行えなくなる可能性がある
CloudWatchメトリクスの「DatabaseConnectionsCurrentlySessionPinned」を監視すると良い
ピン留め発生が想定されるケース


ステートフルなリクエスト
ユーザーセッションに依存する処理が行われる場合、同じバックエンド接続を使用し続ける必要があります。
例: 一時テーブルやユーザー固有の設定を使用したクエリ。
特定のSQL機能の使用
以下のような機能を使用すると、接続が固定されることがあります：
セッション変数: SET SESSION を使用してカスタム設定を適用。
一時テーブル: セッション固有のデータを保持。
ユーザー定義関数（UDF）: セッションスコープで動作する関数。
ロック操作: セッションスコープのロック（例: GET_LOCK()）。
トランザクション管理
トランザクション内で複数のクエリが実行される場合、トランザクションの一貫性を保つため、同じ接続を使い続ける必要があります。


逆に、接続と破棄を繰り返すLambda関数等の使用であれば、この問題は発生しないも？




目を通した導入事例とか

【AWS】RDSのインスタンスタイプを上げたらRDS ProxyのENIがDBサブネットのIPを食い尽くした話 - BFT名古屋 TECH BLOG
Amazon RDS Proxy が BASE にもたらした期待以上の導入メリット - BASEプロダクトチームブログ



Aurora

Auroraを利用すると、簡単にレプリケーションやクラスタの設定が可能
Auroraの構成

1つ以上のインスタンスと1つのクラスタボリューム
インスタンスには読み取り/書き込みを行うプライマリと読み取りのみをサポートするレプリカ


RDSでAurora以外のエンジンを使用している場合との比較

インスタンスとストレージが分離している点が大きく異なる
AuroraはRDSにまたがる分散ストレージにより、バックアップや復旧がRDSより高速
RDSより割高なイメージがあるが、構成と運用次第でRDSよりも費用を抑えられる


Auroraのバージョン

MySQLやPostgreSQLのコミュニティバージョンに対応した独自のAuroraバージョン
major.minor.patchの構成
マイナーとパッチは自動アップグレードも可能
アップグレードにはDBの停止を伴うことを想定する
コミュニティサポート期限が切れると現行以降のメジャーバージョンに自動アップグレードされてしまうので注意


レプリケーションとフェイルオーバー

レプリケーション

プライマリインスタンスに書き込みが発生すると、通常100ミリ秒以下の遅延でレプリカ側でも書き込まれたデータを参照可能になる
レプリカは最大15台をクラスタに組み込めるので、読み込み負荷の高いアプリケーションはAuroraを検討すると良い
複数リージョンにまたがるグローバルデータベースでも、レプリケーションが1秒以内
レプリケーション先にDBインスタンスは不要(クラスタボリュームがあるため)
DR対策としてもAuroraは優位性がある


フェイルオーバー

プライマリに障害が発生すると、レプリカが昇格する
フェイルオーバーの開始から終了までは通常30秒以内
なおシングルインスタンス構成の場合は、障害が発生したAZにDBインスタンスを作成しようとする




スケーリング

最大128TiBまで容量を自動拡張する

拡張時にパフォーマンス影響なし


手動でインスタンスクラスを変更すると、容量だけでなくCPUやメモリもスペックアップ可能だが、サービス停止が発生するので注意
無停止でインスタンスクラスが自動スケールするAuroraServerlessもある



AuroraServerless

ユーザーが事前に設定した範囲で自動スケールアップ

DynamoDB

フルマネージド型のNoSQLデータベース
DynamoDBの特徴

高信頼性

リージョン内3AZに同期されるので、高い可用性と耐障害性


高スループット

テーブルごとのRead/Writeそれぞれにスループットキャパシティを柔軟に割り当てられる


サーバーレス

VPCの設計が不要
事前に設定するキャパシティに基づいて自動スケーリングできる
容量無制限
データのパーティショニングも自動で行われる




整合性モデル

DynamoDBはデフォルトで「結果整合性のある読み込み」を行う
DynamoDBでは少なくとも2AZで書き込み完了後、およそ1秒以内にAck(確認応答)を返す
書き込み後1秒の間にアクセスした際のデータ不整合を許容できる場合はデフォルトのままで良い
「強力な整合性のある読み込み」をするには、DynamoDBへのリクエスト時に「ConsistentReadパラメータ」を付与する(追加でコストがかかる点に注意)
トランザクション読み込み/書き込みAPIもある


モード

実際に使用した分にかかる「オンデマンドキャパシティ」と事前に予測可能な場合に有用な「プロビジョンドキャパシティ」がある
単位や請求内容が異なるので注意
インスタンスを用いるRDSよりは、多くの場合で費用を削減できる



DynamoDBの設計

以下のプライマリキーが必要

パーティションキー(必須)

テーブルのアイテムはパーティションという領域に配置される
このパーティションキーの値を元に配置先のパーティションが決定される


ソートキー

パーティションキーが同一であるアイテムに対し、並び順を保証するために使用される




この辺り理解甘いから公式ドキュメントを読み込みたい

DynamoDB を使用した設計とアーキテクチャの設計に関するベストプラクティス - Amazon DynamoDB



7.ストレージ

大量のデータを保存したい場合：S3
Lambdaや複数のLinux系EC2インスタンスからデータを利用したい場合：EFS

EBS

オンプレミスサーバに例えると、搭載する物理ディスクにあたる
費用は、プロビジョニングされた容量に対して発生するので、インスタンスが停止していても課金されるので注意

S3

オブジェクトストレージ
インターネットからアクセスを受け付けるS3には適切なセキュリティ対策が必要

セキュリティ

データ保護

2023年1月より、S3に追加される全てのオブジェクトにはSSE-S3での暗号化が自動適用されるようになった

監査や鍵の一元管理が不要であれば、追加費用かからず管理の手間もないSSE-S3を利用すると良い




アクセスポリシーの全体像

リソースベースのポリシーとユーザーベースのポリシーを利用して、リソースへのアクセスを管理できる
リソースベースのポリシー

バケットポリシー
バケットアクセスコントロールリスト(ACL)
オブジェクトACL

バケットアクセスコントロールリスト(ACL)とオブジェクトACLは、使用する必要がないケースが多い


バケットポリシーとユーザーポリシーで同じ対象に異なるアクセス制限(拒否と許可など)がされている場合は、より厳しい制限が適用されるので注意





8.アプリーション統合
Amazon API Gateway

2種類のAPIが用意されており、RestfulAPIとチャットなどのリアルタイム双方向通信を行うステートフルなWebSocketAPIがある
RestfulAPIには、WAF統合やクライアントごとのスロットリングなどの多機能なREST APIと、機能を絞り費用を抑えたHTTP APIが存在する

以下を参考に、要件に対して必要な機能を検討してどちらかを選ぶようにする
REST API と HTTP API のどちらかを選択する - Amazon API Gateway


マッピングテンプレートを使用すると、リクエストやレスポンスの整形が可能
トークンバケットアルゴリズムを使用したスロットリング
公式が出しているベストプラクティスもある

Amazon API Gateway のセキュリティのベストプラクティス - Amazon API Gateway
書かれているのは、最小権限やアクセスログの記録・アラート設定、CloudTrailの有効化など



EventBridge

EventBridgeの特徴

EventBridgeは、様々なAWS内やSaaSアプリケーションのイベントを受信・処理し、ターゲットであるAWSサービスへ渡すイベント駆動型のマネージドサービス
スケジュールをトリガーとしたルール実行も可能


イベントバスの種類

イベントバスと呼ばれるパイプラインでイベントを受信する


アクセス制御

デフォルトのイベントバスは、操作しているAWSアカウントからのイベントを許可する
各サービスのアクセス制御は、ターゲット側のポリシーで許可するorEventBridgeのルールのIAMロールでポリシーを設定する



EventBridgeのルールと入力トランスフォーマー

ターゲットは5つまで指定できる
並列実行が可能
DatadogやNewRelic等のサードパーティツールにも統合可能
入力トランスフォーマーでターゲットに渡す情報を編集できる

SNSやSQSとの使い分け

同じイベント駆動型アプリケーションであるSNSやSQSとの使い分けについて
SNSやSQSを使用するケースは以下の通り

低レイテンシが求められる
多数のエンドポイントが必要
対人メッセージングに利用(SNSを使うべし)
順序保証が必要


SNS

プッシュ方式

プロデューサー == ブローカー == コンシューマーという構成でブローカーからコンシューマーへジョブがプッシュされる




SQS

プル方式

コンシューマー側が能動的にブローカー(キュー)からメッセージを取得する


P2P方式

プロデューサーとコンシューマが1：1で連携する方式




EventBridge

スケジュール実行・SaaSサービスとの連携・メッセージの加工はEventBridgeにしかない機能


要件に合わせて使い分けることが大切

9.可用性

疎結合化の文脈で、システムのつなぎ目に拡張性・耐障害性に優れた機能を配置すると良い

例えば、ロードバランサやDNS・メッセージキュー
つなぎ目にはできるだけ非同期処理を行うコンポーネントを配置する

EventBridge,SQS,Kinesisシリーズ群,Step Functions
SQS(スタンダードキュー)は、1秒間にほぼ無限にAPIコールを受け付けられるため、可用性は問題にならない


疎結合には、スケールアウトした時に他のコンポーネントへの影響が少ないことや障害発生時の切り分けもしやすいことがメリットになる



SLA

AWSはSLAを満たせなかった場合、サービスクレジットとして還元される

キャッシュバックではなく、今後請求される支払いに対して利用できるもの
契約者は、いくつかの情報を揃えてAWSに提出する必要がある(自動で適用されるものではない点に注意)



10.セキュリティ

クラウド事業者の選定

ISMAPのクラウドサービスリスト: https://www.ismap.go.jp/csm?id=cloud_service_list


Amazon Inspector

CIS Benchmarksに沿って、EC2やECRのOSやミドルウェア設定を確認・可視化できる
ベストプラクティスに準拠していない場合はレポート出力される


リスク検出を支援するAWSサービス

無料で手軽に：TrustedAdvisor, IAM Access Analyzer
ルールをカスタマイズもできる：AWS Config
それほど料金かからない：SecurityHub



11.ジョブ管理

バッチ処理を行うシステムをジョブ管理システムという
AWSのジョブ実行に関連するサービスはいくつかある

15分以内ならLambdaで実装するのが良い

ECS Scheduled TaskやBatchと比較して安価


ECS Scheduled Taskは、EventBridgeでのトリガを元にECSを実行するというもの



Batch

長時間、高負荷な処理はBatchでの実装を検討すると良い

逆に短時間で終わるものや即時実行が必要なジョブには向いていない


Batchはコンテナ環境を使って処理を行うので、注意すべきポイントがいくつかある
Batchの特徴

コンポーネント

BatchのジョブはECSやEKSのコンテナ上で実行される


スポットインスタンスの活用

コストを安くできる反面、発生しうる中断に対してのケアが必要

冪等性を考慮したジョブ設計にし、リトライできるようにする


ジョブを短時間で終わるように設計する

定期的に結果をS3やEFSに出力するチェックポイント方式にする


ジョブの再試行回数を設定する
実際の設計例では、

優先度の高いジョブはオンデマンドに処理させて、そうではないジョブはスポットインスタンスにするとか
スポットインスタンスで失敗したジョブをSNSに通知→Lambdaを経由して、オンデマンド用キュー→オンデマンドインスタンスでジョブを再実行とか方法がある







Step Functions

AWSサービスやAPIを組み合わせ、ワークフローを視覚的に作成・実行できるサービス
ワークフロータイプ

StandardとExpressがある

実行頻度の高い処理を短時間で処理させる場合はExpressを選択する




料金

Lambdaよりは割高
状態遷移の回数で課金される
EventBridgeーLambdaの構成であれば無料利用枠内に収まるなんてこともあるので、見積もりを慎重に行う


StepFunctionsはデバッグがしやすい

ステートごとに入出力やイベントが見やすかったり
ステートごとにログが時系列でわかりやすく並んでいたりする



12.バックアップ

オンプレでもクラウドでもバックアップの重要性は変わらない

AWSのバックアップ

EC2

Amazon Data Lifecycle Managerで定期的にスナップショットを取得


RDS

自動バックアップの有効化、手動バックアップの実行


S3

バージョニング有効、ライフサイクル管理



AWS Backup

フルマネージドなバックアップサービス
最低料金や初期費用が発生しない
バックアップの自動化や保存期間が過ぎたデータなどバックアップに関する一元管理が可能
対象は、AWSリソースのみ
概要

バックアッププランを作成し、ルールで指定したスケジュールでバックアップを行う
バックアッププランで、AWSリソースを指定する


想定外にかかる費用

簡単に設定できてしまう反面、想定より費用がかかるケースがある
バックアップを一定期間運用した後は、定期的に適切な範囲に収まっているかを確認した方が良い



13.監視

RDS

スロークエリなどを出力したい場合は、パラメータグループのlog_outputをFILEにする


VPC

VPC内のトラフィック情報をCloudWatch Logsに出力するには、VPCフローログが必要


">
<meta name="author" content="nyuusen">
<link rel="canonical" href="http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/">
  <meta property="og:site_name" content="nyuusen blog">
  <meta property="og:title" content="AWS設計スキルアップガイド">
  <meta property="og:description" content="AWS設計スキルアップガイド ――サービスの選定から、システム構成、運用・移行の設計まで：書籍案内｜技術評論社
2.クラウドのインフラ設計 クラウドで考えるセキュリティ 万が一の事故や障害が発生したときに「責任分界点」を定義しておくことで、責任の所在を明らかにできる AWSでの「責任共有モデル」では、それぞれの責任について以下のように定義されている AWS: サービスを提供するためのインフラストラクチャ 利用者: 選択したAWSサービスごとの適切なセキュリティを実装し、システムを保護する AWS SecurityHubを使用することで、横断的にセキュリティの問題を検知することができる 3.システムの構成 AWSでシステムを構築する時にまず考えるべきは「アカウントをどの単位で発行するか」 AWSアカウントの運用例 単一のアカウントで運用するケース 注意ポイント VPCをプロジェクトや環境ごとに分離する プロジェクトや環境がわかるようにタグを活用する VPCに関連のないサービスを使用する場合、IAMで権限を設定する 管理する請求先が1つになるメリットはあるが、誤操作等によるミスや事故リスクが上がるので、できればアカウントは分けて運用するのが良い 複数のアカウントで運用するケース アカウントの統制を考慮する AWS ControlTowerで一元管理 Organizationで多数のAWSアカウントを管理 ログインIDの統合を検討する(1つのユーザーアカウントで各AWSアカウントにログインできるようにする) 各環境のIAMロールで行う方法 AWS IAM Identity Center (SSO)を活用する方法 サードパーティIDaaSを活用する方法 (追記) AWS ControlTowerを利用すると、マルチアカウント環境を一元的に整備してくれる 参考: スタートアップにおけるマルチアカウントの考え方と AWS Control Tower のすゝめ | AWS Startup ブログ IAM 認証はIAMユーザー、認可はIAMポリシーで設定する 通常、ポリシーはグループもしくはロールに付与する なぜなら、ユーザーにポリシーをアタッチすると、運用工数がかかる IAMポリシー設計 デフォルトはすべて拒否なので、明示的に許可していく どのリソース(Resource)に対して、どんな条件で(Conditions)、どんな動作(Action)を、許可/拒否する(Effect)かをJSONもしくはGUIで記述(選択)する ポリシーはいくつか種類がある(使用頻度が高いものを抜粋) アイデンティティベースのポリシー アイデンティティ(ユーザー、グループ、ロール)にアタッチする この中にも再利用可能な管理ポリシーとインラインポリシーが存在(管理ポリシー推奨) リソースベースのポリシー S3などのリソースにアタッチする セッションポリシー 一時的にセッション単位でアクセスを許可するポリシー AssumeRoleなどのAPIを利用する ポリシー評価について 以下の順番で評価される 画像引用元: 【入門編】AWSにおけるアクセスポリシーの評価ロジックを整理してみる 明示的な拒否があれば、その拒否設定が適用される 拒否設定の後に、明示的な許可設定があったとしても、拒否設定が優先的に適用される 明示的な許可があれば許可となるが、なかった場合は暗黙的に拒否される 4.ネットワーク設計 オンプレミスとの比較 オンプレミスと比較すると、AWSにおけるネットワーク設計はある程度ざっくりでOK 名前解決 オンプレミス: 内部DNSを立てるか各サーバーのhostsファイルを利用して名前解決を行う AWS: 自動でパブリックのDNS名が割り当てられ、マネージドのDNSで名前解決を行う 時刻同期 オンプレミス: システム内の時刻が同期するように同一のNTPサーバーを割り当てる AWS: AmazonTimeSyncServiceで同期する(インターネット接続不要) マネージドNTP VPCで実行されているすべてのインスタンスの 169.254.169.123 IPアドレスで NTP を介して利用できる 最新バージョンのAmazonLinux2とAmazonLinuxAMIはデフォルトでAmazonTimeSyncServiceと同期してくれている LambdaやECS on Fargate等のマネージドサービスではAWS側で時刻同期されているはずとのこと AWSマネージドサービスの時刻同期はAWS側で行われているのか | AWS re:Post VPCとサブネット VPCはリージョンごとのサービスなので、リージョンを跨ぐことはできない サブネットではいくつかのIPアドレスがAWSの予約枠として確保されている ネットワークアドレス (最初のIPアドレス) 例: 10.0.0.0/24サブネットの場合、10.0.0.0がこのアドレスです。 役割: ネットワーク自体を表すためのアドレスであり、ルーティングやネットワーク構成で使用されます。 VPCルーター (2番目のIPアドレス) 例: 10.0.0.1がこのアドレスとなります（サブネットによって異なる場合もあり）。 役割: サブネット内での通信を管理する仮想ルーターです。インスタンス間の通信やインターネットゲートウェイ、VPN接続の経路制御など、サブネット内のルーティングに使用されます。 DNSサーバー (3番目のIPアドレス) 例: 10.0.0.2です。 役割: AWSが提供するDNSリゾルバーのIPアドレスです。VPC内のインスタンスがDNSクエリを行う際に使用します。独自のカスタムDNS設定を行わない限り、このアドレスがデフォルトでDNSリゾルバーとして機能します。 将来の用途のために予約されたアドレス (4番目のIPアドレス) 役割: 現時点で特定の用途が明確には指定されていませんが、AWSが今後の機能拡張や内部用途のために予約しています。 ブロードキャストアドレス (最後のIPアドレス) 例: 10.0.0.255/24サブネットの場合、10.0.0.255がこのアドレスです。 役割: ブロードキャスト通信のために予約されていますが、AWSのVPCではブロードキャスト通信はサポートされていないため、実際に使用することはありません。 セキュリティグループ・ネットワークACL・AWS Network Firewall AWS Network Firewallは有料なのであまり使われない セキュリティグループ(SG)→ネットワークACLと、フィルタの範囲を狭めて、シンプルな構成・運用にする SGは、同一SGに所属しているノード同士の通信でも明示的に許可する必要がある ルートテーブル ルートテーブルは複数のサブネットで共有可能 サブネット作成時にルートテーブルも作成され、追加の設定なくVPC内の通信は可能 デフォルトで、VPC内の全てのサブネットに向けたローカルルートが設定されているため ということは、同じVPC内のサブネットに存在するリソース間で通信を拒否したい場合は、セキュリティグループで設定する必要がある VPCエンドポイント 異なるVPCやリージョンに配置されたAWSサービスへインターネットを経由せずに接続するサービス ゲートウェイエンドポイント ルートテーブルでAWSサービスへのルートを指定 費用かからない インターフェイスエンドポイント VPCのプライベートIPアドレスを使用してアクセスする ENIとしてVPC内に配置され、それがサービスに接続するためのエンドポイントとして動作する 処理するデータ量に応じて課金される 例えばS3は、どちらでも接続可能だが、インターフェイスエンドポイントの方がセキュリティグループでトラフィックを制御できるため、セキュアである VPC内のリソースがエンドポイントに対して、どのように通信できるかを詳細に制御ができるため、という意味(IPやプロトコル等の制限が可能) VPCフローログ VPC内のネットワークインターフェースに流れる情報をキャプチャし、ログに記録する 監査に必要なログを出力したり、通信がうまく通らない場合はトラブルシューティングとして出力したり フローログは以下の3つの項目を指定する フローログを取得するリソース(VPC/サブネット/ENIをもつELBやNATGateway等) どんなトラフィックをキャプチャするか(許可、拒否、全て) フローログの出力先(CloudWatch Logs/S3) AWSにセキュアに接続する AWS Client VPN サイト間VPN Direct Connect 5.コンピューティング Lambda イベント駆動型のアプリケーションで使いやすい コールドスタートにかかる時間を短くする方法 VPC内にアクセスしない(ENI作成に10〜30秒かかるため) VPC Lambdaと呼ばれてるやつ Lambdaをパブリックサブネットに配置するとENIが作成されアタッチされる そのENIに対し、パブリックIPを付与(アドレス関連付け)してやれば、Lambdaからアウトバウンドの通信ができるらしい メモリ増やす(メモリ量に比例してCPUも増加する) コード量を短くする 関数の初期化や依存解決の速度の向上が見込まれるため Lambdaのセキュリティ IAMを最小限にする 特定の条件下で特定のリソースに対して実行できるアクションのみ定義する 基本的には複数のLambda関数でIAMロールで共有しない Lambdaの監視 Lambda関数をデプロイすると自動でCloudWatch Logsと連携する＋レイテンシやエラー率などのメトリクスも自動で発行する エラーを検知できるようにアラートを設定しておくと良い 特にDuration(所要時間)やThrottles(同時実行上限を超えて制限した数)は、エラーが発生する前に適切検知できるようにしておく EC2 インスタンスタイプの書式 Amazon EC2 インスタンスタイプの命名規則 - Amazon EC2 オプション コンピューティング最適化: CPU大きめ メモリ最適化: メモリ大きめ AMI インスタンス起動するのに必要なOSやボリューム・アプリケーションを含むテンプレート OSのライセンス費用はEC2の利用料金に含まれている(オンプレと異なる点であり、メリットである) インスタンスの費用削減 リザーブドインスタンス 時間単位の費用を削減できる 1年や3年の長期使用を約束する インスタンスクラスの変更しない場合、または負荷増加の際にオンデマンドインスタンスやスポットインスタンスで対応できる場合に検討する 実際の使用有無に関わらず、購入した条件に応じた期間の費用が発生する SavingsPlans これも1年や3年の長期使用を約束する リザーブドインスタンスとの違いは、LambdaやFargateでも使用可能である点、インスタンスファミリーやプラットフォームなどを指定しなくて良い 逆にRDSやElasiCacheでは使用できないので注意 3種類がある インスタンスタイプや構成を柔軟に変更する予定がある場合は、SavingsPlansを検討する スポットインスタンス AWSクラウド内の使用されていないEC2キャパシティを活用し、中断される可能性がある なので、本番環境で常時起動するサーバーではなく、ECS実行環境やCICDのビルド環境、バッチに適用する 本番環境で適用する場合は、AutoScalingグループでオンデマンドインスタンスとスポットインスタンスの割合を指定する等して、中断が影響しないようにする 中断の2分前にAWSから警告が来るので、アプリケーションの安全な停止や、ログの退避などは自動で対応できるように実装する インスタンスメタデータで中断対象か確認できる インスタンスメタデータを取得できるAPIがあるっぽい そこを定期的に叩くことで確認 T系インスタンスの注意点 汎用のT系はM系よりも安価でありよく選定されるが、バーストパフォーマンスインスタンスであることは十分に理解が必要 バーストパフォーマンスインスタンスとは ベースラインと呼ばれるCPU使用率がある そのベースラインに対して、下回る間はクレジットを獲得し、超える間は消費する 1CPUクレジット=1vCPU×100%使用率×1分 つまり、1vCPUを50%使用率で2分使用すると、1クレジット消費するということ 24時間の間で、獲得したクレジットよりも消費するクレジットが多い場合に、その分のvCPU費用が発生する T系インスタンスの各タイプで、1時間あたりに受け取るクレジットや蓄積可能なクレジット、ベースライン使用率は決められている CPUクレジットの消費タイプには以下の2種類がある Standard: 残高が0になると、ベースライン使用率以下でのみ使用可能となる Unlimited: Standardのような制約はない代わりに、CPUクレジットが0になった後は、vCPU時間ごとに均一追加料金が発生する（他のインスタンスタイプの利用料金を超える可能性がある） 重要なのは、CPU使用率を監視すること CloudWatchメトリクスで参照可能 バーストインスタンスの CPU クレジットをモニタリングする - Amazon Elastic Compute Cloud 参考: バーストパフォーマンス(T系)インスタンスの特徴を理解して上手に利用しよう | AWS Startup ブログ コンテナ 仮想化とコンテナの違い ゲストOSの有無が大きな違い 仮想化はホストOSを介して、ハードウェアを制御するため、オーバーヘッドが大きい コンテナは、アプリケーションの動作環境を隔離していて、カーネルはホストOSに依存するため、仮想化のように複数の異なるOSを稼働させることはできないが、逆に言えばOSがない分起動が早く、使用するリソースも少なくて済む コンテナとEC2の違い EC2上でコンテナを実行するのと、ECSやEKSなどのオーケストレーションツールを使用するのとでどのような違いがあるのかという問いと同義 EC2上で動かした場合、デプロイする時は、EC2アプリケーションを更新→AMIを取得→AutoScaling対象のAMIを変更するという、とても面倒な手作業が発生する 逆にロールバックの作業も面倒.. 加えて、OS更新等の手作業も発生する 一方、ECSの場合は、コンテナやOSの障害や更新をAWS側が管理してくれる CI/CDパイプラインを構築すれば、アプリケーション変更から適用まで迅速に行える コンテナがプロセス落ちを管理し、再度デプロイしてくれる(Serviceがやっていることかな？) コンテナを構成するサービスの特徴 複数の環境を有するシステム 再現性が高い特徴を活かせる 更新頻度が高いシステム アクセス増減の発生が高いシステム もはやこのご時世的にはあえてEC2を選択するケースはないのではと思う コンテナサービスを作るときに気をつけること 障害発生することを前提とする プロセスが落ちても、すぐに起動できるように ECS Serviceを使えという話だと思う 環境差異は変数化する ログ出力を1本化する コンテナは実行環境であるホストOS上でプロセスとして動作し、他のプロセスから隔離されている コンテナ内部でアプリケーションログを吐いても、プロセス停止した際などにログが残らなくなってしまう ホストOSか別の領域に出力するように設定する ちょっと調べた感じ、タスク定義でログドライバにawslogsを設定し、ロググループなども設定すれば、1つのロググループに出力されるようになるっぽい 1コンテナ1プロセスとする 1つのコンテナに複数のプロセスを稼働させることも可能だが、制御が難しいため Amazon ECS ECSの構成要素 クラスター：実行環境 タスク定義：指定のコンテナを動かす サービス：全体の構成やデプロイ方法を設定 タスク定義 主な設定項目 Dockerイメージ コンテナのCPUとメモリ データボリューム IAMロール コンピューティング環境(EC2 or Fargate) サービス 主な設定項目 連携するELBを指定 指定したタスク定義のタスク数 デプロイ方法(Blue/Green,ローリングアップデート) 実行環境(EC2,Fargate)で待ち受けるポートや、コンテナ側で待ち受けるポートも指定する サービスはなくても動くけど、AutoScalingの実装等に必要 クラスター 主な設定項目 コンテナ実行環境のネットワークを指定 起動するインスタンスタイプやAMI、その数を指定 Fargateの場合は、ネットワーク作成とクラスター名のみを設定する タスク定義の更新 コンテナイメージにつけるタグ名はlatestにするとタスク定義の修正が不要になる一方、コンテナイメージのバージョンがわからないのがで名rっと デプロイ方法「ローリングアップデート」と「Blue/Greenデプロイメント」がある ローリングアップデートの例 DesiredCountを4に、minimumHealthyPercentを0.5に設定した場合、4 * 0.5の2インスタンスが更新されたタスク定義を元に作成される Blue/Greenデプロイメントの例 タスク定義を更新すると、新たにGreen環境が作成あれ、疎通に問題がなければ、LBのレイヤーで切り替えを行う（だからLBが必須） データボリューム ログや共通のデータはコンテナ外に領域を確保する ECSで選択可能なデータボリュームは以下になる EFS FSx for Windows File Sever Dockerボリューム EC2のみ利用可能 バインドマウント ホスト上のファイルやディレクトリをコンテナからマウントする Fargate タスクエフェメラルストレージ エフェメラルストレージ=一時的なストレージ プロビジョニング時にECSタスクが受け取るもの これらをマウントし、タスク定義内でvolumes、mountPointsおよびvolumesFromパラメータを使用しているコンテナ間で共有することが可能 Amazon ECS タスクのストレージオプション - Amazon Elastic Container Service 6.データベース データベースの選択 どんな用途なのかと移行か新規なのか、複数の観点からの検討が必要 RDS EC2同様に仮想サーバー上で実行される EC2でもDBの構築は可能だが、RDSと異なり自動スケーリングや高可用性、OS・DBソフトウェアのパッチ適用などはユーザーが設計・実装・運用する必要がある 逆に、その辺りを自前で管理したい・RDSでサポートされていないパラメータをチューニングしたい・開発環境などで費用削減をしたいという場合はEC2でのDB構築が選択肢になる リクエストのI/Oサイズやアクセスパターンにより、パフォーマンスが大きく変わる シーケンシャルなアクセスでは、最大I/Oサイズに達するまで、単一のI/O操作に含められる ランダムなアクセスでは、最大I/Oサイズに達しない小さいサイズでも、IOPSに個別カウントする つまりランダムアクセスの場合はIOPSの消費が多いので、それを考慮してインスタンスクラスなどを決めようという話 パフォーマンスは、DBで最も重要な非機能要件になるので、机上確認だけでなく、実際に検証したり、CloudWatchメトリクスで確認したりして、ストレージタイプを選ぶと良い マルチAZ構成 サポートされている機能は、リージョンやデータベースエンジンによって異なる マルチAZデプロイすると、Read/WriteできるプライマリDBインスタンスとフェイルオーバー先となるスタンバイレプリカ(読み取り書き込みはできない)が別AZへデプロイされる スタンバイレプリカは通常時は動作せず、プライマリに障害が発生した時にレプリカが昇格する フェイルオーバーは60〜120秒 マルチAZ DBクラスタ 1つの読み取り/書き込みインスタンスと、2つ以上の読み取り専用スタンバイDBインスタンスで構成 読み取り/書き込みインスタンスに障害が発生したら、読み取り専用スタンバイDBインスタンスが昇格 書き込み専用DBインスタンス接続するクラスタエンドポイントと、読み取り専用に接続するリーダーエンドポイントがある エンドポイントは、クラスタ内の対象インスタンスに接続できない場合に自動的に接続先を変更する フェイルオーバーは35秒未満 RDS Proxy RDSでは、アプリケーションからの接続を処理する際にメモリやCPUを消費する 頻繁に短時間でDB接続を繰り返すアプリケーションでは、DBの処理負荷を下げるためRDS Proxyを導入すると良い RDSの最大接続数はパラメータグループのmax_connectionsで定義されており、手動変更は推奨されていない そのため、同時接続数が上限に達しそうな場合は、上位のインスタンスクラスorRDS Proxyを検討する RDS Proxyの特徴 フルマネージドサービス アプリケーションとRDSの間に設置 VPC内の異なるAZにある2サブネットを選択して作成 RDS Proxyを間に配置することによる遅延は5ミリ秒程度 RDSのインスタンスレベルを上げずに済むので、コストや運用工数を抑えられる RDS Proxyを採用するメリット フェイルオーバーにかかる時間を短縮できる 数秒レベルでフェイルオーバーが完了する RDS Proxyがない場合は、スタンバイの昇格とクラスタエンドポイントの更新後にアプリケーションが再接続するのに比べて、RDS Proxyがある場合はアプリケーションからの接続をプールし、RDS ProxyからRDSへの接続は処理中であったものを除いて保持・再利用するため この箇所ちょっと引っかかったので調べてみた。 RDS Proxyの使用有無で、RDS側のフェイルオーバーにかかる時間は変わらないと思う ただし、アプリケーションの視点で見た時に、RDS Proxyへのコネクションを再確立する必要がない RDS ProxyーRDS間のコネクションの再確立のみで不要 なので、アプリケーション側からすると、再接続するオーバーヘッドがかからないので、フェイルオーバーにかかる時間を短縮できると表現されていると思われる(RDS側のDNS更新も待つ必要もない) RDS Proxyを利用する際の注意点 IPアドレスの枯渇 IPアドレスを消費するのは、RDS Proxy-RDSの接続 RDS Proxy-RDSは、同じVPC内で通信するため、プライベートIPアドレスを使用する RDS Proxyは、接続先RDSのインスタンスクラスと台数に応じて自動的に容量を増減し、場合によっては多くのIPアドレスを利用する IPアドレスが枯渇するとうまくスケールができず、クエリ遅延やコネクション失敗が発生することがある インスタンスクラスごとに確保すべき最小IPアドレス数が定められている 回避する方法としては、サブネットのIPアドレス範囲を広くすることが推奨される セッション固定（ピン止め）による影響 特定のトランザクションやセッションが接続プール内の特定のバックエンド(DB)接続に固定される状態を指す この状態になってしまうと、通常共有可能な接続が他のリクエストに再利用されなくなり、DBへの同時接続数が増え続け、最終的にはDB接続が行えなくなる可能性がある CloudWatchメトリクスの「DatabaseConnectionsCurrentlySessionPinned」を監視すると良い ピン留め発生が想定されるケース ステートフルなリクエスト ユーザーセッションに依存する処理が行われる場合、同じバックエンド接続を使用し続ける必要があります。 例: 一時テーブルやユーザー固有の設定を使用したクエリ。 特定のSQL機能の使用 以下のような機能を使用すると、接続が固定されることがあります： セッション変数: SET SESSION を使用してカスタム設定を適用。 一時テーブル: セッション固有のデータを保持。 ユーザー定義関数（UDF）: セッションスコープで動作する関数。 ロック操作: セッションスコープのロック（例: GET_LOCK()）。 トランザクション管理 トランザクション内で複数のクエリが実行される場合、トランザクションの一貫性を保つため、同じ接続を使い続ける必要があります。 逆に、接続と破棄を繰り返すLambda関数等の使用であれば、この問題は発生しないも？ 目を通した導入事例とか 【AWS】RDSのインスタンスタイプを上げたらRDS ProxyのENIがDBサブネットのIPを食い尽くした話 - BFT名古屋 TECH BLOG Amazon RDS Proxy が BASE にもたらした期待以上の導入メリット - BASEプロダクトチームブログ Aurora Auroraを利用すると、簡単にレプリケーションやクラスタの設定が可能 Auroraの構成 1つ以上のインスタンスと1つのクラスタボリューム インスタンスには読み取り/書き込みを行うプライマリと読み取りのみをサポートするレプリカ RDSでAurora以外のエンジンを使用している場合との比較 インスタンスとストレージが分離している点が大きく異なる AuroraはRDSにまたがる分散ストレージにより、バックアップや復旧がRDSより高速 RDSより割高なイメージがあるが、構成と運用次第でRDSよりも費用を抑えられる Auroraのバージョン MySQLやPostgreSQLのコミュニティバージョンに対応した独自のAuroraバージョン major.minor.patchの構成 マイナーとパッチは自動アップグレードも可能 アップグレードにはDBの停止を伴うことを想定する コミュニティサポート期限が切れると現行以降のメジャーバージョンに自動アップグレードされてしまうので注意 レプリケーションとフェイルオーバー レプリケーション プライマリインスタンスに書き込みが発生すると、通常100ミリ秒以下の遅延でレプリカ側でも書き込まれたデータを参照可能になる レプリカは最大15台をクラスタに組み込めるので、読み込み負荷の高いアプリケーションはAuroraを検討すると良い 複数リージョンにまたがるグローバルデータベースでも、レプリケーションが1秒以内 レプリケーション先にDBインスタンスは不要(クラスタボリュームがあるため) DR対策としてもAuroraは優位性がある フェイルオーバー プライマリに障害が発生すると、レプリカが昇格する フェイルオーバーの開始から終了までは通常30秒以内 なおシングルインスタンス構成の場合は、障害が発生したAZにDBインスタンスを作成しようとする スケーリング 最大128TiBまで容量を自動拡張する 拡張時にパフォーマンス影響なし 手動でインスタンスクラスを変更すると、容量だけでなくCPUやメモリもスペックアップ可能だが、サービス停止が発生するので注意 無停止でインスタンスクラスが自動スケールするAuroraServerlessもある AuroraServerless ユーザーが事前に設定した範囲で自動スケールアップ DynamoDB フルマネージド型のNoSQLデータベース DynamoDBの特徴 高信頼性 リージョン内3AZに同期されるので、高い可用性と耐障害性 高スループット テーブルごとのRead/Writeそれぞれにスループットキャパシティを柔軟に割り当てられる サーバーレス VPCの設計が不要 事前に設定するキャパシティに基づいて自動スケーリングできる 容量無制限 データのパーティショニングも自動で行われる 整合性モデル DynamoDBはデフォルトで「結果整合性のある読み込み」を行う DynamoDBでは少なくとも2AZで書き込み完了後、およそ1秒以内にAck(確認応答)を返す 書き込み後1秒の間にアクセスした際のデータ不整合を許容できる場合はデフォルトのままで良い 「強力な整合性のある読み込み」をするには、DynamoDBへのリクエスト時に「ConsistentReadパラメータ」を付与する(追加でコストがかかる点に注意) トランザクション読み込み/書き込みAPIもある モード 実際に使用した分にかかる「オンデマンドキャパシティ」と事前に予測可能な場合に有用な「プロビジョンドキャパシティ」がある 単位や請求内容が異なるので注意 インスタンスを用いるRDSよりは、多くの場合で費用を削減できる DynamoDBの設計 以下のプライマリキーが必要 パーティションキー(必須) テーブルのアイテムはパーティションという領域に配置される このパーティションキーの値を元に配置先のパーティションが決定される ソートキー パーティションキーが同一であるアイテムに対し、並び順を保証するために使用される この辺り理解甘いから公式ドキュメントを読み込みたい DynamoDB を使用した設計とアーキテクチャの設計に関するベストプラクティス - Amazon DynamoDB 7.ストレージ 大量のデータを保存したい場合：S3 Lambdaや複数のLinux系EC2インスタンスからデータを利用したい場合：EFS EBS オンプレミスサーバに例えると、搭載する物理ディスクにあたる 費用は、プロビジョニングされた容量に対して発生するので、インスタンスが停止していても課金されるので注意 S3 オブジェクトストレージ インターネットからアクセスを受け付けるS3には適切なセキュリティ対策が必要 セキュリティ データ保護 2023年1月より、S3に追加される全てのオブジェクトにはSSE-S3での暗号化が自動適用されるようになった 監査や鍵の一元管理が不要であれば、追加費用かからず管理の手間もないSSE-S3を利用すると良い アクセスポリシーの全体像 リソースベースのポリシーとユーザーベースのポリシーを利用して、リソースへのアクセスを管理できる リソースベースのポリシー バケットポリシー バケットアクセスコントロールリスト(ACL) オブジェクトACL バケットアクセスコントロールリスト(ACL)とオブジェクトACLは、使用する必要がないケースが多い バケットポリシーとユーザーポリシーで同じ対象に異なるアクセス制限(拒否と許可など)がされている場合は、より厳しい制限が適用されるので注意 8.アプリーション統合 Amazon API Gateway 2種類のAPIが用意されており、RestfulAPIとチャットなどのリアルタイム双方向通信を行うステートフルなWebSocketAPIがある RestfulAPIには、WAF統合やクライアントごとのスロットリングなどの多機能なREST APIと、機能を絞り費用を抑えたHTTP APIが存在する 以下を参考に、要件に対して必要な機能を検討してどちらかを選ぶようにする REST API と HTTP API のどちらかを選択する - Amazon API Gateway マッピングテンプレートを使用すると、リクエストやレスポンスの整形が可能 トークンバケットアルゴリズムを使用したスロットリング 公式が出しているベストプラクティスもある Amazon API Gateway のセキュリティのベストプラクティス - Amazon API Gateway 書かれているのは、最小権限やアクセスログの記録・アラート設定、CloudTrailの有効化など EventBridge EventBridgeの特徴 EventBridgeは、様々なAWS内やSaaSアプリケーションのイベントを受信・処理し、ターゲットであるAWSサービスへ渡すイベント駆動型のマネージドサービス スケジュールをトリガーとしたルール実行も可能 イベントバスの種類 イベントバスと呼ばれるパイプラインでイベントを受信する アクセス制御 デフォルトのイベントバスは、操作しているAWSアカウントからのイベントを許可する 各サービスのアクセス制御は、ターゲット側のポリシーで許可するorEventBridgeのルールのIAMロールでポリシーを設定する EventBridgeのルールと入力トランスフォーマー ターゲットは5つまで指定できる 並列実行が可能 DatadogやNewRelic等のサードパーティツールにも統合可能 入力トランスフォーマーでターゲットに渡す情報を編集できる SNSやSQSとの使い分け 同じイベント駆動型アプリケーションであるSNSやSQSとの使い分けについて SNSやSQSを使用するケースは以下の通り 低レイテンシが求められる 多数のエンドポイントが必要 対人メッセージングに利用(SNSを使うべし) 順序保証が必要 SNS プッシュ方式 プロデューサー == ブローカー == コンシューマーという構成でブローカーからコンシューマーへジョブがプッシュされる SQS プル方式 コンシューマー側が能動的にブローカー(キュー)からメッセージを取得する P2P方式 プロデューサーとコンシューマが1：1で連携する方式 EventBridge スケジュール実行・SaaSサービスとの連携・メッセージの加工はEventBridgeにしかない機能 要件に合わせて使い分けることが大切 9.可用性 疎結合化の文脈で、システムのつなぎ目に拡張性・耐障害性に優れた機能を配置すると良い 例えば、ロードバランサやDNS・メッセージキュー つなぎ目にはできるだけ非同期処理を行うコンポーネントを配置する EventBridge,SQS,Kinesisシリーズ群,Step Functions SQS(スタンダードキュー)は、1秒間にほぼ無限にAPIコールを受け付けられるため、可用性は問題にならない 疎結合には、スケールアウトした時に他のコンポーネントへの影響が少ないことや障害発生時の切り分けもしやすいことがメリットになる SLA AWSはSLAを満たせなかった場合、サービスクレジットとして還元される キャッシュバックではなく、今後請求される支払いに対して利用できるもの 契約者は、いくつかの情報を揃えてAWSに提出する必要がある(自動で適用されるものではない点に注意) 10.セキュリティ クラウド事業者の選定 ISMAPのクラウドサービスリスト: https://www.ismap.go.jp/csm?id=cloud_service_list Amazon Inspector CIS Benchmarksに沿って、EC2やECRのOSやミドルウェア設定を確認・可視化できる ベストプラクティスに準拠していない場合はレポート出力される リスク検出を支援するAWSサービス 無料で手軽に：TrustedAdvisor, IAM Access Analyzer ルールをカスタマイズもできる：AWS Config それほど料金かからない：SecurityHub 11.ジョブ管理 バッチ処理を行うシステムをジョブ管理システムという AWSのジョブ実行に関連するサービスはいくつかある 15分以内ならLambdaで実装するのが良い ECS Scheduled TaskやBatchと比較して安価 ECS Scheduled Taskは、EventBridgeでのトリガを元にECSを実行するというもの Batch 長時間、高負荷な処理はBatchでの実装を検討すると良い 逆に短時間で終わるものや即時実行が必要なジョブには向いていない Batchはコンテナ環境を使って処理を行うので、注意すべきポイントがいくつかある Batchの特徴 コンポーネント BatchのジョブはECSやEKSのコンテナ上で実行される スポットインスタンスの活用 コストを安くできる反面、発生しうる中断に対してのケアが必要 冪等性を考慮したジョブ設計にし、リトライできるようにする ジョブを短時間で終わるように設計する 定期的に結果をS3やEFSに出力するチェックポイント方式にする ジョブの再試行回数を設定する 実際の設計例では、 優先度の高いジョブはオンデマンドに処理させて、そうではないジョブはスポットインスタンスにするとか スポットインスタンスで失敗したジョブをSNSに通知→Lambdaを経由して、オンデマンド用キュー→オンデマンドインスタンスでジョブを再実行とか方法がある Step Functions AWSサービスやAPIを組み合わせ、ワークフローを視覚的に作成・実行できるサービス ワークフロータイプ StandardとExpressがある 実行頻度の高い処理を短時間で処理させる場合はExpressを選択する 料金 Lambdaよりは割高 状態遷移の回数で課金される EventBridgeーLambdaの構成であれば無料利用枠内に収まるなんてこともあるので、見積もりを慎重に行う StepFunctionsはデバッグがしやすい ステートごとに入出力やイベントが見やすかったり ステートごとにログが時系列でわかりやすく並んでいたりする 12.バックアップ オンプレでもクラウドでもバックアップの重要性は変わらない AWSのバックアップ EC2 Amazon Data Lifecycle Managerで定期的にスナップショットを取得 RDS 自動バックアップの有効化、手動バックアップの実行 S3 バージョニング有効、ライフサイクル管理 AWS Backup フルマネージドなバックアップサービス 最低料金や初期費用が発生しない バックアップの自動化や保存期間が過ぎたデータなどバックアップに関する一元管理が可能 対象は、AWSリソースのみ 概要 バックアッププランを作成し、ルールで指定したスケジュールでバックアップを行う バックアッププランで、AWSリソースを指定する 想定外にかかる費用 簡単に設定できてしまう反面、想定より費用がかかるケースがある バックアップを一定期間運用した後は、定期的に適切な範囲に収まっているかを確認した方が良い 13.監視 RDS スロークエリなどを出力したい場合は、パラメータグループのlog_outputをFILEにする VPC VPC内のトラフィック情報をCloudWatch Logsに出力するには、VPCフローログが必要 ">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-01-15T21:58:49+09:00">
    <meta property="article:modified_time" content="2025-01-15T21:58:49+09:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AWS設計スキルアップガイド">
<meta name="twitter:description" content="AWS設計スキルアップガイド ――サービスの選定から、システム構成、運用・移行の設計まで：書籍案内｜技術評論社
2.クラウドのインフラ設計
クラウドで考えるセキュリティ

万が一の事故や障害が発生したときに「責任分界点」を定義しておくことで、責任の所在を明らかにできる
AWSでの「責任共有モデル」では、それぞれの責任について以下のように定義されている

AWS: サービスを提供するためのインフラストラクチャ
利用者: 選択したAWSサービスごとの適切なセキュリティを実装し、システムを保護する


AWS SecurityHubを使用することで、横断的にセキュリティの問題を検知することができる

3.システムの構成

AWSでシステムを構築する時にまず考えるべきは「アカウントをどの単位で発行するか」

AWSアカウントの運用例

単一のアカウントで運用するケース

注意ポイント

VPCをプロジェクトや環境ごとに分離する
プロジェクトや環境がわかるようにタグを活用する
VPCに関連のないサービスを使用する場合、IAMで権限を設定する


管理する請求先が1つになるメリットはあるが、誤操作等によるミスや事故リスクが上がるので、できればアカウントは分けて運用するのが良い


複数のアカウントで運用するケース

アカウントの統制を考慮する

AWS ControlTowerで一元管理
Organizationで多数のAWSアカウントを管理


ログインIDの統合を検討する(1つのユーザーアカウントで各AWSアカウントにログインできるようにする)

各環境のIAMロールで行う方法
AWS IAM Identity Center (SSO)を活用する方法
サードパーティIDaaSを活用する方法




(追記)

AWS ControlTowerを利用すると、マルチアカウント環境を一元的に整備してくれる
参考: スタートアップにおけるマルチアカウントの考え方と AWS Control Tower のすゝめ | AWS Startup ブログ



IAM

認証はIAMユーザー、認可はIAMポリシーで設定する

通常、ポリシーはグループもしくはロールに付与する
なぜなら、ユーザーにポリシーをアタッチすると、運用工数がかかる



IAMポリシー設計

デフォルトはすべて拒否なので、明示的に許可していく

どのリソース(Resource)に対して、どんな条件で(Conditions)、どんな動作(Action)を、許可/拒否する(Effect)かをJSONもしくはGUIで記述(選択)する


ポリシーはいくつか種類がある(使用頻度が高いものを抜粋)

アイデンティティベースのポリシー

アイデンティティ(ユーザー、グループ、ロール)にアタッチする
この中にも再利用可能な管理ポリシーとインラインポリシーが存在(管理ポリシー推奨)


リソースベースのポリシー

S3などのリソースにアタッチする


セッションポリシー

一時的にセッション単位でアクセスを許可するポリシー
AssumeRoleなどのAPIを利用する




ポリシー評価について

以下の順番で評価される



画像引用元: 【入門編】AWSにおけるアクセスポリシーの評価ロジックを整理してみる




明示的な拒否があれば、その拒否設定が適用される

拒否設定の後に、明示的な許可設定があったとしても、拒否設定が優先的に適用される


明示的な許可があれば許可となるが、なかった場合は暗黙的に拒否される



4.ネットワーク設計
オンプレミスとの比較

オンプレミスと比較すると、AWSにおけるネットワーク設計はある程度ざっくりでOK

名前解決

オンプレミス: 内部DNSを立てるか各サーバーのhostsファイルを利用して名前解決を行う
AWS: 自動でパブリックのDNS名が割り当てられ、マネージドのDNSで名前解決を行う


時刻同期

オンプレミス: システム内の時刻が同期するように同一のNTPサーバーを割り当てる
AWS: AmazonTimeSyncServiceで同期する(インターネット接続不要)

マネージドNTP
VPCで実行されているすべてのインスタンスの 169.254.169.123 IPアドレスで NTP を介して利用できる
最新バージョンのAmazonLinux2とAmazonLinuxAMIはデフォルトでAmazonTimeSyncServiceと同期してくれている

LambdaやECS on Fargate等のマネージドサービスではAWS側で時刻同期されているはずとのこと
AWSマネージドサービスの時刻同期はAWS側で行われているのか | AWS re:Post









VPCとサブネット

VPCはリージョンごとのサービスなので、リージョンを跨ぐことはできない
サブネットではいくつかのIPアドレスがAWSの予約枠として確保されている

ネットワークアドレス (最初のIPアドレス)

例: 10.0.0.0/24サブネットの場合、10.0.0.0がこのアドレスです。
役割: ネットワーク自体を表すためのアドレスであり、ルーティングやネットワーク構成で使用されます。


VPCルーター (2番目のIPアドレス)

例: 10.0.0.1がこのアドレスとなります（サブネットによって異なる場合もあり）。
役割: サブネット内での通信を管理する仮想ルーターです。インスタンス間の通信やインターネットゲートウェイ、VPN接続の経路制御など、サブネット内のルーティングに使用されます。


DNSサーバー (3番目のIPアドレス)

例: 10.0.0.2です。
役割: AWSが提供するDNSリゾルバーのIPアドレスです。VPC内のインスタンスがDNSクエリを行う際に使用します。独自のカスタムDNS設定を行わない限り、このアドレスがデフォルトでDNSリゾルバーとして機能します。


将来の用途のために予約されたアドレス (4番目のIPアドレス)

役割: 現時点で特定の用途が明確には指定されていませんが、AWSが今後の機能拡張や内部用途のために予約しています。


ブロードキャストアドレス (最後のIPアドレス)

例: 10.0.0.255/24サブネットの場合、10.0.0.255がこのアドレスです。
役割: ブロードキャスト通信のために予約されていますが、AWSのVPCではブロードキャスト通信はサポートされていないため、実際に使用することはありません。





セキュリティグループ・ネットワークACL・AWS Network Firewall

AWS Network Firewallは有料なのであまり使われない
セキュリティグループ(SG)→ネットワークACLと、フィルタの範囲を狭めて、シンプルな構成・運用にする
SGは、同一SGに所属しているノード同士の通信でも明示的に許可する必要がある

ルートテーブル

ルートテーブルは複数のサブネットで共有可能
サブネット作成時にルートテーブルも作成され、追加の設定なくVPC内の通信は可能

デフォルトで、VPC内の全てのサブネットに向けたローカルルートが設定されているため
ということは、同じVPC内のサブネットに存在するリソース間で通信を拒否したい場合は、セキュリティグループで設定する必要がある



VPCエンドポイント

異なるVPCやリージョンに配置されたAWSサービスへインターネットを経由せずに接続するサービス
ゲートウェイエンドポイント

ルートテーブルでAWSサービスへのルートを指定
費用かからない


インターフェイスエンドポイント

VPCのプライベートIPアドレスを使用してアクセスする
ENIとしてVPC内に配置され、それがサービスに接続するためのエンドポイントとして動作する
処理するデータ量に応じて課金される


例えばS3は、どちらでも接続可能だが、インターフェイスエンドポイントの方がセキュリティグループでトラフィックを制御できるため、セキュアである

VPC内のリソースがエンドポイントに対して、どのように通信できるかを詳細に制御ができるため、という意味(IPやプロトコル等の制限が可能)



VPCフローログ

VPC内のネットワークインターフェースに流れる情報をキャプチャし、ログに記録する
監査に必要なログを出力したり、通信がうまく通らない場合はトラブルシューティングとして出力したり
フローログは以下の3つの項目を指定する

フローログを取得するリソース(VPC/サブネット/ENIをもつELBやNATGateway等)
どんなトラフィックをキャプチャするか(許可、拒否、全て)
フローログの出力先(CloudWatch Logs/S3)



AWSにセキュアに接続する

AWS Client VPN
サイト間VPN
Direct Connect

5.コンピューティング
Lambda

イベント駆動型のアプリケーションで使いやすい
コールドスタートにかかる時間を短くする方法

VPC内にアクセスしない(ENI作成に10〜30秒かかるため)

VPC Lambdaと呼ばれてるやつ
Lambdaをパブリックサブネットに配置するとENIが作成されアタッチされる
そのENIに対し、パブリックIPを付与(アドレス関連付け)してやれば、Lambdaからアウトバウンドの通信ができるらしい


メモリ増やす(メモリ量に比例してCPUも増加する)
コード量を短くする

関数の初期化や依存解決の速度の向上が見込まれるため





Lambdaのセキュリティ

IAMを最小限にする

特定の条件下で特定のリソースに対して実行できるアクションのみ定義する
基本的には複数のLambda関数でIAMロールで共有しない



Lambdaの監視

Lambda関数をデプロイすると自動でCloudWatch Logsと連携する＋レイテンシやエラー率などのメトリクスも自動で発行する

エラーを検知できるようにアラートを設定しておくと良い
特にDuration(所要時間)やThrottles(同時実行上限を超えて制限した数)は、エラーが発生する前に適切検知できるようにしておく



EC2

インスタンスタイプの書式

Amazon EC2 インスタンスタイプの命名規則 - Amazon EC2
オプション

コンピューティング最適化: CPU大きめ
メモリ最適化: メモリ大きめ





AMI

インスタンス起動するのに必要なOSやボリューム・アプリケーションを含むテンプレート
OSのライセンス費用はEC2の利用料金に含まれている(オンプレと異なる点であり、メリットである)

インスタンスの費用削減

リザーブドインスタンス

時間単位の費用を削減できる
1年や3年の長期使用を約束する
インスタンスクラスの変更しない場合、または負荷増加の際にオンデマンドインスタンスやスポットインスタンスで対応できる場合に検討する
実際の使用有無に関わらず、購入した条件に応じた期間の費用が発生する


SavingsPlans

これも1年や3年の長期使用を約束する
リザーブドインスタンスとの違いは、LambdaやFargateでも使用可能である点、インスタンスファミリーやプラットフォームなどを指定しなくて良い

逆にRDSやElasiCacheでは使用できないので注意


3種類がある
インスタンスタイプや構成を柔軟に変更する予定がある場合は、SavingsPlansを検討する


スポットインスタンス

AWSクラウド内の使用されていないEC2キャパシティを活用し、中断される可能性がある
なので、本番環境で常時起動するサーバーではなく、ECS実行環境やCICDのビルド環境、バッチに適用する
本番環境で適用する場合は、AutoScalingグループでオンデマンドインスタンスとスポットインスタンスの割合を指定する等して、中断が影響しないようにする

中断の2分前にAWSから警告が来るので、アプリケーションの安全な停止や、ログの退避などは自動で対応できるように実装する
インスタンスメタデータで中断対象か確認できる

インスタンスメタデータを取得できるAPIがあるっぽい
そこを定期的に叩くことで確認







T系インスタンスの注意点

汎用のT系はM系よりも安価でありよく選定されるが、バーストパフォーマンスインスタンスであることは十分に理解が必要
バーストパフォーマンスインスタンスとは

ベースラインと呼ばれるCPU使用率がある
そのベースラインに対して、下回る間はクレジットを獲得し、超える間は消費する

1CPUクレジット=1vCPU×100%使用率×1分
つまり、1vCPUを50%使用率で2分使用すると、1クレジット消費するということ


24時間の間で、獲得したクレジットよりも消費するクレジットが多い場合に、その分のvCPU費用が発生する
T系インスタンスの各タイプで、1時間あたりに受け取るクレジットや蓄積可能なクレジット、ベースライン使用率は決められている


CPUクレジットの消費タイプには以下の2種類がある

Standard: 残高が0になると、ベースライン使用率以下でのみ使用可能となる
Unlimited: Standardのような制約はない代わりに、CPUクレジットが0になった後は、vCPU時間ごとに均一追加料金が発生する（他のインスタンスタイプの利用料金を超える可能性がある）


重要なのは、CPU使用率を監視すること

CloudWatchメトリクスで参照可能
バーストインスタンスの CPU クレジットをモニタリングする - Amazon Elastic Compute Cloud


参考: バーストパフォーマンス(T系)インスタンスの特徴を理解して上手に利用しよう | AWS Startup ブログ

コンテナ

仮想化とコンテナの違い

ゲストOSの有無が大きな違い
仮想化はホストOSを介して、ハードウェアを制御するため、オーバーヘッドが大きい
コンテナは、アプリケーションの動作環境を隔離していて、カーネルはホストOSに依存するため、仮想化のように複数の異なるOSを稼働させることはできないが、逆に言えばOSがない分起動が早く、使用するリソースも少なくて済む



コンテナとEC2の違い

EC2上でコンテナを実行するのと、ECSやEKSなどのオーケストレーションツールを使用するのとでどのような違いがあるのかという問いと同義
EC2上で動かした場合、デプロイする時は、EC2アプリケーションを更新→AMIを取得→AutoScaling対象のAMIを変更するという、とても面倒な手作業が発生する

逆にロールバックの作業も面倒..
加えて、OS更新等の手作業も発生する


一方、ECSの場合は、コンテナやOSの障害や更新をAWS側が管理してくれる

CI/CDパイプラインを構築すれば、アプリケーション変更から適用まで迅速に行える
コンテナがプロセス落ちを管理し、再度デプロイしてくれる(Serviceがやっていることかな？)



コンテナを構成するサービスの特徴

複数の環境を有するシステム

再現性が高い特徴を活かせる


更新頻度が高いシステム
アクセス増減の発生が高いシステム
もはやこのご時世的にはあえてEC2を選択するケースはないのではと思う

コンテナサービスを作るときに気をつけること

障害発生することを前提とする

プロセスが落ちても、すぐに起動できるように
ECS Serviceを使えという話だと思う


環境差異は変数化する
ログ出力を1本化する

コンテナは実行環境であるホストOS上でプロセスとして動作し、他のプロセスから隔離されている
コンテナ内部でアプリケーションログを吐いても、プロセス停止した際などにログが残らなくなってしまう
ホストOSか別の領域に出力するように設定する

ちょっと調べた感じ、タスク定義でログドライバにawslogsを設定し、ロググループなども設定すれば、1つのロググループに出力されるようになるっぽい




1コンテナ1プロセスとする

1つのコンテナに複数のプロセスを稼働させることも可能だが、制御が難しいため



Amazon ECS

ECSの構成要素

クラスター：実行環境
タスク定義：指定のコンテナを動かす
サービス：全体の構成やデプロイ方法を設定


タスク定義

主な設定項目

Dockerイメージ
コンテナのCPUとメモリ
データボリューム
IAMロール
コンピューティング環境(EC2 or Fargate)




サービス

主な設定項目

連携するELBを指定
指定したタスク定義のタスク数
デプロイ方法(Blue/Green,ローリングアップデート)
実行環境(EC2,Fargate)で待ち受けるポートや、コンテナ側で待ち受けるポートも指定する


サービスはなくても動くけど、AutoScalingの実装等に必要


クラスター

主な設定項目

コンテナ実行環境のネットワークを指定
起動するインスタンスタイプやAMI、その数を指定


Fargateの場合は、ネットワーク作成とクラスター名のみを設定する



タスク定義の更新

コンテナイメージにつけるタグ名はlatestにするとタスク定義の修正が不要になる一方、コンテナイメージのバージョンがわからないのがで名rっと
デプロイ方法「ローリングアップデート」と「Blue/Greenデプロイメント」がある

ローリングアップデートの例

DesiredCountを4に、minimumHealthyPercentを0.5に設定した場合、4 * 0.5の2インスタンスが更新されたタスク定義を元に作成される


Blue/Greenデプロイメントの例

タスク定義を更新すると、新たにGreen環境が作成あれ、疎通に問題がなければ、LBのレイヤーで切り替えを行う（だからLBが必須）





データボリューム

ログや共通のデータはコンテナ外に領域を確保する
ECSで選択可能なデータボリュームは以下になる

EFS
FSx for Windows File Sever
Dockerボリューム

EC2のみ利用可能


バインドマウント

ホスト上のファイルやディレクトリをコンテナからマウントする


Fargate タスクエフェメラルストレージ

エフェメラルストレージ=一時的なストレージ
プロビジョニング時にECSタスクが受け取るもの
これらをマウントし、タスク定義内でvolumes、mountPointsおよびvolumesFromパラメータを使用しているコンテナ間で共有することが可能


Amazon ECS タスクのストレージオプション - Amazon Elastic Container Service



6.データベース
データベースの選択

どんな用途なのかと移行か新規なのか、複数の観点からの検討が必要

RDS

EC2同様に仮想サーバー上で実行される
EC2でもDBの構築は可能だが、RDSと異なり自動スケーリングや高可用性、OS・DBソフトウェアのパッチ適用などはユーザーが設計・実装・運用する必要がある

逆に、その辺りを自前で管理したい・RDSでサポートされていないパラメータをチューニングしたい・開発環境などで費用削減をしたいという場合はEC2でのDB構築が選択肢になる


リクエストのI/Oサイズやアクセスパターンにより、パフォーマンスが大きく変わる

シーケンシャルなアクセスでは、最大I/Oサイズに達するまで、単一のI/O操作に含められる
ランダムなアクセスでは、最大I/Oサイズに達しない小さいサイズでも、IOPSに個別カウントする

つまりランダムアクセスの場合はIOPSの消費が多いので、それを考慮してインスタンスクラスなどを決めようという話




パフォーマンスは、DBで最も重要な非機能要件になるので、机上確認だけでなく、実際に検証したり、CloudWatchメトリクスで確認したりして、ストレージタイプを選ぶと良い

マルチAZ構成

サポートされている機能は、リージョンやデータベースエンジンによって異なる
マルチAZデプロイすると、Read/WriteできるプライマリDBインスタンスとフェイルオーバー先となるスタンバイレプリカ(読み取り書き込みはできない)が別AZへデプロイされる
スタンバイレプリカは通常時は動作せず、プライマリに障害が発生した時にレプリカが昇格する
フェイルオーバーは60〜120秒

マルチAZ DBクラスタ

1つの読み取り/書き込みインスタンスと、2つ以上の読み取り専用スタンバイDBインスタンスで構成
読み取り/書き込みインスタンスに障害が発生したら、読み取り専用スタンバイDBインスタンスが昇格
書き込み専用DBインスタンス接続するクラスタエンドポイントと、読み取り専用に接続するリーダーエンドポイントがある

エンドポイントは、クラスタ内の対象インスタンスに接続できない場合に自動的に接続先を変更する


フェイルオーバーは35秒未満

RDS Proxy

RDSでは、アプリケーションからの接続を処理する際にメモリやCPUを消費する
頻繁に短時間でDB接続を繰り返すアプリケーションでは、DBの処理負荷を下げるためRDS Proxyを導入すると良い
RDSの最大接続数はパラメータグループのmax_connectionsで定義されており、手動変更は推奨されていない
そのため、同時接続数が上限に達しそうな場合は、上位のインスタンスクラスorRDS Proxyを検討する
RDS Proxyの特徴

フルマネージドサービス
アプリケーションとRDSの間に設置
VPC内の異なるAZにある2サブネットを選択して作成
RDS Proxyを間に配置することによる遅延は5ミリ秒程度
RDSのインスタンスレベルを上げずに済むので、コストや運用工数を抑えられる


RDS Proxyを採用するメリット

フェイルオーバーにかかる時間を短縮できる

数秒レベルでフェイルオーバーが完了する
RDS Proxyがない場合は、スタンバイの昇格とクラスタエンドポイントの更新後にアプリケーションが再接続するのに比べて、RDS Proxyがある場合はアプリケーションからの接続をプールし、RDS ProxyからRDSへの接続は処理中であったものを除いて保持・再利用するため

この箇所ちょっと引っかかったので調べてみた。
RDS Proxyの使用有無で、RDS側のフェイルオーバーにかかる時間は変わらないと思う
ただし、アプリケーションの視点で見た時に、RDS Proxyへのコネクションを再確立する必要がない

RDS ProxyーRDS間のコネクションの再確立のみで不要
なので、アプリケーション側からすると、再接続するオーバーヘッドがかからないので、フェイルオーバーにかかる時間を短縮できると表現されていると思われる(RDS側のDNS更新も待つ必要もない)








RDS Proxyを利用する際の注意点

IPアドレスの枯渇

IPアドレスを消費するのは、RDS Proxy-RDSの接続

RDS Proxy-RDSは、同じVPC内で通信するため、プライベートIPアドレスを使用する
RDS Proxyは、接続先RDSのインスタンスクラスと台数に応じて自動的に容量を増減し、場合によっては多くのIPアドレスを利用する


IPアドレスが枯渇するとうまくスケールができず、クエリ遅延やコネクション失敗が発生することがある
インスタンスクラスごとに確保すべき最小IPアドレス数が定められている
回避する方法としては、サブネットのIPアドレス範囲を広くすることが推奨される


セッション固定（ピン止め）による影響

特定のトランザクションやセッションが接続プール内の特定のバックエンド(DB)接続に固定される状態を指す
この状態になってしまうと、通常共有可能な接続が他のリクエストに再利用されなくなり、DBへの同時接続数が増え続け、最終的にはDB接続が行えなくなる可能性がある
CloudWatchメトリクスの「DatabaseConnectionsCurrentlySessionPinned」を監視すると良い
ピン留め発生が想定されるケース


ステートフルなリクエスト
ユーザーセッションに依存する処理が行われる場合、同じバックエンド接続を使用し続ける必要があります。
例: 一時テーブルやユーザー固有の設定を使用したクエリ。
特定のSQL機能の使用
以下のような機能を使用すると、接続が固定されることがあります：
セッション変数: SET SESSION を使用してカスタム設定を適用。
一時テーブル: セッション固有のデータを保持。
ユーザー定義関数（UDF）: セッションスコープで動作する関数。
ロック操作: セッションスコープのロック（例: GET_LOCK()）。
トランザクション管理
トランザクション内で複数のクエリが実行される場合、トランザクションの一貫性を保つため、同じ接続を使い続ける必要があります。


逆に、接続と破棄を繰り返すLambda関数等の使用であれば、この問題は発生しないも？




目を通した導入事例とか

【AWS】RDSのインスタンスタイプを上げたらRDS ProxyのENIがDBサブネットのIPを食い尽くした話 - BFT名古屋 TECH BLOG
Amazon RDS Proxy が BASE にもたらした期待以上の導入メリット - BASEプロダクトチームブログ



Aurora

Auroraを利用すると、簡単にレプリケーションやクラスタの設定が可能
Auroraの構成

1つ以上のインスタンスと1つのクラスタボリューム
インスタンスには読み取り/書き込みを行うプライマリと読み取りのみをサポートするレプリカ


RDSでAurora以外のエンジンを使用している場合との比較

インスタンスとストレージが分離している点が大きく異なる
AuroraはRDSにまたがる分散ストレージにより、バックアップや復旧がRDSより高速
RDSより割高なイメージがあるが、構成と運用次第でRDSよりも費用を抑えられる


Auroraのバージョン

MySQLやPostgreSQLのコミュニティバージョンに対応した独自のAuroraバージョン
major.minor.patchの構成
マイナーとパッチは自動アップグレードも可能
アップグレードにはDBの停止を伴うことを想定する
コミュニティサポート期限が切れると現行以降のメジャーバージョンに自動アップグレードされてしまうので注意


レプリケーションとフェイルオーバー

レプリケーション

プライマリインスタンスに書き込みが発生すると、通常100ミリ秒以下の遅延でレプリカ側でも書き込まれたデータを参照可能になる
レプリカは最大15台をクラスタに組み込めるので、読み込み負荷の高いアプリケーションはAuroraを検討すると良い
複数リージョンにまたがるグローバルデータベースでも、レプリケーションが1秒以内
レプリケーション先にDBインスタンスは不要(クラスタボリュームがあるため)
DR対策としてもAuroraは優位性がある


フェイルオーバー

プライマリに障害が発生すると、レプリカが昇格する
フェイルオーバーの開始から終了までは通常30秒以内
なおシングルインスタンス構成の場合は、障害が発生したAZにDBインスタンスを作成しようとする




スケーリング

最大128TiBまで容量を自動拡張する

拡張時にパフォーマンス影響なし


手動でインスタンスクラスを変更すると、容量だけでなくCPUやメモリもスペックアップ可能だが、サービス停止が発生するので注意
無停止でインスタンスクラスが自動スケールするAuroraServerlessもある



AuroraServerless

ユーザーが事前に設定した範囲で自動スケールアップ

DynamoDB

フルマネージド型のNoSQLデータベース
DynamoDBの特徴

高信頼性

リージョン内3AZに同期されるので、高い可用性と耐障害性


高スループット

テーブルごとのRead/Writeそれぞれにスループットキャパシティを柔軟に割り当てられる


サーバーレス

VPCの設計が不要
事前に設定するキャパシティに基づいて自動スケーリングできる
容量無制限
データのパーティショニングも自動で行われる




整合性モデル

DynamoDBはデフォルトで「結果整合性のある読み込み」を行う
DynamoDBでは少なくとも2AZで書き込み完了後、およそ1秒以内にAck(確認応答)を返す
書き込み後1秒の間にアクセスした際のデータ不整合を許容できる場合はデフォルトのままで良い
「強力な整合性のある読み込み」をするには、DynamoDBへのリクエスト時に「ConsistentReadパラメータ」を付与する(追加でコストがかかる点に注意)
トランザクション読み込み/書き込みAPIもある


モード

実際に使用した分にかかる「オンデマンドキャパシティ」と事前に予測可能な場合に有用な「プロビジョンドキャパシティ」がある
単位や請求内容が異なるので注意
インスタンスを用いるRDSよりは、多くの場合で費用を削減できる



DynamoDBの設計

以下のプライマリキーが必要

パーティションキー(必須)

テーブルのアイテムはパーティションという領域に配置される
このパーティションキーの値を元に配置先のパーティションが決定される


ソートキー

パーティションキーが同一であるアイテムに対し、並び順を保証するために使用される




この辺り理解甘いから公式ドキュメントを読み込みたい

DynamoDB を使用した設計とアーキテクチャの設計に関するベストプラクティス - Amazon DynamoDB



7.ストレージ

大量のデータを保存したい場合：S3
Lambdaや複数のLinux系EC2インスタンスからデータを利用したい場合：EFS

EBS

オンプレミスサーバに例えると、搭載する物理ディスクにあたる
費用は、プロビジョニングされた容量に対して発生するので、インスタンスが停止していても課金されるので注意

S3

オブジェクトストレージ
インターネットからアクセスを受け付けるS3には適切なセキュリティ対策が必要

セキュリティ

データ保護

2023年1月より、S3に追加される全てのオブジェクトにはSSE-S3での暗号化が自動適用されるようになった

監査や鍵の一元管理が不要であれば、追加費用かからず管理の手間もないSSE-S3を利用すると良い




アクセスポリシーの全体像

リソースベースのポリシーとユーザーベースのポリシーを利用して、リソースへのアクセスを管理できる
リソースベースのポリシー

バケットポリシー
バケットアクセスコントロールリスト(ACL)
オブジェクトACL

バケットアクセスコントロールリスト(ACL)とオブジェクトACLは、使用する必要がないケースが多い


バケットポリシーとユーザーポリシーで同じ対象に異なるアクセス制限(拒否と許可など)がされている場合は、より厳しい制限が適用されるので注意





8.アプリーション統合
Amazon API Gateway

2種類のAPIが用意されており、RestfulAPIとチャットなどのリアルタイム双方向通信を行うステートフルなWebSocketAPIがある
RestfulAPIには、WAF統合やクライアントごとのスロットリングなどの多機能なREST APIと、機能を絞り費用を抑えたHTTP APIが存在する

以下を参考に、要件に対して必要な機能を検討してどちらかを選ぶようにする
REST API と HTTP API のどちらかを選択する - Amazon API Gateway


マッピングテンプレートを使用すると、リクエストやレスポンスの整形が可能
トークンバケットアルゴリズムを使用したスロットリング
公式が出しているベストプラクティスもある

Amazon API Gateway のセキュリティのベストプラクティス - Amazon API Gateway
書かれているのは、最小権限やアクセスログの記録・アラート設定、CloudTrailの有効化など



EventBridge

EventBridgeの特徴

EventBridgeは、様々なAWS内やSaaSアプリケーションのイベントを受信・処理し、ターゲットであるAWSサービスへ渡すイベント駆動型のマネージドサービス
スケジュールをトリガーとしたルール実行も可能


イベントバスの種類

イベントバスと呼ばれるパイプラインでイベントを受信する


アクセス制御

デフォルトのイベントバスは、操作しているAWSアカウントからのイベントを許可する
各サービスのアクセス制御は、ターゲット側のポリシーで許可するorEventBridgeのルールのIAMロールでポリシーを設定する



EventBridgeのルールと入力トランスフォーマー

ターゲットは5つまで指定できる
並列実行が可能
DatadogやNewRelic等のサードパーティツールにも統合可能
入力トランスフォーマーでターゲットに渡す情報を編集できる

SNSやSQSとの使い分け

同じイベント駆動型アプリケーションであるSNSやSQSとの使い分けについて
SNSやSQSを使用するケースは以下の通り

低レイテンシが求められる
多数のエンドポイントが必要
対人メッセージングに利用(SNSを使うべし)
順序保証が必要


SNS

プッシュ方式

プロデューサー == ブローカー == コンシューマーという構成でブローカーからコンシューマーへジョブがプッシュされる




SQS

プル方式

コンシューマー側が能動的にブローカー(キュー)からメッセージを取得する


P2P方式

プロデューサーとコンシューマが1：1で連携する方式




EventBridge

スケジュール実行・SaaSサービスとの連携・メッセージの加工はEventBridgeにしかない機能


要件に合わせて使い分けることが大切

9.可用性

疎結合化の文脈で、システムのつなぎ目に拡張性・耐障害性に優れた機能を配置すると良い

例えば、ロードバランサやDNS・メッセージキュー
つなぎ目にはできるだけ非同期処理を行うコンポーネントを配置する

EventBridge,SQS,Kinesisシリーズ群,Step Functions
SQS(スタンダードキュー)は、1秒間にほぼ無限にAPIコールを受け付けられるため、可用性は問題にならない


疎結合には、スケールアウトした時に他のコンポーネントへの影響が少ないことや障害発生時の切り分けもしやすいことがメリットになる



SLA

AWSはSLAを満たせなかった場合、サービスクレジットとして還元される

キャッシュバックではなく、今後請求される支払いに対して利用できるもの
契約者は、いくつかの情報を揃えてAWSに提出する必要がある(自動で適用されるものではない点に注意)



10.セキュリティ

クラウド事業者の選定

ISMAPのクラウドサービスリスト: https://www.ismap.go.jp/csm?id=cloud_service_list


Amazon Inspector

CIS Benchmarksに沿って、EC2やECRのOSやミドルウェア設定を確認・可視化できる
ベストプラクティスに準拠していない場合はレポート出力される


リスク検出を支援するAWSサービス

無料で手軽に：TrustedAdvisor, IAM Access Analyzer
ルールをカスタマイズもできる：AWS Config
それほど料金かからない：SecurityHub



11.ジョブ管理

バッチ処理を行うシステムをジョブ管理システムという
AWSのジョブ実行に関連するサービスはいくつかある

15分以内ならLambdaで実装するのが良い

ECS Scheduled TaskやBatchと比較して安価


ECS Scheduled Taskは、EventBridgeでのトリガを元にECSを実行するというもの



Batch

長時間、高負荷な処理はBatchでの実装を検討すると良い

逆に短時間で終わるものや即時実行が必要なジョブには向いていない


Batchはコンテナ環境を使って処理を行うので、注意すべきポイントがいくつかある
Batchの特徴

コンポーネント

BatchのジョブはECSやEKSのコンテナ上で実行される


スポットインスタンスの活用

コストを安くできる反面、発生しうる中断に対してのケアが必要

冪等性を考慮したジョブ設計にし、リトライできるようにする


ジョブを短時間で終わるように設計する

定期的に結果をS3やEFSに出力するチェックポイント方式にする


ジョブの再試行回数を設定する
実際の設計例では、

優先度の高いジョブはオンデマンドに処理させて、そうではないジョブはスポットインスタンスにするとか
スポットインスタンスで失敗したジョブをSNSに通知→Lambdaを経由して、オンデマンド用キュー→オンデマンドインスタンスでジョブを再実行とか方法がある







Step Functions

AWSサービスやAPIを組み合わせ、ワークフローを視覚的に作成・実行できるサービス
ワークフロータイプ

StandardとExpressがある

実行頻度の高い処理を短時間で処理させる場合はExpressを選択する




料金

Lambdaよりは割高
状態遷移の回数で課金される
EventBridgeーLambdaの構成であれば無料利用枠内に収まるなんてこともあるので、見積もりを慎重に行う


StepFunctionsはデバッグがしやすい

ステートごとに入出力やイベントが見やすかったり
ステートごとにログが時系列でわかりやすく並んでいたりする



12.バックアップ

オンプレでもクラウドでもバックアップの重要性は変わらない

AWSのバックアップ

EC2

Amazon Data Lifecycle Managerで定期的にスナップショットを取得


RDS

自動バックアップの有効化、手動バックアップの実行


S3

バージョニング有効、ライフサイクル管理



AWS Backup

フルマネージドなバックアップサービス
最低料金や初期費用が発生しない
バックアップの自動化や保存期間が過ぎたデータなどバックアップに関する一元管理が可能
対象は、AWSリソースのみ
概要

バックアッププランを作成し、ルールで指定したスケジュールでバックアップを行う
バックアッププランで、AWSリソースを指定する


想定外にかかる費用

簡単に設定できてしまう反面、想定より費用がかかるケースがある
バックアップを一定期間運用した後は、定期的に適切な範囲に収まっているかを確認した方が良い



13.監視

RDS

スロークエリなどを出力したい場合は、パラメータグループのlog_outputをFILEにする


VPC

VPC内のトラフィック情報をCloudWatch Logsに出力するには、VPCフローログが必要


">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "AWS設計スキルアップガイド",
      "item": "http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "AWS設計スキルアップガイド",
  "name": "AWS設計スキルアップガイド",
  "description": "AWS設計スキルアップガイド ――サービスの選定から、システム構成、運用・移行の設計まで：書籍案内｜技術評論社\n2.クラウドのインフラ設計 クラウドで考えるセキュリティ 万が一の事故や障害が発生したときに「責任分界点」を定義しておくことで、責任の所在を明らかにできる AWSでの「責任共有モデル」では、それぞれの責任について以下のように定義されている AWS: サービスを提供するためのインフラストラクチャ 利用者: 選択したAWSサービスごとの適切なセキュリティを実装し、システムを保護する AWS SecurityHubを使用することで、横断的にセキュリティの問題を検知することができる 3.システムの構成 AWSでシステムを構築する時にまず考えるべきは「アカウントをどの単位で発行するか」 AWSアカウントの運用例 単一のアカウントで運用するケース 注意ポイント VPCをプロジェクトや環境ごとに分離する プロジェクトや環境がわかるようにタグを活用する VPCに関連のないサービスを使用する場合、IAMで権限を設定する 管理する請求先が1つになるメリットはあるが、誤操作等によるミスや事故リスクが上がるので、できればアカウントは分けて運用するのが良い 複数のアカウントで運用するケース アカウントの統制を考慮する AWS ControlTowerで一元管理 Organizationで多数のAWSアカウントを管理 ログインIDの統合を検討する(1つのユーザーアカウントで各AWSアカウントにログインできるようにする) 各環境のIAMロールで行う方法 AWS IAM Identity Center (SSO)を活用する方法 サードパーティIDaaSを活用する方法 (追記) AWS ControlTowerを利用すると、マルチアカウント環境を一元的に整備してくれる 参考: スタートアップにおけるマルチアカウントの考え方と AWS Control Tower のすゝめ | AWS Startup ブログ IAM 認証はIAMユーザー、認可はIAMポリシーで設定する 通常、ポリシーはグループもしくはロールに付与する なぜなら、ユーザーにポリシーをアタッチすると、運用工数がかかる IAMポリシー設計 デフォルトはすべて拒否なので、明示的に許可していく どのリソース(Resource)に対して、どんな条件で(Conditions)、どんな動作(Action)を、許可/拒否する(Effect)かをJSONもしくはGUIで記述(選択)する ポリシーはいくつか種類がある(使用頻度が高いものを抜粋) アイデンティティベースのポリシー アイデンティティ(ユーザー、グループ、ロール)にアタッチする この中にも再利用可能な管理ポリシーとインラインポリシーが存在(管理ポリシー推奨) リソースベースのポリシー S3などのリソースにアタッチする セッションポリシー 一時的にセッション単位でアクセスを許可するポリシー AssumeRoleなどのAPIを利用する ポリシー評価について 以下の順番で評価される 画像引用元: 【入門編】AWSにおけるアクセスポリシーの評価ロジックを整理してみる 明示的な拒否があれば、その拒否設定が適用される 拒否設定の後に、明示的な許可設定があったとしても、拒否設定が優先的に適用される 明示的な許可があれば許可となるが、なかった場合は暗黙的に拒否される 4.ネットワーク設計 オンプレミスとの比較 オンプレミスと比較すると、AWSにおけるネットワーク設計はある程度ざっくりでOK 名前解決 オンプレミス: 内部DNSを立てるか各サーバーのhostsファイルを利用して名前解決を行う AWS: 自動でパブリックのDNS名が割り当てられ、マネージドのDNSで名前解決を行う 時刻同期 オンプレミス: システム内の時刻が同期するように同一のNTPサーバーを割り当てる AWS: AmazonTimeSyncServiceで同期する(インターネット接続不要) マネージドNTP VPCで実行されているすべてのインスタンスの 169.254.169.123 IPアドレスで NTP を介して利用できる 最新バージョンのAmazonLinux2とAmazonLinuxAMIはデフォルトでAmazonTimeSyncServiceと同期してくれている LambdaやECS on Fargate等のマネージドサービスではAWS側で時刻同期されているはずとのこと AWSマネージドサービスの時刻同期はAWS側で行われているのか | AWS re:Post VPCとサブネット VPCはリージョンごとのサービスなので、リージョンを跨ぐことはできない サブネットではいくつかのIPアドレスがAWSの予約枠として確保されている ネットワークアドレス (最初のIPアドレス) 例: 10.0.0.0/24サブネットの場合、10.0.0.0がこのアドレスです。 役割: ネットワーク自体を表すためのアドレスであり、ルーティングやネットワーク構成で使用されます。 VPCルーター (2番目のIPアドレス) 例: 10.0.0.1がこのアドレスとなります（サブネットによって異なる場合もあり）。 役割: サブネット内での通信を管理する仮想ルーターです。インスタンス間の通信やインターネットゲートウェイ、VPN接続の経路制御など、サブネット内のルーティングに使用されます。 DNSサーバー (3番目のIPアドレス) 例: 10.0.0.2です。 役割: AWSが提供するDNSリゾルバーのIPアドレスです。VPC内のインスタンスがDNSクエリを行う際に使用します。独自のカスタムDNS設定を行わない限り、このアドレスがデフォルトでDNSリゾルバーとして機能します。 将来の用途のために予約されたアドレス (4番目のIPアドレス) 役割: 現時点で特定の用途が明確には指定されていませんが、AWSが今後の機能拡張や内部用途のために予約しています。 ブロードキャストアドレス (最後のIPアドレス) 例: 10.0.0.255/24サブネットの場合、10.0.0.255がこのアドレスです。 役割: ブロードキャスト通信のために予約されていますが、AWSのVPCではブロードキャスト通信はサポートされていないため、実際に使用することはありません。 セキュリティグループ・ネットワークACL・AWS Network Firewall AWS Network Firewallは有料なのであまり使われない セキュリティグループ(SG)→ネットワークACLと、フィルタの範囲を狭めて、シンプルな構成・運用にする SGは、同一SGに所属しているノード同士の通信でも明示的に許可する必要がある ルートテーブル ルートテーブルは複数のサブネットで共有可能 サブネット作成時にルートテーブルも作成され、追加の設定なくVPC内の通信は可能 デフォルトで、VPC内の全てのサブネットに向けたローカルルートが設定されているため ということは、同じVPC内のサブネットに存在するリソース間で通信を拒否したい場合は、セキュリティグループで設定する必要がある VPCエンドポイント 異なるVPCやリージョンに配置されたAWSサービスへインターネットを経由せずに接続するサービス ゲートウェイエンドポイント ルートテーブルでAWSサービスへのルートを指定 費用かからない インターフェイスエンドポイント VPCのプライベートIPアドレスを使用してアクセスする ENIとしてVPC内に配置され、それがサービスに接続するためのエンドポイントとして動作する 処理するデータ量に応じて課金される 例えばS3は、どちらでも接続可能だが、インターフェイスエンドポイントの方がセキュリティグループでトラフィックを制御できるため、セキュアである VPC内のリソースがエンドポイントに対して、どのように通信できるかを詳細に制御ができるため、という意味(IPやプロトコル等の制限が可能) VPCフローログ VPC内のネットワークインターフェースに流れる情報をキャプチャし、ログに記録する 監査に必要なログを出力したり、通信がうまく通らない場合はトラブルシューティングとして出力したり フローログは以下の3つの項目を指定する フローログを取得するリソース(VPC/サブネット/ENIをもつELBやNATGateway等) どんなトラフィックをキャプチャするか(許可、拒否、全て) フローログの出力先(CloudWatch Logs/S3) AWSにセキュアに接続する AWS Client VPN サイト間VPN Direct Connect 5.コンピューティング Lambda イベント駆動型のアプリケーションで使いやすい コールドスタートにかかる時間を短くする方法 VPC内にアクセスしない(ENI作成に10〜30秒かかるため) VPC Lambdaと呼ばれてるやつ Lambdaをパブリックサブネットに配置するとENIが作成されアタッチされる そのENIに対し、パブリックIPを付与(アドレス関連付け)してやれば、Lambdaからアウトバウンドの通信ができるらしい メモリ増やす(メモリ量に比例してCPUも増加する) コード量を短くする 関数の初期化や依存解決の速度の向上が見込まれるため Lambdaのセキュリティ IAMを最小限にする 特定の条件下で特定のリソースに対して実行できるアクションのみ定義する 基本的には複数のLambda関数でIAMロールで共有しない Lambdaの監視 Lambda関数をデプロイすると自動でCloudWatch Logsと連携する＋レイテンシやエラー率などのメトリクスも自動で発行する エラーを検知できるようにアラートを設定しておくと良い 特にDuration(所要時間)やThrottles(同時実行上限を超えて制限した数)は、エラーが発生する前に適切検知できるようにしておく EC2 インスタンスタイプの書式 Amazon EC2 インスタンスタイプの命名規則 - Amazon EC2 オプション コンピューティング最適化: CPU大きめ メモリ最適化: メモリ大きめ AMI インスタンス起動するのに必要なOSやボリューム・アプリケーションを含むテンプレート OSのライセンス費用はEC2の利用料金に含まれている(オンプレと異なる点であり、メリットである) インスタンスの費用削減 リザーブドインスタンス 時間単位の費用を削減できる 1年や3年の長期使用を約束する インスタンスクラスの変更しない場合、または負荷増加の際にオンデマンドインスタンスやスポットインスタンスで対応できる場合に検討する 実際の使用有無に関わらず、購入した条件に応じた期間の費用が発生する SavingsPlans これも1年や3年の長期使用を約束する リザーブドインスタンスとの違いは、LambdaやFargateでも使用可能である点、インスタンスファミリーやプラットフォームなどを指定しなくて良い 逆にRDSやElasiCacheでは使用できないので注意 3種類がある インスタンスタイプや構成を柔軟に変更する予定がある場合は、SavingsPlansを検討する スポットインスタンス AWSクラウド内の使用されていないEC2キャパシティを活用し、中断される可能性がある なので、本番環境で常時起動するサーバーではなく、ECS実行環境やCICDのビルド環境、バッチに適用する 本番環境で適用する場合は、AutoScalingグループでオンデマンドインスタンスとスポットインスタンスの割合を指定する等して、中断が影響しないようにする 中断の2分前にAWSから警告が来るので、アプリケーションの安全な停止や、ログの退避などは自動で対応できるように実装する インスタンスメタデータで中断対象か確認できる インスタンスメタデータを取得できるAPIがあるっぽい そこを定期的に叩くことで確認 T系インスタンスの注意点 汎用のT系はM系よりも安価でありよく選定されるが、バーストパフォーマンスインスタンスであることは十分に理解が必要 バーストパフォーマンスインスタンスとは ベースラインと呼ばれるCPU使用率がある そのベースラインに対して、下回る間はクレジットを獲得し、超える間は消費する 1CPUクレジット=1vCPU×100%使用率×1分 つまり、1vCPUを50%使用率で2分使用すると、1クレジット消費するということ 24時間の間で、獲得したクレジットよりも消費するクレジットが多い場合に、その分のvCPU費用が発生する T系インスタンスの各タイプで、1時間あたりに受け取るクレジットや蓄積可能なクレジット、ベースライン使用率は決められている CPUクレジットの消費タイプには以下の2種類がある Standard: 残高が0になると、ベースライン使用率以下でのみ使用可能となる Unlimited: Standardのような制約はない代わりに、CPUクレジットが0になった後は、vCPU時間ごとに均一追加料金が発生する（他のインスタンスタイプの利用料金を超える可能性がある） 重要なのは、CPU使用率を監視すること CloudWatchメトリクスで参照可能 バーストインスタンスの CPU クレジットをモニタリングする - Amazon Elastic Compute Cloud 参考: バーストパフォーマンス(T系)インスタンスの特徴を理解して上手に利用しよう | AWS Startup ブログ コンテナ 仮想化とコンテナの違い ゲストOSの有無が大きな違い 仮想化はホストOSを介して、ハードウェアを制御するため、オーバーヘッドが大きい コンテナは、アプリケーションの動作環境を隔離していて、カーネルはホストOSに依存するため、仮想化のように複数の異なるOSを稼働させることはできないが、逆に言えばOSがない分起動が早く、使用するリソースも少なくて済む コンテナとEC2の違い EC2上でコンテナを実行するのと、ECSやEKSなどのオーケストレーションツールを使用するのとでどのような違いがあるのかという問いと同義 EC2上で動かした場合、デプロイする時は、EC2アプリケーションを更新→AMIを取得→AutoScaling対象のAMIを変更するという、とても面倒な手作業が発生する 逆にロールバックの作業も面倒.. 加えて、OS更新等の手作業も発生する 一方、ECSの場合は、コンテナやOSの障害や更新をAWS側が管理してくれる CI/CDパイプラインを構築すれば、アプリケーション変更から適用まで迅速に行える コンテナがプロセス落ちを管理し、再度デプロイしてくれる(Serviceがやっていることかな？) コンテナを構成するサービスの特徴 複数の環境を有するシステム 再現性が高い特徴を活かせる 更新頻度が高いシステム アクセス増減の発生が高いシステム もはやこのご時世的にはあえてEC2を選択するケースはないのではと思う コンテナサービスを作るときに気をつけること 障害発生することを前提とする プロセスが落ちても、すぐに起動できるように ECS Serviceを使えという話だと思う 環境差異は変数化する ログ出力を1本化する コンテナは実行環境であるホストOS上でプロセスとして動作し、他のプロセスから隔離されている コンテナ内部でアプリケーションログを吐いても、プロセス停止した際などにログが残らなくなってしまう ホストOSか別の領域に出力するように設定する ちょっと調べた感じ、タスク定義でログドライバにawslogsを設定し、ロググループなども設定すれば、1つのロググループに出力されるようになるっぽい 1コンテナ1プロセスとする 1つのコンテナに複数のプロセスを稼働させることも可能だが、制御が難しいため Amazon ECS ECSの構成要素 クラスター：実行環境 タスク定義：指定のコンテナを動かす サービス：全体の構成やデプロイ方法を設定 タスク定義 主な設定項目 Dockerイメージ コンテナのCPUとメモリ データボリューム IAMロール コンピューティング環境(EC2 or Fargate) サービス 主な設定項目 連携するELBを指定 指定したタスク定義のタスク数 デプロイ方法(Blue/Green,ローリングアップデート) 実行環境(EC2,Fargate)で待ち受けるポートや、コンテナ側で待ち受けるポートも指定する サービスはなくても動くけど、AutoScalingの実装等に必要 クラスター 主な設定項目 コンテナ実行環境のネットワークを指定 起動するインスタンスタイプやAMI、その数を指定 Fargateの場合は、ネットワーク作成とクラスター名のみを設定する タスク定義の更新 コンテナイメージにつけるタグ名はlatestにするとタスク定義の修正が不要になる一方、コンテナイメージのバージョンがわからないのがで名rっと デプロイ方法「ローリングアップデート」と「Blue/Greenデプロイメント」がある ローリングアップデートの例 DesiredCountを4に、minimumHealthyPercentを0.5に設定した場合、4 * 0.5の2インスタンスが更新されたタスク定義を元に作成される Blue/Greenデプロイメントの例 タスク定義を更新すると、新たにGreen環境が作成あれ、疎通に問題がなければ、LBのレイヤーで切り替えを行う（だからLBが必須） データボリューム ログや共通のデータはコンテナ外に領域を確保する ECSで選択可能なデータボリュームは以下になる EFS FSx for Windows File Sever Dockerボリューム EC2のみ利用可能 バインドマウント ホスト上のファイルやディレクトリをコンテナからマウントする Fargate タスクエフェメラルストレージ エフェメラルストレージ=一時的なストレージ プロビジョニング時にECSタスクが受け取るもの これらをマウントし、タスク定義内でvolumes、mountPointsおよびvolumesFromパラメータを使用しているコンテナ間で共有することが可能 Amazon ECS タスクのストレージオプション - Amazon Elastic Container Service 6.データベース データベースの選択 どんな用途なのかと移行か新規なのか、複数の観点からの検討が必要 RDS EC2同様に仮想サーバー上で実行される EC2でもDBの構築は可能だが、RDSと異なり自動スケーリングや高可用性、OS・DBソフトウェアのパッチ適用などはユーザーが設計・実装・運用する必要がある 逆に、その辺りを自前で管理したい・RDSでサポートされていないパラメータをチューニングしたい・開発環境などで費用削減をしたいという場合はEC2でのDB構築が選択肢になる リクエストのI/Oサイズやアクセスパターンにより、パフォーマンスが大きく変わる シーケンシャルなアクセスでは、最大I/Oサイズに達するまで、単一のI/O操作に含められる ランダムなアクセスでは、最大I/Oサイズに達しない小さいサイズでも、IOPSに個別カウントする つまりランダムアクセスの場合はIOPSの消費が多いので、それを考慮してインスタンスクラスなどを決めようという話 パフォーマンスは、DBで最も重要な非機能要件になるので、机上確認だけでなく、実際に検証したり、CloudWatchメトリクスで確認したりして、ストレージタイプを選ぶと良い マルチAZ構成 サポートされている機能は、リージョンやデータベースエンジンによって異なる マルチAZデプロイすると、Read/WriteできるプライマリDBインスタンスとフェイルオーバー先となるスタンバイレプリカ(読み取り書き込みはできない)が別AZへデプロイされる スタンバイレプリカは通常時は動作せず、プライマリに障害が発生した時にレプリカが昇格する フェイルオーバーは60〜120秒 マルチAZ DBクラスタ 1つの読み取り/書き込みインスタンスと、2つ以上の読み取り専用スタンバイDBインスタンスで構成 読み取り/書き込みインスタンスに障害が発生したら、読み取り専用スタンバイDBインスタンスが昇格 書き込み専用DBインスタンス接続するクラスタエンドポイントと、読み取り専用に接続するリーダーエンドポイントがある エンドポイントは、クラスタ内の対象インスタンスに接続できない場合に自動的に接続先を変更する フェイルオーバーは35秒未満 RDS Proxy RDSでは、アプリケーションからの接続を処理する際にメモリやCPUを消費する 頻繁に短時間でDB接続を繰り返すアプリケーションでは、DBの処理負荷を下げるためRDS Proxyを導入すると良い RDSの最大接続数はパラメータグループのmax_connectionsで定義されており、手動変更は推奨されていない そのため、同時接続数が上限に達しそうな場合は、上位のインスタンスクラスorRDS Proxyを検討する RDS Proxyの特徴 フルマネージドサービス アプリケーションとRDSの間に設置 VPC内の異なるAZにある2サブネットを選択して作成 RDS Proxyを間に配置することによる遅延は5ミリ秒程度 RDSのインスタンスレベルを上げずに済むので、コストや運用工数を抑えられる RDS Proxyを採用するメリット フェイルオーバーにかかる時間を短縮できる 数秒レベルでフェイルオーバーが完了する RDS Proxyがない場合は、スタンバイの昇格とクラスタエンドポイントの更新後にアプリケーションが再接続するのに比べて、RDS Proxyがある場合はアプリケーションからの接続をプールし、RDS ProxyからRDSへの接続は処理中であったものを除いて保持・再利用するため この箇所ちょっと引っかかったので調べてみた。 RDS Proxyの使用有無で、RDS側のフェイルオーバーにかかる時間は変わらないと思う ただし、アプリケーションの視点で見た時に、RDS Proxyへのコネクションを再確立する必要がない RDS ProxyーRDS間のコネクションの再確立のみで不要 なので、アプリケーション側からすると、再接続するオーバーヘッドがかからないので、フェイルオーバーにかかる時間を短縮できると表現されていると思われる(RDS側のDNS更新も待つ必要もない) RDS Proxyを利用する際の注意点 IPアドレスの枯渇 IPアドレスを消費するのは、RDS Proxy-RDSの接続 RDS Proxy-RDSは、同じVPC内で通信するため、プライベートIPアドレスを使用する RDS Proxyは、接続先RDSのインスタンスクラスと台数に応じて自動的に容量を増減し、場合によっては多くのIPアドレスを利用する IPアドレスが枯渇するとうまくスケールができず、クエリ遅延やコネクション失敗が発生することがある インスタンスクラスごとに確保すべき最小IPアドレス数が定められている 回避する方法としては、サブネットのIPアドレス範囲を広くすることが推奨される セッション固定（ピン止め）による影響 特定のトランザクションやセッションが接続プール内の特定のバックエンド(DB)接続に固定される状態を指す この状態になってしまうと、通常共有可能な接続が他のリクエストに再利用されなくなり、DBへの同時接続数が増え続け、最終的にはDB接続が行えなくなる可能性がある CloudWatchメトリクスの「DatabaseConnectionsCurrentlySessionPinned」を監視すると良い ピン留め発生が想定されるケース ステートフルなリクエスト ユーザーセッションに依存する処理が行われる場合、同じバックエンド接続を使用し続ける必要があります。 例: 一時テーブルやユーザー固有の設定を使用したクエリ。 特定のSQL機能の使用 以下のような機能を使用すると、接続が固定されることがあります： セッション変数: SET SESSION を使用してカスタム設定を適用。 一時テーブル: セッション固有のデータを保持。 ユーザー定義関数（UDF）: セッションスコープで動作する関数。 ロック操作: セッションスコープのロック（例: GET_LOCK()）。 トランザクション管理 トランザクション内で複数のクエリが実行される場合、トランザクションの一貫性を保つため、同じ接続を使い続ける必要があります。 逆に、接続と破棄を繰り返すLambda関数等の使用であれば、この問題は発生しないも？ 目を通した導入事例とか 【AWS】RDSのインスタンスタイプを上げたらRDS ProxyのENIがDBサブネットのIPを食い尽くした話 - BFT名古屋 TECH BLOG Amazon RDS Proxy が BASE にもたらした期待以上の導入メリット - BASEプロダクトチームブログ Aurora Auroraを利用すると、簡単にレプリケーションやクラスタの設定が可能 Auroraの構成 1つ以上のインスタンスと1つのクラスタボリューム インスタンスには読み取り/書き込みを行うプライマリと読み取りのみをサポートするレプリカ RDSでAurora以外のエンジンを使用している場合との比較 インスタンスとストレージが分離している点が大きく異なる AuroraはRDSにまたがる分散ストレージにより、バックアップや復旧がRDSより高速 RDSより割高なイメージがあるが、構成と運用次第でRDSよりも費用を抑えられる Auroraのバージョン MySQLやPostgreSQLのコミュニティバージョンに対応した独自のAuroraバージョン major.minor.patchの構成 マイナーとパッチは自動アップグレードも可能 アップグレードにはDBの停止を伴うことを想定する コミュニティサポート期限が切れると現行以降のメジャーバージョンに自動アップグレードされてしまうので注意 レプリケーションとフェイルオーバー レプリケーション プライマリインスタンスに書き込みが発生すると、通常100ミリ秒以下の遅延でレプリカ側でも書き込まれたデータを参照可能になる レプリカは最大15台をクラスタに組み込めるので、読み込み負荷の高いアプリケーションはAuroraを検討すると良い 複数リージョンにまたがるグローバルデータベースでも、レプリケーションが1秒以内 レプリケーション先にDBインスタンスは不要(クラスタボリュームがあるため) DR対策としてもAuroraは優位性がある フェイルオーバー プライマリに障害が発生すると、レプリカが昇格する フェイルオーバーの開始から終了までは通常30秒以内 なおシングルインスタンス構成の場合は、障害が発生したAZにDBインスタンスを作成しようとする スケーリング 最大128TiBまで容量を自動拡張する 拡張時にパフォーマンス影響なし 手動でインスタンスクラスを変更すると、容量だけでなくCPUやメモリもスペックアップ可能だが、サービス停止が発生するので注意 無停止でインスタンスクラスが自動スケールするAuroraServerlessもある AuroraServerless ユーザーが事前に設定した範囲で自動スケールアップ DynamoDB フルマネージド型のNoSQLデータベース DynamoDBの特徴 高信頼性 リージョン内3AZに同期されるので、高い可用性と耐障害性 高スループット テーブルごとのRead/Writeそれぞれにスループットキャパシティを柔軟に割り当てられる サーバーレス VPCの設計が不要 事前に設定するキャパシティに基づいて自動スケーリングできる 容量無制限 データのパーティショニングも自動で行われる 整合性モデル DynamoDBはデフォルトで「結果整合性のある読み込み」を行う DynamoDBでは少なくとも2AZで書き込み完了後、およそ1秒以内にAck(確認応答)を返す 書き込み後1秒の間にアクセスした際のデータ不整合を許容できる場合はデフォルトのままで良い 「強力な整合性のある読み込み」をするには、DynamoDBへのリクエスト時に「ConsistentReadパラメータ」を付与する(追加でコストがかかる点に注意) トランザクション読み込み/書き込みAPIもある モード 実際に使用した分にかかる「オンデマンドキャパシティ」と事前に予測可能な場合に有用な「プロビジョンドキャパシティ」がある 単位や請求内容が異なるので注意 インスタンスを用いるRDSよりは、多くの場合で費用を削減できる DynamoDBの設計 以下のプライマリキーが必要 パーティションキー(必須) テーブルのアイテムはパーティションという領域に配置される このパーティションキーの値を元に配置先のパーティションが決定される ソートキー パーティションキーが同一であるアイテムに対し、並び順を保証するために使用される この辺り理解甘いから公式ドキュメントを読み込みたい DynamoDB を使用した設計とアーキテクチャの設計に関するベストプラクティス - Amazon DynamoDB 7.ストレージ 大量のデータを保存したい場合：S3 Lambdaや複数のLinux系EC2インスタンスからデータを利用したい場合：EFS EBS オンプレミスサーバに例えると、搭載する物理ディスクにあたる 費用は、プロビジョニングされた容量に対して発生するので、インスタンスが停止していても課金されるので注意 S3 オブジェクトストレージ インターネットからアクセスを受け付けるS3には適切なセキュリティ対策が必要 セキュリティ データ保護 2023年1月より、S3に追加される全てのオブジェクトにはSSE-S3での暗号化が自動適用されるようになった 監査や鍵の一元管理が不要であれば、追加費用かからず管理の手間もないSSE-S3を利用すると良い アクセスポリシーの全体像 リソースベースのポリシーとユーザーベースのポリシーを利用して、リソースへのアクセスを管理できる リソースベースのポリシー バケットポリシー バケットアクセスコントロールリスト(ACL) オブジェクトACL バケットアクセスコントロールリスト(ACL)とオブジェクトACLは、使用する必要がないケースが多い バケットポリシーとユーザーポリシーで同じ対象に異なるアクセス制限(拒否と許可など)がされている場合は、より厳しい制限が適用されるので注意 8.アプリーション統合 Amazon API Gateway 2種類のAPIが用意されており、RestfulAPIとチャットなどのリアルタイム双方向通信を行うステートフルなWebSocketAPIがある RestfulAPIには、WAF統合やクライアントごとのスロットリングなどの多機能なREST APIと、機能を絞り費用を抑えたHTTP APIが存在する 以下を参考に、要件に対して必要な機能を検討してどちらかを選ぶようにする REST API と HTTP API のどちらかを選択する - Amazon API Gateway マッピングテンプレートを使用すると、リクエストやレスポンスの整形が可能 トークンバケットアルゴリズムを使用したスロットリング 公式が出しているベストプラクティスもある Amazon API Gateway のセキュリティのベストプラクティス - Amazon API Gateway 書かれているのは、最小権限やアクセスログの記録・アラート設定、CloudTrailの有効化など EventBridge EventBridgeの特徴 EventBridgeは、様々なAWS内やSaaSアプリケーションのイベントを受信・処理し、ターゲットであるAWSサービスへ渡すイベント駆動型のマネージドサービス スケジュールをトリガーとしたルール実行も可能 イベントバスの種類 イベントバスと呼ばれるパイプラインでイベントを受信する アクセス制御 デフォルトのイベントバスは、操作しているAWSアカウントからのイベントを許可する 各サービスのアクセス制御は、ターゲット側のポリシーで許可するorEventBridgeのルールのIAMロールでポリシーを設定する EventBridgeのルールと入力トランスフォーマー ターゲットは5つまで指定できる 並列実行が可能 DatadogやNewRelic等のサードパーティツールにも統合可能 入力トランスフォーマーでターゲットに渡す情報を編集できる SNSやSQSとの使い分け 同じイベント駆動型アプリケーションであるSNSやSQSとの使い分けについて SNSやSQSを使用するケースは以下の通り 低レイテンシが求められる 多数のエンドポイントが必要 対人メッセージングに利用(SNSを使うべし) 順序保証が必要 SNS プッシュ方式 プロデューサー == ブローカー == コンシューマーという構成でブローカーからコンシューマーへジョブがプッシュされる SQS プル方式 コンシューマー側が能動的にブローカー(キュー)からメッセージを取得する P2P方式 プロデューサーとコンシューマが1：1で連携する方式 EventBridge スケジュール実行・SaaSサービスとの連携・メッセージの加工はEventBridgeにしかない機能 要件に合わせて使い分けることが大切 9.可用性 疎結合化の文脈で、システムのつなぎ目に拡張性・耐障害性に優れた機能を配置すると良い 例えば、ロードバランサやDNS・メッセージキュー つなぎ目にはできるだけ非同期処理を行うコンポーネントを配置する EventBridge,SQS,Kinesisシリーズ群,Step Functions SQS(スタンダードキュー)は、1秒間にほぼ無限にAPIコールを受け付けられるため、可用性は問題にならない 疎結合には、スケールアウトした時に他のコンポーネントへの影響が少ないことや障害発生時の切り分けもしやすいことがメリットになる SLA AWSはSLAを満たせなかった場合、サービスクレジットとして還元される キャッシュバックではなく、今後請求される支払いに対して利用できるもの 契約者は、いくつかの情報を揃えてAWSに提出する必要がある(自動で適用されるものではない点に注意) 10.セキュリティ クラウド事業者の選定 ISMAPのクラウドサービスリスト: https://www.ismap.go.jp/csm?id=cloud_service_list Amazon Inspector CIS Benchmarksに沿って、EC2やECRのOSやミドルウェア設定を確認・可視化できる ベストプラクティスに準拠していない場合はレポート出力される リスク検出を支援するAWSサービス 無料で手軽に：TrustedAdvisor, IAM Access Analyzer ルールをカスタマイズもできる：AWS Config それほど料金かからない：SecurityHub 11.ジョブ管理 バッチ処理を行うシステムをジョブ管理システムという AWSのジョブ実行に関連するサービスはいくつかある 15分以内ならLambdaで実装するのが良い ECS Scheduled TaskやBatchと比較して安価 ECS Scheduled Taskは、EventBridgeでのトリガを元にECSを実行するというもの Batch 長時間、高負荷な処理はBatchでの実装を検討すると良い 逆に短時間で終わるものや即時実行が必要なジョブには向いていない Batchはコンテナ環境を使って処理を行うので、注意すべきポイントがいくつかある Batchの特徴 コンポーネント BatchのジョブはECSやEKSのコンテナ上で実行される スポットインスタンスの活用 コストを安くできる反面、発生しうる中断に対してのケアが必要 冪等性を考慮したジョブ設計にし、リトライできるようにする ジョブを短時間で終わるように設計する 定期的に結果をS3やEFSに出力するチェックポイント方式にする ジョブの再試行回数を設定する 実際の設計例では、 優先度の高いジョブはオンデマンドに処理させて、そうではないジョブはスポットインスタンスにするとか スポットインスタンスで失敗したジョブをSNSに通知→Lambdaを経由して、オンデマンド用キュー→オンデマンドインスタンスでジョブを再実行とか方法がある Step Functions AWSサービスやAPIを組み合わせ、ワークフローを視覚的に作成・実行できるサービス ワークフロータイプ StandardとExpressがある 実行頻度の高い処理を短時間で処理させる場合はExpressを選択する 料金 Lambdaよりは割高 状態遷移の回数で課金される EventBridgeーLambdaの構成であれば無料利用枠内に収まるなんてこともあるので、見積もりを慎重に行う StepFunctionsはデバッグがしやすい ステートごとに入出力やイベントが見やすかったり ステートごとにログが時系列でわかりやすく並んでいたりする 12.バックアップ オンプレでもクラウドでもバックアップの重要性は変わらない AWSのバックアップ EC2 Amazon Data Lifecycle Managerで定期的にスナップショットを取得 RDS 自動バックアップの有効化、手動バックアップの実行 S3 バージョニング有効、ライフサイクル管理 AWS Backup フルマネージドなバックアップサービス 最低料金や初期費用が発生しない バックアップの自動化や保存期間が過ぎたデータなどバックアップに関する一元管理が可能 対象は、AWSリソースのみ 概要 バックアッププランを作成し、ルールで指定したスケジュールでバックアップを行う バックアッププランで、AWSリソースを指定する 想定外にかかる費用 簡単に設定できてしまう反面、想定より費用がかかるケースがある バックアップを一定期間運用した後は、定期的に適切な範囲に収まっているかを確認した方が良い 13.監視 RDS スロークエリなどを出力したい場合は、パラメータグループのlog_outputをFILEにする VPC VPC内のトラフィック情報をCloudWatch Logsに出力するには、VPCフローログが必要 ",
  "keywords": [
    
  ],
  "articleBody": "AWS設計スキルアップガイド ――サービスの選定から、システム構成、運用・移行の設計まで：書籍案内｜技術評論社\n2.クラウドのインフラ設計 クラウドで考えるセキュリティ 万が一の事故や障害が発生したときに「責任分界点」を定義しておくことで、責任の所在を明らかにできる AWSでの「責任共有モデル」では、それぞれの責任について以下のように定義されている AWS: サービスを提供するためのインフラストラクチャ 利用者: 選択したAWSサービスごとの適切なセキュリティを実装し、システムを保護する AWS SecurityHubを使用することで、横断的にセキュリティの問題を検知することができる 3.システムの構成 AWSでシステムを構築する時にまず考えるべきは「アカウントをどの単位で発行するか」 AWSアカウントの運用例 単一のアカウントで運用するケース 注意ポイント VPCをプロジェクトや環境ごとに分離する プロジェクトや環境がわかるようにタグを活用する VPCに関連のないサービスを使用する場合、IAMで権限を設定する 管理する請求先が1つになるメリットはあるが、誤操作等によるミスや事故リスクが上がるので、できればアカウントは分けて運用するのが良い 複数のアカウントで運用するケース アカウントの統制を考慮する AWS ControlTowerで一元管理 Organizationで多数のAWSアカウントを管理 ログインIDの統合を検討する(1つのユーザーアカウントで各AWSアカウントにログインできるようにする) 各環境のIAMロールで行う方法 AWS IAM Identity Center (SSO)を活用する方法 サードパーティIDaaSを活用する方法 (追記) AWS ControlTowerを利用すると、マルチアカウント環境を一元的に整備してくれる 参考: スタートアップにおけるマルチアカウントの考え方と AWS Control Tower のすゝめ | AWS Startup ブログ IAM 認証はIAMユーザー、認可はIAMポリシーで設定する 通常、ポリシーはグループもしくはロールに付与する なぜなら、ユーザーにポリシーをアタッチすると、運用工数がかかる IAMポリシー設計 デフォルトはすべて拒否なので、明示的に許可していく どのリソース(Resource)に対して、どんな条件で(Conditions)、どんな動作(Action)を、許可/拒否する(Effect)かをJSONもしくはGUIで記述(選択)する ポリシーはいくつか種類がある(使用頻度が高いものを抜粋) アイデンティティベースのポリシー アイデンティティ(ユーザー、グループ、ロール)にアタッチする この中にも再利用可能な管理ポリシーとインラインポリシーが存在(管理ポリシー推奨) リソースベースのポリシー S3などのリソースにアタッチする セッションポリシー 一時的にセッション単位でアクセスを許可するポリシー AssumeRoleなどのAPIを利用する ポリシー評価について 以下の順番で評価される 画像引用元: 【入門編】AWSにおけるアクセスポリシーの評価ロジックを整理してみる 明示的な拒否があれば、その拒否設定が適用される 拒否設定の後に、明示的な許可設定があったとしても、拒否設定が優先的に適用される 明示的な許可があれば許可となるが、なかった場合は暗黙的に拒否される 4.ネットワーク設計 オンプレミスとの比較 オンプレミスと比較すると、AWSにおけるネットワーク設計はある程度ざっくりでOK 名前解決 オンプレミス: 内部DNSを立てるか各サーバーのhostsファイルを利用して名前解決を行う AWS: 自動でパブリックのDNS名が割り当てられ、マネージドのDNSで名前解決を行う 時刻同期 オンプレミス: システム内の時刻が同期するように同一のNTPサーバーを割り当てる AWS: AmazonTimeSyncServiceで同期する(インターネット接続不要) マネージドNTP VPCで実行されているすべてのインスタンスの 169.254.169.123 IPアドレスで NTP を介して利用できる 最新バージョンのAmazonLinux2とAmazonLinuxAMIはデフォルトでAmazonTimeSyncServiceと同期してくれている LambdaやECS on Fargate等のマネージドサービスではAWS側で時刻同期されているはずとのこと AWSマネージドサービスの時刻同期はAWS側で行われているのか | AWS re:Post VPCとサブネット VPCはリージョンごとのサービスなので、リージョンを跨ぐことはできない サブネットではいくつかのIPアドレスがAWSの予約枠として確保されている ネットワークアドレス (最初のIPアドレス) 例: 10.0.0.0/24サブネットの場合、10.0.0.0がこのアドレスです。 役割: ネットワーク自体を表すためのアドレスであり、ルーティングやネットワーク構成で使用されます。 VPCルーター (2番目のIPアドレス) 例: 10.0.0.1がこのアドレスとなります（サブネットによって異なる場合もあり）。 役割: サブネット内での通信を管理する仮想ルーターです。インスタンス間の通信やインターネットゲートウェイ、VPN接続の経路制御など、サブネット内のルーティングに使用されます。 DNSサーバー (3番目のIPアドレス) 例: 10.0.0.2です。 役割: AWSが提供するDNSリゾルバーのIPアドレスです。VPC内のインスタンスがDNSクエリを行う際に使用します。独自のカスタムDNS設定を行わない限り、このアドレスがデフォルトでDNSリゾルバーとして機能します。 将来の用途のために予約されたアドレス (4番目のIPアドレス) 役割: 現時点で特定の用途が明確には指定されていませんが、AWSが今後の機能拡張や内部用途のために予約しています。 ブロードキャストアドレス (最後のIPアドレス) 例: 10.0.0.255/24サブネットの場合、10.0.0.255がこのアドレスです。 役割: ブロードキャスト通信のために予約されていますが、AWSのVPCではブロードキャスト通信はサポートされていないため、実際に使用することはありません。 セキュリティグループ・ネットワークACL・AWS Network Firewall AWS Network Firewallは有料なのであまり使われない セキュリティグループ(SG)→ネットワークACLと、フィルタの範囲を狭めて、シンプルな構成・運用にする SGは、同一SGに所属しているノード同士の通信でも明示的に許可する必要がある ルートテーブル ルートテーブルは複数のサブネットで共有可能 サブネット作成時にルートテーブルも作成され、追加の設定なくVPC内の通信は可能 デフォルトで、VPC内の全てのサブネットに向けたローカルルートが設定されているため ということは、同じVPC内のサブネットに存在するリソース間で通信を拒否したい場合は、セキュリティグループで設定する必要がある VPCエンドポイント 異なるVPCやリージョンに配置されたAWSサービスへインターネットを経由せずに接続するサービス ゲートウェイエンドポイント ルートテーブルでAWSサービスへのルートを指定 費用かからない インターフェイスエンドポイント VPCのプライベートIPアドレスを使用してアクセスする ENIとしてVPC内に配置され、それがサービスに接続するためのエンドポイントとして動作する 処理するデータ量に応じて課金される 例えばS3は、どちらでも接続可能だが、インターフェイスエンドポイントの方がセキュリティグループでトラフィックを制御できるため、セキュアである VPC内のリソースがエンドポイントに対して、どのように通信できるかを詳細に制御ができるため、という意味(IPやプロトコル等の制限が可能) VPCフローログ VPC内のネットワークインターフェースに流れる情報をキャプチャし、ログに記録する 監査に必要なログを出力したり、通信がうまく通らない場合はトラブルシューティングとして出力したり フローログは以下の3つの項目を指定する フローログを取得するリソース(VPC/サブネット/ENIをもつELBやNATGateway等) どんなトラフィックをキャプチャするか(許可、拒否、全て) フローログの出力先(CloudWatch Logs/S3) AWSにセキュアに接続する AWS Client VPN サイト間VPN Direct Connect 5.コンピューティング Lambda イベント駆動型のアプリケーションで使いやすい コールドスタートにかかる時間を短くする方法 VPC内にアクセスしない(ENI作成に10〜30秒かかるため) VPC Lambdaと呼ばれてるやつ Lambdaをパブリックサブネットに配置するとENIが作成されアタッチされる そのENIに対し、パブリックIPを付与(アドレス関連付け)してやれば、Lambdaからアウトバウンドの通信ができるらしい メモリ増やす(メモリ量に比例してCPUも増加する) コード量を短くする 関数の初期化や依存解決の速度の向上が見込まれるため Lambdaのセキュリティ IAMを最小限にする 特定の条件下で特定のリソースに対して実行できるアクションのみ定義する 基本的には複数のLambda関数でIAMロールで共有しない Lambdaの監視 Lambda関数をデプロイすると自動でCloudWatch Logsと連携する＋レイテンシやエラー率などのメトリクスも自動で発行する エラーを検知できるようにアラートを設定しておくと良い 特にDuration(所要時間)やThrottles(同時実行上限を超えて制限した数)は、エラーが発生する前に適切検知できるようにしておく EC2 インスタンスタイプの書式 Amazon EC2 インスタンスタイプの命名規則 - Amazon EC2 オプション コンピューティング最適化: CPU大きめ メモリ最適化: メモリ大きめ AMI インスタンス起動するのに必要なOSやボリューム・アプリケーションを含むテンプレート OSのライセンス費用はEC2の利用料金に含まれている(オンプレと異なる点であり、メリットである) インスタンスの費用削減 リザーブドインスタンス 時間単位の費用を削減できる 1年や3年の長期使用を約束する インスタンスクラスの変更しない場合、または負荷増加の際にオンデマンドインスタンスやスポットインスタンスで対応できる場合に検討する 実際の使用有無に関わらず、購入した条件に応じた期間の費用が発生する SavingsPlans これも1年や3年の長期使用を約束する リザーブドインスタンスとの違いは、LambdaやFargateでも使用可能である点、インスタンスファミリーやプラットフォームなどを指定しなくて良い 逆にRDSやElasiCacheでは使用できないので注意 3種類がある インスタンスタイプや構成を柔軟に変更する予定がある場合は、SavingsPlansを検討する スポットインスタンス AWSクラウド内の使用されていないEC2キャパシティを活用し、中断される可能性がある なので、本番環境で常時起動するサーバーではなく、ECS実行環境やCICDのビルド環境、バッチに適用する 本番環境で適用する場合は、AutoScalingグループでオンデマンドインスタンスとスポットインスタンスの割合を指定する等して、中断が影響しないようにする 中断の2分前にAWSから警告が来るので、アプリケーションの安全な停止や、ログの退避などは自動で対応できるように実装する インスタンスメタデータで中断対象か確認できる インスタンスメタデータを取得できるAPIがあるっぽい そこを定期的に叩くことで確認 T系インスタンスの注意点 汎用のT系はM系よりも安価でありよく選定されるが、バーストパフォーマンスインスタンスであることは十分に理解が必要 バーストパフォーマンスインスタンスとは ベースラインと呼ばれるCPU使用率がある そのベースラインに対して、下回る間はクレジットを獲得し、超える間は消費する 1CPUクレジット=1vCPU×100%使用率×1分 つまり、1vCPUを50%使用率で2分使用すると、1クレジット消費するということ 24時間の間で、獲得したクレジットよりも消費するクレジットが多い場合に、その分のvCPU費用が発生する T系インスタンスの各タイプで、1時間あたりに受け取るクレジットや蓄積可能なクレジット、ベースライン使用率は決められている CPUクレジットの消費タイプには以下の2種類がある Standard: 残高が0になると、ベースライン使用率以下でのみ使用可能となる Unlimited: Standardのような制約はない代わりに、CPUクレジットが0になった後は、vCPU時間ごとに均一追加料金が発生する（他のインスタンスタイプの利用料金を超える可能性がある） 重要なのは、CPU使用率を監視すること CloudWatchメトリクスで参照可能 バーストインスタンスの CPU クレジットをモニタリングする - Amazon Elastic Compute Cloud 参考: バーストパフォーマンス(T系)インスタンスの特徴を理解して上手に利用しよう | AWS Startup ブログ コンテナ 仮想化とコンテナの違い ゲストOSの有無が大きな違い 仮想化はホストOSを介して、ハードウェアを制御するため、オーバーヘッドが大きい コンテナは、アプリケーションの動作環境を隔離していて、カーネルはホストOSに依存するため、仮想化のように複数の異なるOSを稼働させることはできないが、逆に言えばOSがない分起動が早く、使用するリソースも少なくて済む コンテナとEC2の違い EC2上でコンテナを実行するのと、ECSやEKSなどのオーケストレーションツールを使用するのとでどのような違いがあるのかという問いと同義 EC2上で動かした場合、デプロイする時は、EC2アプリケーションを更新→AMIを取得→AutoScaling対象のAMIを変更するという、とても面倒な手作業が発生する 逆にロールバックの作業も面倒.. 加えて、OS更新等の手作業も発生する 一方、ECSの場合は、コンテナやOSの障害や更新をAWS側が管理してくれる CI/CDパイプラインを構築すれば、アプリケーション変更から適用まで迅速に行える コンテナがプロセス落ちを管理し、再度デプロイしてくれる(Serviceがやっていることかな？) コンテナを構成するサービスの特徴 複数の環境を有するシステム 再現性が高い特徴を活かせる 更新頻度が高いシステム アクセス増減の発生が高いシステム もはやこのご時世的にはあえてEC2を選択するケースはないのではと思う コンテナサービスを作るときに気をつけること 障害発生することを前提とする プロセスが落ちても、すぐに起動できるように ECS Serviceを使えという話だと思う 環境差異は変数化する ログ出力を1本化する コンテナは実行環境であるホストOS上でプロセスとして動作し、他のプロセスから隔離されている コンテナ内部でアプリケーションログを吐いても、プロセス停止した際などにログが残らなくなってしまう ホストOSか別の領域に出力するように設定する ちょっと調べた感じ、タスク定義でログドライバにawslogsを設定し、ロググループなども設定すれば、1つのロググループに出力されるようになるっぽい 1コンテナ1プロセスとする 1つのコンテナに複数のプロセスを稼働させることも可能だが、制御が難しいため Amazon ECS ECSの構成要素 クラスター：実行環境 タスク定義：指定のコンテナを動かす サービス：全体の構成やデプロイ方法を設定 タスク定義 主な設定項目 Dockerイメージ コンテナのCPUとメモリ データボリューム IAMロール コンピューティング環境(EC2 or Fargate) サービス 主な設定項目 連携するELBを指定 指定したタスク定義のタスク数 デプロイ方法(Blue/Green,ローリングアップデート) 実行環境(EC2,Fargate)で待ち受けるポートや、コンテナ側で待ち受けるポートも指定する サービスはなくても動くけど、AutoScalingの実装等に必要 クラスター 主な設定項目 コンテナ実行環境のネットワークを指定 起動するインスタンスタイプやAMI、その数を指定 Fargateの場合は、ネットワーク作成とクラスター名のみを設定する タスク定義の更新 コンテナイメージにつけるタグ名はlatestにするとタスク定義の修正が不要になる一方、コンテナイメージのバージョンがわからないのがで名rっと デプロイ方法「ローリングアップデート」と「Blue/Greenデプロイメント」がある ローリングアップデートの例 DesiredCountを4に、minimumHealthyPercentを0.5に設定した場合、4 * 0.5の2インスタンスが更新されたタスク定義を元に作成される Blue/Greenデプロイメントの例 タスク定義を更新すると、新たにGreen環境が作成あれ、疎通に問題がなければ、LBのレイヤーで切り替えを行う（だからLBが必須） データボリューム ログや共通のデータはコンテナ外に領域を確保する ECSで選択可能なデータボリュームは以下になる EFS FSx for Windows File Sever Dockerボリューム EC2のみ利用可能 バインドマウント ホスト上のファイルやディレクトリをコンテナからマウントする Fargate タスクエフェメラルストレージ エフェメラルストレージ=一時的なストレージ プロビジョニング時にECSタスクが受け取るもの これらをマウントし、タスク定義内でvolumes、mountPointsおよびvolumesFromパラメータを使用しているコンテナ間で共有することが可能 Amazon ECS タスクのストレージオプション - Amazon Elastic Container Service 6.データベース データベースの選択 どんな用途なのかと移行か新規なのか、複数の観点からの検討が必要 RDS EC2同様に仮想サーバー上で実行される EC2でもDBの構築は可能だが、RDSと異なり自動スケーリングや高可用性、OS・DBソフトウェアのパッチ適用などはユーザーが設計・実装・運用する必要がある 逆に、その辺りを自前で管理したい・RDSでサポートされていないパラメータをチューニングしたい・開発環境などで費用削減をしたいという場合はEC2でのDB構築が選択肢になる リクエストのI/Oサイズやアクセスパターンにより、パフォーマンスが大きく変わる シーケンシャルなアクセスでは、最大I/Oサイズに達するまで、単一のI/O操作に含められる ランダムなアクセスでは、最大I/Oサイズに達しない小さいサイズでも、IOPSに個別カウントする つまりランダムアクセスの場合はIOPSの消費が多いので、それを考慮してインスタンスクラスなどを決めようという話 パフォーマンスは、DBで最も重要な非機能要件になるので、机上確認だけでなく、実際に検証したり、CloudWatchメトリクスで確認したりして、ストレージタイプを選ぶと良い マルチAZ構成 サポートされている機能は、リージョンやデータベースエンジンによって異なる マルチAZデプロイすると、Read/WriteできるプライマリDBインスタンスとフェイルオーバー先となるスタンバイレプリカ(読み取り書き込みはできない)が別AZへデプロイされる スタンバイレプリカは通常時は動作せず、プライマリに障害が発生した時にレプリカが昇格する フェイルオーバーは60〜120秒 マルチAZ DBクラスタ 1つの読み取り/書き込みインスタンスと、2つ以上の読み取り専用スタンバイDBインスタンスで構成 読み取り/書き込みインスタンスに障害が発生したら、読み取り専用スタンバイDBインスタンスが昇格 書き込み専用DBインスタンス接続するクラスタエンドポイントと、読み取り専用に接続するリーダーエンドポイントがある エンドポイントは、クラスタ内の対象インスタンスに接続できない場合に自動的に接続先を変更する フェイルオーバーは35秒未満 RDS Proxy RDSでは、アプリケーションからの接続を処理する際にメモリやCPUを消費する 頻繁に短時間でDB接続を繰り返すアプリケーションでは、DBの処理負荷を下げるためRDS Proxyを導入すると良い RDSの最大接続数はパラメータグループのmax_connectionsで定義されており、手動変更は推奨されていない そのため、同時接続数が上限に達しそうな場合は、上位のインスタンスクラスorRDS Proxyを検討する RDS Proxyの特徴 フルマネージドサービス アプリケーションとRDSの間に設置 VPC内の異なるAZにある2サブネットを選択して作成 RDS Proxyを間に配置することによる遅延は5ミリ秒程度 RDSのインスタンスレベルを上げずに済むので、コストや運用工数を抑えられる RDS Proxyを採用するメリット フェイルオーバーにかかる時間を短縮できる 数秒レベルでフェイルオーバーが完了する RDS Proxyがない場合は、スタンバイの昇格とクラスタエンドポイントの更新後にアプリケーションが再接続するのに比べて、RDS Proxyがある場合はアプリケーションからの接続をプールし、RDS ProxyからRDSへの接続は処理中であったものを除いて保持・再利用するため この箇所ちょっと引っかかったので調べてみた。 RDS Proxyの使用有無で、RDS側のフェイルオーバーにかかる時間は変わらないと思う ただし、アプリケーションの視点で見た時に、RDS Proxyへのコネクションを再確立する必要がない RDS ProxyーRDS間のコネクションの再確立のみで不要 なので、アプリケーション側からすると、再接続するオーバーヘッドがかからないので、フェイルオーバーにかかる時間を短縮できると表現されていると思われる(RDS側のDNS更新も待つ必要もない) RDS Proxyを利用する際の注意点 IPアドレスの枯渇 IPアドレスを消費するのは、RDS Proxy-RDSの接続 RDS Proxy-RDSは、同じVPC内で通信するため、プライベートIPアドレスを使用する RDS Proxyは、接続先RDSのインスタンスクラスと台数に応じて自動的に容量を増減し、場合によっては多くのIPアドレスを利用する IPアドレスが枯渇するとうまくスケールができず、クエリ遅延やコネクション失敗が発生することがある インスタンスクラスごとに確保すべき最小IPアドレス数が定められている 回避する方法としては、サブネットのIPアドレス範囲を広くすることが推奨される セッション固定（ピン止め）による影響 特定のトランザクションやセッションが接続プール内の特定のバックエンド(DB)接続に固定される状態を指す この状態になってしまうと、通常共有可能な接続が他のリクエストに再利用されなくなり、DBへの同時接続数が増え続け、最終的にはDB接続が行えなくなる可能性がある CloudWatchメトリクスの「DatabaseConnectionsCurrentlySessionPinned」を監視すると良い ピン留め発生が想定されるケース ステートフルなリクエスト ユーザーセッションに依存する処理が行われる場合、同じバックエンド接続を使用し続ける必要があります。 例: 一時テーブルやユーザー固有の設定を使用したクエリ。 特定のSQL機能の使用 以下のような機能を使用すると、接続が固定されることがあります： セッション変数: SET SESSION を使用してカスタム設定を適用。 一時テーブル: セッション固有のデータを保持。 ユーザー定義関数（UDF）: セッションスコープで動作する関数。 ロック操作: セッションスコープのロック（例: GET_LOCK()）。 トランザクション管理 トランザクション内で複数のクエリが実行される場合、トランザクションの一貫性を保つため、同じ接続を使い続ける必要があります。 逆に、接続と破棄を繰り返すLambda関数等の使用であれば、この問題は発生しないも？ 目を通した導入事例とか 【AWS】RDSのインスタンスタイプを上げたらRDS ProxyのENIがDBサブネットのIPを食い尽くした話 - BFT名古屋 TECH BLOG Amazon RDS Proxy が BASE にもたらした期待以上の導入メリット - BASEプロダクトチームブログ Aurora Auroraを利用すると、簡単にレプリケーションやクラスタの設定が可能 Auroraの構成 1つ以上のインスタンスと1つのクラスタボリューム インスタンスには読み取り/書き込みを行うプライマリと読み取りのみをサポートするレプリカ RDSでAurora以外のエンジンを使用している場合との比較 インスタンスとストレージが分離している点が大きく異なる AuroraはRDSにまたがる分散ストレージにより、バックアップや復旧がRDSより高速 RDSより割高なイメージがあるが、構成と運用次第でRDSよりも費用を抑えられる Auroraのバージョン MySQLやPostgreSQLのコミュニティバージョンに対応した独自のAuroraバージョン major.minor.patchの構成 マイナーとパッチは自動アップグレードも可能 アップグレードにはDBの停止を伴うことを想定する コミュニティサポート期限が切れると現行以降のメジャーバージョンに自動アップグレードされてしまうので注意 レプリケーションとフェイルオーバー レプリケーション プライマリインスタンスに書き込みが発生すると、通常100ミリ秒以下の遅延でレプリカ側でも書き込まれたデータを参照可能になる レプリカは最大15台をクラスタに組み込めるので、読み込み負荷の高いアプリケーションはAuroraを検討すると良い 複数リージョンにまたがるグローバルデータベースでも、レプリケーションが1秒以内 レプリケーション先にDBインスタンスは不要(クラスタボリュームがあるため) DR対策としてもAuroraは優位性がある フェイルオーバー プライマリに障害が発生すると、レプリカが昇格する フェイルオーバーの開始から終了までは通常30秒以内 なおシングルインスタンス構成の場合は、障害が発生したAZにDBインスタンスを作成しようとする スケーリング 最大128TiBまで容量を自動拡張する 拡張時にパフォーマンス影響なし 手動でインスタンスクラスを変更すると、容量だけでなくCPUやメモリもスペックアップ可能だが、サービス停止が発生するので注意 無停止でインスタンスクラスが自動スケールするAuroraServerlessもある AuroraServerless ユーザーが事前に設定した範囲で自動スケールアップ DynamoDB フルマネージド型のNoSQLデータベース DynamoDBの特徴 高信頼性 リージョン内3AZに同期されるので、高い可用性と耐障害性 高スループット テーブルごとのRead/Writeそれぞれにスループットキャパシティを柔軟に割り当てられる サーバーレス VPCの設計が不要 事前に設定するキャパシティに基づいて自動スケーリングできる 容量無制限 データのパーティショニングも自動で行われる 整合性モデル DynamoDBはデフォルトで「結果整合性のある読み込み」を行う DynamoDBでは少なくとも2AZで書き込み完了後、およそ1秒以内にAck(確認応答)を返す 書き込み後1秒の間にアクセスした際のデータ不整合を許容できる場合はデフォルトのままで良い 「強力な整合性のある読み込み」をするには、DynamoDBへのリクエスト時に「ConsistentReadパラメータ」を付与する(追加でコストがかかる点に注意) トランザクション読み込み/書き込みAPIもある モード 実際に使用した分にかかる「オンデマンドキャパシティ」と事前に予測可能な場合に有用な「プロビジョンドキャパシティ」がある 単位や請求内容が異なるので注意 インスタンスを用いるRDSよりは、多くの場合で費用を削減できる DynamoDBの設計 以下のプライマリキーが必要 パーティションキー(必須) テーブルのアイテムはパーティションという領域に配置される このパーティションキーの値を元に配置先のパーティションが決定される ソートキー パーティションキーが同一であるアイテムに対し、並び順を保証するために使用される この辺り理解甘いから公式ドキュメントを読み込みたい DynamoDB を使用した設計とアーキテクチャの設計に関するベストプラクティス - Amazon DynamoDB 7.ストレージ 大量のデータを保存したい場合：S3 Lambdaや複数のLinux系EC2インスタンスからデータを利用したい場合：EFS EBS オンプレミスサーバに例えると、搭載する物理ディスクにあたる 費用は、プロビジョニングされた容量に対して発生するので、インスタンスが停止していても課金されるので注意 S3 オブジェクトストレージ インターネットからアクセスを受け付けるS3には適切なセキュリティ対策が必要 セキュリティ データ保護 2023年1月より、S3に追加される全てのオブジェクトにはSSE-S3での暗号化が自動適用されるようになった 監査や鍵の一元管理が不要であれば、追加費用かからず管理の手間もないSSE-S3を利用すると良い アクセスポリシーの全体像 リソースベースのポリシーとユーザーベースのポリシーを利用して、リソースへのアクセスを管理できる リソースベースのポリシー バケットポリシー バケットアクセスコントロールリスト(ACL) オブジェクトACL バケットアクセスコントロールリスト(ACL)とオブジェクトACLは、使用する必要がないケースが多い バケットポリシーとユーザーポリシーで同じ対象に異なるアクセス制限(拒否と許可など)がされている場合は、より厳しい制限が適用されるので注意 8.アプリーション統合 Amazon API Gateway 2種類のAPIが用意されており、RestfulAPIとチャットなどのリアルタイム双方向通信を行うステートフルなWebSocketAPIがある RestfulAPIには、WAF統合やクライアントごとのスロットリングなどの多機能なREST APIと、機能を絞り費用を抑えたHTTP APIが存在する 以下を参考に、要件に対して必要な機能を検討してどちらかを選ぶようにする REST API と HTTP API のどちらかを選択する - Amazon API Gateway マッピングテンプレートを使用すると、リクエストやレスポンスの整形が可能 トークンバケットアルゴリズムを使用したスロットリング 公式が出しているベストプラクティスもある Amazon API Gateway のセキュリティのベストプラクティス - Amazon API Gateway 書かれているのは、最小権限やアクセスログの記録・アラート設定、CloudTrailの有効化など EventBridge EventBridgeの特徴 EventBridgeは、様々なAWS内やSaaSアプリケーションのイベントを受信・処理し、ターゲットであるAWSサービスへ渡すイベント駆動型のマネージドサービス スケジュールをトリガーとしたルール実行も可能 イベントバスの種類 イベントバスと呼ばれるパイプラインでイベントを受信する アクセス制御 デフォルトのイベントバスは、操作しているAWSアカウントからのイベントを許可する 各サービスのアクセス制御は、ターゲット側のポリシーで許可するorEventBridgeのルールのIAMロールでポリシーを設定する EventBridgeのルールと入力トランスフォーマー ターゲットは5つまで指定できる 並列実行が可能 DatadogやNewRelic等のサードパーティツールにも統合可能 入力トランスフォーマーでターゲットに渡す情報を編集できる SNSやSQSとの使い分け 同じイベント駆動型アプリケーションであるSNSやSQSとの使い分けについて SNSやSQSを使用するケースは以下の通り 低レイテンシが求められる 多数のエンドポイントが必要 対人メッセージングに利用(SNSを使うべし) 順序保証が必要 SNS プッシュ方式 プロデューサー == ブローカー == コンシューマーという構成でブローカーからコンシューマーへジョブがプッシュされる SQS プル方式 コンシューマー側が能動的にブローカー(キュー)からメッセージを取得する P2P方式 プロデューサーとコンシューマが1：1で連携する方式 EventBridge スケジュール実行・SaaSサービスとの連携・メッセージの加工はEventBridgeにしかない機能 要件に合わせて使い分けることが大切 9.可用性 疎結合化の文脈で、システムのつなぎ目に拡張性・耐障害性に優れた機能を配置すると良い 例えば、ロードバランサやDNS・メッセージキュー つなぎ目にはできるだけ非同期処理を行うコンポーネントを配置する EventBridge,SQS,Kinesisシリーズ群,Step Functions SQS(スタンダードキュー)は、1秒間にほぼ無限にAPIコールを受け付けられるため、可用性は問題にならない 疎結合には、スケールアウトした時に他のコンポーネントへの影響が少ないことや障害発生時の切り分けもしやすいことがメリットになる SLA AWSはSLAを満たせなかった場合、サービスクレジットとして還元される キャッシュバックではなく、今後請求される支払いに対して利用できるもの 契約者は、いくつかの情報を揃えてAWSに提出する必要がある(自動で適用されるものではない点に注意) 10.セキュリティ クラウド事業者の選定 ISMAPのクラウドサービスリスト: https://www.ismap.go.jp/csm?id=cloud_service_list Amazon Inspector CIS Benchmarksに沿って、EC2やECRのOSやミドルウェア設定を確認・可視化できる ベストプラクティスに準拠していない場合はレポート出力される リスク検出を支援するAWSサービス 無料で手軽に：TrustedAdvisor, IAM Access Analyzer ルールをカスタマイズもできる：AWS Config それほど料金かからない：SecurityHub 11.ジョブ管理 バッチ処理を行うシステムをジョブ管理システムという AWSのジョブ実行に関連するサービスはいくつかある 15分以内ならLambdaで実装するのが良い ECS Scheduled TaskやBatchと比較して安価 ECS Scheduled Taskは、EventBridgeでのトリガを元にECSを実行するというもの Batch 長時間、高負荷な処理はBatchでの実装を検討すると良い 逆に短時間で終わるものや即時実行が必要なジョブには向いていない Batchはコンテナ環境を使って処理を行うので、注意すべきポイントがいくつかある Batchの特徴 コンポーネント BatchのジョブはECSやEKSのコンテナ上で実行される スポットインスタンスの活用 コストを安くできる反面、発生しうる中断に対してのケアが必要 冪等性を考慮したジョブ設計にし、リトライできるようにする ジョブを短時間で終わるように設計する 定期的に結果をS3やEFSに出力するチェックポイント方式にする ジョブの再試行回数を設定する 実際の設計例では、 優先度の高いジョブはオンデマンドに処理させて、そうではないジョブはスポットインスタンスにするとか スポットインスタンスで失敗したジョブをSNSに通知→Lambdaを経由して、オンデマンド用キュー→オンデマンドインスタンスでジョブを再実行とか方法がある Step Functions AWSサービスやAPIを組み合わせ、ワークフローを視覚的に作成・実行できるサービス ワークフロータイプ StandardとExpressがある 実行頻度の高い処理を短時間で処理させる場合はExpressを選択する 料金 Lambdaよりは割高 状態遷移の回数で課金される EventBridgeーLambdaの構成であれば無料利用枠内に収まるなんてこともあるので、見積もりを慎重に行う StepFunctionsはデバッグがしやすい ステートごとに入出力やイベントが見やすかったり ステートごとにログが時系列でわかりやすく並んでいたりする 12.バックアップ オンプレでもクラウドでもバックアップの重要性は変わらない AWSのバックアップ EC2 Amazon Data Lifecycle Managerで定期的にスナップショットを取得 RDS 自動バックアップの有効化、手動バックアップの実行 S3 バージョニング有効、ライフサイクル管理 AWS Backup フルマネージドなバックアップサービス 最低料金や初期費用が発生しない バックアップの自動化や保存期間が過ぎたデータなどバックアップに関する一元管理が可能 対象は、AWSリソースのみ 概要 バックアッププランを作成し、ルールで指定したスケジュールでバックアップを行う バックアッププランで、AWSリソースを指定する 想定外にかかる費用 簡単に設定できてしまう反面、想定より費用がかかるケースがある バックアップを一定期間運用した後は、定期的に適切な範囲に収まっているかを確認した方が良い 13.監視 RDS スロークエリなどを出力したい場合は、パラメータグループのlog_outputをFILEにする VPC VPC内のトラフィック情報をCloudWatch Logsに出力するには、VPCフローログが必要 ",
  "wordCount" : "710",
  "inLanguage": "en",
  "datePublished": "2025-01-15T21:58:49+09:00",
  "dateModified": "2025-01-15T21:58:49+09:00",
  "author":{
    "@type": "Person",
    "name": "nyuusen"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "nyuusen blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="nyuusen blog (Alt + H)">nyuusen blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      AWS設計スキルアップガイド
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="35" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h1>
    <div class="post-meta"><span title='2025-01-15 21:58:49 +0900 JST'>January 15, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;nyuusen

</div>
  </header> 
  <div class="post-content"><p><a href="https://gihyo.jp/book/2023/978-4-297-13649-9">AWS設計スキルアップガイド ――サービスの選定から、システム構成、運用・移行の設計まで：書籍案内｜技術評論社</a></p>
<h2 id="2クラウドのインフラ設計">2.クラウドのインフラ設計<a hidden class="anchor" aria-hidden="true" href="#2クラウドのインフラ設計">#</a></h2>
<h3 id="クラウドで考えるセキュリティ">クラウドで考えるセキュリティ<a hidden class="anchor" aria-hidden="true" href="#クラウドで考えるセキュリティ">#</a></h3>
<ul>
<li>万が一の事故や障害が発生したときに「責任分界点」を定義しておくことで、責任の所在を明らかにできる</li>
<li>AWSでの「責任共有モデル」では、それぞれの責任について以下のように定義されている
<ul>
<li>AWS: サービスを提供するためのインフラストラクチャ</li>
<li>利用者: 選択したAWSサービスごとの適切なセキュリティを実装し、システムを保護する</li>
</ul>
</li>
<li>AWS SecurityHubを使用することで、横断的にセキュリティの問題を検知することができる</li>
</ul>
<h2 id="3システムの構成">3.システムの構成<a hidden class="anchor" aria-hidden="true" href="#3システムの構成">#</a></h2>
<ul>
<li>AWSでシステムを構築する時にまず考えるべきは「アカウントをどの単位で発行するか」</li>
</ul>
<h3 id="awsアカウントの運用例">AWSアカウントの運用例<a hidden class="anchor" aria-hidden="true" href="#awsアカウントの運用例">#</a></h3>
<ul>
<li>単一のアカウントで運用するケース
<ul>
<li>注意ポイント
<ul>
<li>VPCをプロジェクトや環境ごとに分離する</li>
<li>プロジェクトや環境がわかるようにタグを活用する</li>
<li>VPCに関連のないサービスを使用する場合、IAMで権限を設定する</li>
</ul>
</li>
<li>管理する請求先が1つになるメリットはあるが、誤操作等によるミスや事故リスクが上がるので、<strong>できればアカウントは分けて運用するのが良い</strong></li>
</ul>
</li>
<li>複数のアカウントで運用するケース
<ul>
<li>アカウントの統制を考慮する
<ul>
<li>AWS ControlTowerで一元管理</li>
<li>Organizationで多数のAWSアカウントを管理</li>
</ul>
</li>
<li>ログインIDの統合を検討する(1つのユーザーアカウントで各AWSアカウントにログインできるようにする)
<ul>
<li>各環境のIAMロールで行う方法</li>
<li>AWS IAM Identity Center (SSO)を活用する方法</li>
<li>サードパーティIDaaSを活用する方法</li>
</ul>
</li>
</ul>
</li>
<li>(追記)
<ul>
<li>AWS ControlTowerを利用すると、マルチアカウント環境を一元的に整備してくれる</li>
<li>参考: <a href="https://aws.amazon.com/jp/blogs/startup/multi-accounts-and-control-tower/">スタートアップにおけるマルチアカウントの考え方と AWS Control Tower のすゝめ | AWS Startup ブログ</a></li>
</ul>
</li>
</ul>
<h3 id="iam">IAM<a hidden class="anchor" aria-hidden="true" href="#iam">#</a></h3>
<ul>
<li>認証はIAMユーザー、認可はIAMポリシーで設定する
<ul>
<li>通常、ポリシーはグループもしくはロールに付与する</li>
<li>なぜなら、ユーザーにポリシーをアタッチすると、運用工数がかかる</li>
</ul>
</li>
</ul>
<h4 id="iamポリシー設計">IAMポリシー設計<a hidden class="anchor" aria-hidden="true" href="#iamポリシー設計">#</a></h4>
<ul>
<li>デフォルトはすべて拒否なので、明示的に許可していく
<ul>
<li>どのリソース(Resource)に対して、どんな条件で(Conditions)、どんな動作(Action)を、許可/拒否する(Effect)かをJSONもしくはGUIで記述(選択)する</li>
</ul>
</li>
<li>ポリシーはいくつか種類がある(使用頻度が高いものを抜粋)
<ul>
<li>アイデンティティベースのポリシー
<ul>
<li>アイデンティティ(ユーザー、グループ、ロール)にアタッチする</li>
<li>この中にも再利用可能な管理ポリシーとインラインポリシーが存在(管理ポリシー推奨)</li>
</ul>
</li>
<li>リソースベースのポリシー
<ul>
<li>S3などのリソースにアタッチする</li>
</ul>
</li>
<li>セッションポリシー
<ul>
<li>一時的にセッション単位でアクセスを許可するポリシー</li>
<li>AssumeRoleなどのAPIを利用する</li>
</ul>
</li>
</ul>
</li>
<li>ポリシー評価について
<ul>
<li>以下の順番で評価される
<ul>
<li><img alt="image" loading="lazy" src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/swx-yamasaki/20220227/20220227092451.png">
<ul>
<li>画像引用元: <a href="https://blog.serverworks.co.jp/iam/policy/evaluation-logic">【入門編】AWSにおけるアクセスポリシーの評価ロジックを整理してみる</a></li>
</ul>
</li>
</ul>
</li>
<li>明示的な拒否があれば、その拒否設定が適用される
<ul>
<li>拒否設定の後に、明示的な許可設定があったとしても、拒否設定が優先的に適用される</li>
</ul>
</li>
<li>明示的な許可があれば許可となるが、なかった場合は暗黙的に拒否される</li>
</ul>
</li>
</ul>
<h2 id="4ネットワーク設計">4.ネットワーク設計<a hidden class="anchor" aria-hidden="true" href="#4ネットワーク設計">#</a></h2>
<h3 id="オンプレミスとの比較">オンプレミスとの比較<a hidden class="anchor" aria-hidden="true" href="#オンプレミスとの比較">#</a></h3>
<ul>
<li>オンプレミスと比較すると、AWSにおけるネットワーク設計はある程度ざっくりでOK
<ul>
<li>名前解決
<ul>
<li>オンプレミス: 内部DNSを立てるか各サーバーのhostsファイルを利用して名前解決を行う</li>
<li>AWS: 自動でパブリックのDNS名が割り当てられ、マネージドのDNSで名前解決を行う</li>
</ul>
</li>
<li>時刻同期
<ul>
<li>オンプレミス: システム内の時刻が同期するように同一のNTPサーバーを割り当てる</li>
<li>AWS: AmazonTimeSyncServiceで同期する(インターネット接続不要)
<ul>
<li>マネージドNTP</li>
<li>VPCで実行されているすべてのインスタンスの 169.254.169.123 IPアドレスで NTP を介して利用できる</li>
<li>最新バージョンのAmazonLinux2とAmazonLinuxAMIはデフォルトでAmazonTimeSyncServiceと同期してくれている
<ul>
<li>LambdaやECS on Fargate等のマネージドサービスではAWS側で時刻同期されているはずとのこと</li>
<li><a href="https://repost.aws/questions/QUvug7LNsXTQacKVF-AFT9lw/aws%E3%83%9E%E3%83%8D%E3%83%BC%E3%82%B8%E3%83%89%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%81%AE%E6%99%82%E5%88%BB%E5%90%8C%E6%9C%9F%E3%81%AFaws%E5%81%B4%E3%81%A7%E8%A1%8C%E3%82%8F%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%81%AE%E3%81%8B">AWSマネージドサービスの時刻同期はAWS側で行われているのか | AWS re:Post</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="vpcとサブネット">VPCとサブネット<a hidden class="anchor" aria-hidden="true" href="#vpcとサブネット">#</a></h3>
<ul>
<li>VPCはリージョンごとのサービスなので、リージョンを跨ぐことはできない</li>
<li>サブネットではいくつかのIPアドレスがAWSの予約枠として確保されている
<ul>
<li>ネットワークアドレス (最初のIPアドレス)
<ul>
<li>例: 10.0.0.0/24サブネットの場合、10.0.0.0がこのアドレスです。</li>
<li>役割: ネットワーク自体を表すためのアドレスであり、ルーティングやネットワーク構成で使用されます。</li>
</ul>
</li>
<li>VPCルーター (2番目のIPアドレス)
<ul>
<li>例: 10.0.0.1がこのアドレスとなります（サブネットによって異なる場合もあり）。</li>
<li>役割: サブネット内での通信を管理する仮想ルーターです。インスタンス間の通信やインターネットゲートウェイ、VPN接続の経路制御など、サブネット内のルーティングに使用されます。</li>
</ul>
</li>
<li>DNSサーバー (3番目のIPアドレス)
<ul>
<li>例: 10.0.0.2です。</li>
<li>役割: AWSが提供するDNSリゾルバーのIPアドレスです。VPC内のインスタンスがDNSクエリを行う際に使用します。独自のカスタムDNS設定を行わない限り、このアドレスがデフォルトでDNSリゾルバーとして機能します。</li>
</ul>
</li>
<li>将来の用途のために予約されたアドレス (4番目のIPアドレス)
<ul>
<li>役割: 現時点で特定の用途が明確には指定されていませんが、AWSが今後の機能拡張や内部用途のために予約しています。</li>
</ul>
</li>
<li>ブロードキャストアドレス (最後のIPアドレス)
<ul>
<li>例: 10.0.0.255/24サブネットの場合、10.0.0.255がこのアドレスです。</li>
<li>役割: ブロードキャスト通信のために予約されていますが、AWSのVPCではブロードキャスト通信はサポートされていないため、実際に使用することはありません。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="セキュリティグループネットワークaclaws-network-firewall">セキュリティグループ・ネットワークACL・AWS Network Firewall<a hidden class="anchor" aria-hidden="true" href="#セキュリティグループネットワークaclaws-network-firewall">#</a></h3>
<ul>
<li>AWS Network Firewallは有料なのであまり使われない</li>
<li>セキュリティグループ(SG)→ネットワークACLと、フィルタの範囲を狭めて、シンプルな構成・運用にする</li>
<li>SGは、同一SGに所属しているノード同士の通信でも明示的に許可する必要がある</li>
</ul>
<h3 id="ルートテーブル">ルートテーブル<a hidden class="anchor" aria-hidden="true" href="#ルートテーブル">#</a></h3>
<ul>
<li>ルートテーブルは複数のサブネットで共有可能</li>
<li>サブネット作成時にルートテーブルも作成され、追加の設定なくVPC内の通信は可能
<ul>
<li>デフォルトで、VPC内の全てのサブネットに向けたローカルルートが設定されているため</li>
<li>ということは、同じVPC内のサブネットに存在するリソース間で通信を拒否したい場合は、セキュリティグループで設定する必要がある</li>
</ul>
</li>
</ul>
<h3 id="vpcエンドポイント">VPCエンドポイント<a hidden class="anchor" aria-hidden="true" href="#vpcエンドポイント">#</a></h3>
<ul>
<li>異なるVPCやリージョンに配置されたAWSサービスへインターネットを経由せずに接続するサービス</li>
<li>ゲートウェイエンドポイント
<ul>
<li>ルートテーブルでAWSサービスへのルートを指定</li>
<li>費用かからない</li>
</ul>
</li>
<li>インターフェイスエンドポイント
<ul>
<li>VPCのプライベートIPアドレスを使用してアクセスする</li>
<li>ENIとしてVPC内に配置され、それがサービスに接続するためのエンドポイントとして動作する</li>
<li>処理するデータ量に応じて課金される</li>
</ul>
</li>
<li>例えばS3は、どちらでも接続可能だが、インターフェイスエンドポイントの方がセキュリティグループでトラフィックを制御できるため、セキュアである
<ul>
<li>VPC内のリソースがエンドポイントに対して、どのように通信できるかを詳細に制御ができるため、という意味(IPやプロトコル等の制限が可能)</li>
</ul>
</li>
</ul>
<h3 id="vpcフローログ">VPCフローログ<a hidden class="anchor" aria-hidden="true" href="#vpcフローログ">#</a></h3>
<ul>
<li>VPC内のネットワークインターフェースに流れる情報をキャプチャし、ログに記録する</li>
<li>監査に必要なログを出力したり、通信がうまく通らない場合はトラブルシューティングとして出力したり</li>
<li>フローログは以下の3つの項目を指定する
<ol>
<li>フローログを取得するリソース(VPC/サブネット/ENIをもつELBやNATGateway等)</li>
<li>どんなトラフィックをキャプチャするか(許可、拒否、全て)</li>
<li>フローログの出力先(CloudWatch Logs/S3)</li>
</ol>
</li>
</ul>
<h3 id="awsにセキュアに接続する">AWSにセキュアに接続する<a hidden class="anchor" aria-hidden="true" href="#awsにセキュアに接続する">#</a></h3>
<ul>
<li>AWS Client VPN</li>
<li>サイト間VPN</li>
<li>Direct Connect</li>
</ul>
<h2 id="5コンピューティング">5.コンピューティング<a hidden class="anchor" aria-hidden="true" href="#5コンピューティング">#</a></h2>
<h3 id="lambda">Lambda<a hidden class="anchor" aria-hidden="true" href="#lambda">#</a></h3>
<ul>
<li>イベント駆動型のアプリケーションで使いやすい</li>
<li>コールドスタートにかかる時間を短くする方法
<ul>
<li>VPC内にアクセスしない(ENI作成に10〜30秒かかるため)
<ul>
<li>VPC Lambdaと呼ばれてるやつ</li>
<li>Lambdaをパブリックサブネットに配置するとENIが作成されアタッチされる</li>
<li>そのENIに対し、パブリックIPを付与(アドレス関連付け)してやれば、Lambdaからアウトバウンドの通信ができるらしい</li>
</ul>
</li>
<li>メモリ増やす(メモリ量に比例してCPUも増加する)</li>
<li>コード量を短くする
<ul>
<li>関数の初期化や依存解決の速度の向上が見込まれるため</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="lambdaのセキュリティ">Lambdaのセキュリティ<a hidden class="anchor" aria-hidden="true" href="#lambdaのセキュリティ">#</a></h4>
<ul>
<li>IAMを最小限にする
<ul>
<li>特定の条件下で特定のリソースに対して実行できるアクションのみ定義する</li>
<li>基本的には複数のLambda関数でIAMロールで共有しない</li>
</ul>
</li>
</ul>
<h4 id="lambdaの監視">Lambdaの監視<a hidden class="anchor" aria-hidden="true" href="#lambdaの監視">#</a></h4>
<ul>
<li>Lambda関数をデプロイすると自動でCloudWatch Logsと連携する＋レイテンシやエラー率などのメトリクスも自動で発行する
<ul>
<li>エラーを検知できるようにアラートを設定しておくと良い</li>
<li>特にDuration(所要時間)やThrottles(同時実行上限を超えて制限した数)は、エラーが発生する前に適切検知できるようにしておく</li>
</ul>
</li>
</ul>
<h3 id="ec2">EC2<a hidden class="anchor" aria-hidden="true" href="#ec2">#</a></h3>
<ul>
<li>インスタンスタイプの書式
<ul>
<li><a href="https://docs.aws.amazon.com/ja_jp/ec2/latest/instancetypes/instance-type-names.html">Amazon EC2 インスタンスタイプの命名規則 - Amazon EC2</a></li>
<li>オプション
<ul>
<li>コンピューティング最適化: CPU大きめ</li>
<li>メモリ最適化: メモリ大きめ</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="ami">AMI<a hidden class="anchor" aria-hidden="true" href="#ami">#</a></h4>
<ul>
<li>インスタンス起動するのに必要なOSやボリューム・アプリケーションを含むテンプレート</li>
<li>OSのライセンス費用はEC2の利用料金に含まれている(オンプレと異なる点であり、メリットである)</li>
</ul>
<h4 id="インスタンスの費用削減">インスタンスの費用削減<a hidden class="anchor" aria-hidden="true" href="#インスタンスの費用削減">#</a></h4>
<ul>
<li>リザーブドインスタンス
<ul>
<li>時間単位の費用を削減できる</li>
<li>1年や3年の長期使用を約束する</li>
<li>インスタンスクラスの変更しない場合、または負荷増加の際にオンデマンドインスタンスやスポットインスタンスで対応できる場合に検討する</li>
<li>実際の使用有無に関わらず、購入した条件に応じた期間の費用が発生する</li>
</ul>
</li>
<li>SavingsPlans
<ul>
<li>これも1年や3年の長期使用を約束する</li>
<li>リザーブドインスタンスとの違いは、LambdaやFargateでも使用可能である点、インスタンスファミリーやプラットフォームなどを指定しなくて良い
<ul>
<li>逆にRDSやElasiCacheでは使用できないので注意</li>
</ul>
</li>
<li>3種類がある</li>
<li>インスタンスタイプや構成を柔軟に変更する予定がある場合は、SavingsPlansを検討する</li>
</ul>
</li>
<li>スポットインスタンス
<ul>
<li>AWSクラウド内の使用されていないEC2キャパシティを活用し、中断される可能性がある</li>
<li>なので、本番環境で常時起動するサーバーではなく、ECS実行環境やCICDのビルド環境、バッチに適用する</li>
<li>本番環境で適用する場合は、AutoScalingグループでオンデマンドインスタンスとスポットインスタンスの割合を指定する等して、中断が影響しないようにする
<ul>
<li>中断の2分前にAWSから警告が来るので、アプリケーションの安全な停止や、ログの退避などは自動で対応できるように実装する</li>
<li>インスタンスメタデータで中断対象か確認できる
<ul>
<li>インスタンスメタデータを取得できるAPIがあるっぽい</li>
<li>そこを定期的に叩くことで確認</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="t系インスタンスの注意点">T系インスタンスの注意点<a hidden class="anchor" aria-hidden="true" href="#t系インスタンスの注意点">#</a></h4>
<ul>
<li>汎用のT系はM系よりも安価でありよく選定されるが、バーストパフォーマンスインスタンスであることは十分に理解が必要</li>
<li>バーストパフォーマンスインスタンスとは
<ul>
<li>ベースラインと呼ばれるCPU使用率がある</li>
<li>そのベースラインに対して、下回る間はクレジットを獲得し、超える間は消費する
<ul>
<li>1CPUクレジット=1vCPU×100%使用率×1分</li>
<li>つまり、1vCPUを50%使用率で2分使用すると、1クレジット消費するということ</li>
</ul>
</li>
<li>24時間の間で、獲得したクレジットよりも消費するクレジットが多い場合に、その分のvCPU費用が発生する</li>
<li>T系インスタンスの各タイプで、1時間あたりに受け取るクレジットや蓄積可能なクレジット、ベースライン使用率は決められている</li>
</ul>
</li>
<li>CPUクレジットの消費タイプには以下の2種類がある
<ul>
<li>Standard: 残高が0になると、ベースライン使用率以下でのみ使用可能となる</li>
<li>Unlimited: Standardのような制約はない代わりに、CPUクレジットが0になった後は、vCPU時間ごとに均一追加料金が発生する（他のインスタンスタイプの利用料金を超える可能性がある）</li>
</ul>
</li>
<li>重要なのは、CPU使用率を監視すること
<ul>
<li>CloudWatchメトリクスで参照可能</li>
<li><a href="https://docs.aws.amazon.com/ja_jp/AWSEC2/latest/UserGuide/burstable-performance-instances-monitoring-cpu-credits.html">バーストインスタンスの CPU クレジットをモニタリングする - Amazon Elastic Compute Cloud</a></li>
</ul>
</li>
<li>参考: <a href="https://aws.amazon.com/jp/blogs/startup/burstable-performance-instances/">バーストパフォーマンス(T系)インスタンスの特徴を理解して上手に利用しよう | AWS Startup ブログ</a></li>
</ul>
<h3 id="コンテナ">コンテナ<a hidden class="anchor" aria-hidden="true" href="#コンテナ">#</a></h3>
<ul>
<li>仮想化とコンテナの違い
<ul>
<li>ゲストOSの有無が大きな違い</li>
<li>仮想化はホストOSを介して、ハードウェアを制御するため、オーバーヘッドが大きい</li>
<li>コンテナは、アプリケーションの動作環境を隔離していて、カーネルはホストOSに依存するため、仮想化のように複数の異なるOSを稼働させることはできないが、逆に言えばOSがない分起動が早く、使用するリソースも少なくて済む</li>
</ul>
</li>
</ul>
<h4 id="コンテナとec2の違い">コンテナとEC2の違い<a hidden class="anchor" aria-hidden="true" href="#コンテナとec2の違い">#</a></h4>
<ul>
<li>EC2上でコンテナを実行するのと、ECSやEKSなどのオーケストレーションツールを使用するのとでどのような違いがあるのかという問いと同義</li>
<li>EC2上で動かした場合、デプロイする時は、EC2アプリケーションを更新→AMIを取得→AutoScaling対象のAMIを変更するという、とても面倒な手作業が発生する
<ul>
<li>逆にロールバックの作業も面倒..</li>
<li>加えて、OS更新等の手作業も発生する</li>
</ul>
</li>
<li>一方、ECSの場合は、コンテナやOSの障害や更新をAWS側が管理してくれる
<ul>
<li>CI/CDパイプラインを構築すれば、アプリケーション変更から適用まで迅速に行える</li>
<li>コンテナがプロセス落ちを管理し、再度デプロイしてくれる(Serviceがやっていることかな？)</li>
</ul>
</li>
</ul>
<h4 id="コンテナを構成するサービスの特徴">コンテナを構成するサービスの特徴<a hidden class="anchor" aria-hidden="true" href="#コンテナを構成するサービスの特徴">#</a></h4>
<ul>
<li>複数の環境を有するシステム
<ul>
<li>再現性が高い特徴を活かせる</li>
</ul>
</li>
<li>更新頻度が高いシステム</li>
<li>アクセス増減の発生が高いシステム</li>
<li>もはやこのご時世的にはあえてEC2を選択するケースはないのではと思う</li>
</ul>
<h4 id="コンテナサービスを作るときに気をつけること">コンテナサービスを作るときに気をつけること<a hidden class="anchor" aria-hidden="true" href="#コンテナサービスを作るときに気をつけること">#</a></h4>
<ul>
<li>障害発生することを前提とする
<ul>
<li>プロセスが落ちても、すぐに起動できるように</li>
<li>ECS Serviceを使えという話だと思う</li>
</ul>
</li>
<li>環境差異は変数化する</li>
<li>ログ出力を1本化する
<ul>
<li>コンテナは実行環境であるホストOS上でプロセスとして動作し、他のプロセスから隔離されている</li>
<li>コンテナ内部でアプリケーションログを吐いても、プロセス停止した際などにログが残らなくなってしまう</li>
<li>ホストOSか別の領域に出力するように設定する
<ul>
<li>ちょっと調べた感じ、タスク定義でログドライバにawslogsを設定し、ロググループなども設定すれば、1つのロググループに出力されるようになるっぽい</li>
</ul>
</li>
</ul>
</li>
<li>1コンテナ1プロセスとする
<ul>
<li>1つのコンテナに複数のプロセスを稼働させることも可能だが、制御が難しいため</li>
</ul>
</li>
</ul>
<h4 id="amazon-ecs">Amazon ECS<a hidden class="anchor" aria-hidden="true" href="#amazon-ecs">#</a></h4>
<ul>
<li>ECSの構成要素
<ul>
<li>クラスター：実行環境</li>
<li>タスク定義：指定のコンテナを動かす</li>
<li>サービス：全体の構成やデプロイ方法を設定</li>
</ul>
</li>
<li>タスク定義
<ul>
<li>主な設定項目
<ul>
<li>Dockerイメージ</li>
<li>コンテナのCPUとメモリ</li>
<li>データボリューム</li>
<li>IAMロール</li>
<li>コンピューティング環境(EC2 or Fargate)</li>
</ul>
</li>
</ul>
</li>
<li>サービス
<ul>
<li>主な設定項目
<ul>
<li>連携するELBを指定</li>
<li>指定したタスク定義のタスク数</li>
<li>デプロイ方法(Blue/Green,ローリングアップデート)</li>
<li>実行環境(EC2,Fargate)で待ち受けるポートや、コンテナ側で待ち受けるポートも指定する</li>
</ul>
</li>
<li>サービスはなくても動くけど、AutoScalingの実装等に必要</li>
</ul>
</li>
<li>クラスター
<ul>
<li>主な設定項目
<ul>
<li>コンテナ実行環境のネットワークを指定</li>
<li>起動するインスタンスタイプやAMI、その数を指定</li>
</ul>
</li>
<li>Fargateの場合は、ネットワーク作成とクラスター名のみを設定する</li>
</ul>
</li>
</ul>
<h4 id="タスク定義の更新">タスク定義の更新<a hidden class="anchor" aria-hidden="true" href="#タスク定義の更新">#</a></h4>
<ul>
<li>コンテナイメージにつけるタグ名はlatestにするとタスク定義の修正が不要になる一方、コンテナイメージのバージョンがわからないのがで名rっと</li>
<li>デプロイ方法「ローリングアップデート」と「Blue/Greenデプロイメント」がある
<ul>
<li>ローリングアップデートの例
<ul>
<li>DesiredCountを4に、minimumHealthyPercentを0.5に設定した場合、4 * 0.5の2インスタンスが更新されたタスク定義を元に作成される</li>
</ul>
</li>
<li>Blue/Greenデプロイメントの例
<ul>
<li>タスク定義を更新すると、新たにGreen環境が作成あれ、疎通に問題がなければ、LBのレイヤーで切り替えを行う（だからLBが必須）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="データボリューム">データボリューム<a hidden class="anchor" aria-hidden="true" href="#データボリューム">#</a></h4>
<ul>
<li>ログや共通のデータはコンテナ外に領域を確保する</li>
<li>ECSで選択可能なデータボリュームは以下になる
<ul>
<li>EFS</li>
<li>FSx for Windows File Sever</li>
<li>Dockerボリューム
<ul>
<li>EC2のみ利用可能</li>
</ul>
</li>
<li>バインドマウント
<ul>
<li>ホスト上のファイルやディレクトリをコンテナからマウントする</li>
</ul>
</li>
<li>Fargate タスクエフェメラルストレージ
<ul>
<li>エフェメラルストレージ=一時的なストレージ</li>
<li>プロビジョニング時にECSタスクが受け取るもの</li>
<li>これらをマウントし、タスク定義内でvolumes、mountPointsおよびvolumesFromパラメータを使用しているコンテナ間で共有することが可能</li>
</ul>
</li>
<li><a href="https://docs.aws.amazon.com/ja_jp/AmazonECS/latest/developerguide/using_data_volumes.html">Amazon ECS タスクのストレージオプション - Amazon Elastic Container Service</a></li>
</ul>
</li>
</ul>
<h2 id="6データベース">6.データベース<a hidden class="anchor" aria-hidden="true" href="#6データベース">#</a></h2>
<h3 id="データベースの選択">データベースの選択<a hidden class="anchor" aria-hidden="true" href="#データベースの選択">#</a></h3>
<ul>
<li>どんな用途なのかと移行か新規なのか、複数の観点からの検討が必要</li>
</ul>
<h3 id="rds">RDS<a hidden class="anchor" aria-hidden="true" href="#rds">#</a></h3>
<ul>
<li>EC2同様に仮想サーバー上で実行される</li>
<li>EC2でもDBの構築は可能だが、RDSと異なり自動スケーリングや高可用性、OS・DBソフトウェアのパッチ適用などはユーザーが設計・実装・運用する必要がある
<ul>
<li>逆に、その辺りを自前で管理したい・RDSでサポートされていないパラメータをチューニングしたい・開発環境などで費用削減をしたいという場合はEC2でのDB構築が選択肢になる</li>
</ul>
</li>
<li>リクエストのI/Oサイズやアクセスパターンにより、パフォーマンスが大きく変わる
<ul>
<li>シーケンシャルなアクセスでは、最大I/Oサイズに達するまで、単一のI/O操作に含められる</li>
<li>ランダムなアクセスでは、最大I/Oサイズに達しない小さいサイズでも、IOPSに個別カウントする
<ul>
<li>つまりランダムアクセスの場合はIOPSの消費が多いので、それを考慮してインスタンスクラスなどを決めようという話</li>
</ul>
</li>
</ul>
</li>
<li>パフォーマンスは、DBで最も重要な非機能要件になるので、机上確認だけでなく、実際に検証したり、CloudWatchメトリクスで確認したりして、ストレージタイプを選ぶと良い</li>
</ul>
<h4 id="マルチaz構成">マルチAZ構成<a hidden class="anchor" aria-hidden="true" href="#マルチaz構成">#</a></h4>
<ul>
<li>サポートされている機能は、リージョンやデータベースエンジンによって異なる</li>
<li>マルチAZデプロイすると、Read/WriteできるプライマリDBインスタンスとフェイルオーバー先となるスタンバイレプリカ(読み取り書き込みはできない)が別AZへデプロイされる</li>
<li>スタンバイレプリカは通常時は動作せず、プライマリに障害が発生した時にレプリカが昇格する</li>
<li>フェイルオーバーは60〜120秒</li>
</ul>
<h4 id="マルチazdbクラスタ">マルチAZ DBクラスタ<a hidden class="anchor" aria-hidden="true" href="#マルチazdbクラスタ">#</a></h4>
<ul>
<li>1つの読み取り/書き込みインスタンスと、2つ以上の読み取り専用スタンバイDBインスタンスで構成</li>
<li>読み取り/書き込みインスタンスに障害が発生したら、読み取り専用スタンバイDBインスタンスが昇格</li>
<li>書き込み専用DBインスタンス接続するクラスタエンドポイントと、読み取り専用に接続するリーダーエンドポイントがある
<ul>
<li>エンドポイントは、クラスタ内の対象インスタンスに接続できない場合に自動的に接続先を変更する</li>
</ul>
</li>
<li>フェイルオーバーは35秒未満</li>
</ul>
<h3 id="rds-proxy">RDS Proxy<a hidden class="anchor" aria-hidden="true" href="#rds-proxy">#</a></h3>
<ul>
<li>RDSでは、アプリケーションからの接続を処理する際にメモリやCPUを消費する</li>
<li>頻繁に短時間でDB接続を繰り返すアプリケーションでは、DBの処理負荷を下げるためRDS Proxyを導入すると良い</li>
<li>RDSの最大接続数はパラメータグループのmax_connectionsで定義されており、手動変更は推奨されていない</li>
<li>そのため、同時接続数が上限に達しそうな場合は、上位のインスタンスクラスorRDS Proxyを検討する</li>
<li>RDS Proxyの特徴
<ul>
<li>フルマネージドサービス</li>
<li>アプリケーションとRDSの間に設置</li>
<li>VPC内の異なるAZにある2サブネットを選択して作成</li>
<li>RDS Proxyを間に配置することによる遅延は5ミリ秒程度</li>
<li>RDSのインスタンスレベルを上げずに済むので、コストや運用工数を抑えられる</li>
</ul>
</li>
<li>RDS Proxyを採用するメリット
<ul>
<li>フェイルオーバーにかかる時間を短縮できる
<ul>
<li>数秒レベルでフェイルオーバーが完了する</li>
<li>RDS Proxyがない場合は、スタンバイの昇格とクラスタエンドポイントの更新後にアプリケーションが再接続するのに比べて、RDS Proxyがある場合はアプリケーションからの接続をプールし、RDS ProxyからRDSへの接続は処理中であったものを除いて保持・再利用するため
<ul>
<li>この箇所ちょっと引っかかったので調べてみた。</li>
<li>RDS Proxyの使用有無で、RDS側のフェイルオーバーにかかる時間は変わらないと思う</li>
<li>ただし、アプリケーションの視点で見た時に、RDS Proxyへのコネクションを再確立する必要がない
<ul>
<li>RDS ProxyーRDS間のコネクションの再確立のみで不要</li>
<li>なので、アプリケーション側からすると、再接続するオーバーヘッドがかからないので、フェイルオーバーにかかる時間を短縮できると表現されていると思われる(RDS側のDNS更新も待つ必要もない)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>RDS Proxyを利用する際の注意点
<ul>
<li>IPアドレスの枯渇
<ul>
<li>IPアドレスを消費するのは、RDS Proxy-RDSの接続
<ul>
<li>RDS Proxy-RDSは、同じVPC内で通信するため、プライベートIPアドレスを使用する</li>
<li>RDS Proxyは、接続先RDSのインスタンスクラスと台数に応じて自動的に容量を増減し、場合によっては多くのIPアドレスを利用する</li>
</ul>
</li>
<li>IPアドレスが枯渇するとうまくスケールができず、クエリ遅延やコネクション失敗が発生することがある</li>
<li>インスタンスクラスごとに確保すべき最小IPアドレス数が定められている</li>
<li>回避する方法としては、サブネットのIPアドレス範囲を広くすることが推奨される</li>
</ul>
</li>
<li>セッション固定（ピン止め）による影響
<ul>
<li>特定のトランザクションやセッションが接続プール内の特定のバックエンド(DB)接続に固定される状態を指す</li>
<li>この状態になってしまうと、通常共有可能な接続が他のリクエストに再利用されなくなり、DBへの同時接続数が増え続け、最終的にはDB接続が行えなくなる可能性がある</li>
<li>CloudWatchメトリクスの「DatabaseConnectionsCurrentlySessionPinned」を監視すると良い</li>
<li>ピン留め発生が想定されるケース
<blockquote>
<ol>
<li>ステートフルなリクエスト
ユーザーセッションに依存する処理が行われる場合、同じバックエンド接続を使用し続ける必要があります。
例: 一時テーブルやユーザー固有の設定を使用したクエリ。</li>
<li>特定のSQL機能の使用
以下のような機能を使用すると、接続が固定されることがあります：
セッション変数: SET SESSION を使用してカスタム設定を適用。
一時テーブル: セッション固有のデータを保持。
ユーザー定義関数（UDF）: セッションスコープで動作する関数。
ロック操作: セッションスコープのロック（例: GET_LOCK()）。</li>
<li>トランザクション管理
トランザクション内で複数のクエリが実行される場合、トランザクションの一貫性を保つため、同じ接続を使い続ける必要があります。</li>
</ol></blockquote>
</li>
<li>逆に、接続と破棄を繰り返すLambda関数等の使用であれば、この問題は発生しないも？</li>
</ul>
</li>
</ul>
</li>
<li>目を通した導入事例とか
<ul>
<li><a href="https://bftnagoya.hateblo.jp/entry/2022/03/28/094806">【AWS】RDSのインスタンスタイプを上げたらRDS ProxyのENIがDBサブネットのIPを食い尽くした話 - BFT名古屋 TECH BLOG</a></li>
<li><a href="https://devblog.thebase.in/entry/2022/05/26/180000">Amazon RDS Proxy が BASE にもたらした期待以上の導入メリット - BASEプロダクトチームブログ</a></li>
</ul>
</li>
</ul>
<h3 id="aurora">Aurora<a hidden class="anchor" aria-hidden="true" href="#aurora">#</a></h3>
<ul>
<li>Auroraを利用すると、簡単にレプリケーションやクラスタの設定が可能</li>
<li>Auroraの構成
<ul>
<li>1つ以上のインスタンスと1つのクラスタボリューム</li>
<li>インスタンスには読み取り/書き込みを行うプライマリと読み取りのみをサポートするレプリカ</li>
</ul>
</li>
<li>RDSでAurora以外のエンジンを使用している場合との比較
<ul>
<li>インスタンスとストレージが分離している点が大きく異なる</li>
<li>AuroraはRDSにまたがる分散ストレージにより、バックアップや復旧がRDSより高速</li>
<li>RDSより割高なイメージがあるが、構成と運用次第でRDSよりも費用を抑えられる</li>
</ul>
</li>
<li>Auroraのバージョン
<ul>
<li>MySQLやPostgreSQLのコミュニティバージョンに対応した独自のAuroraバージョン</li>
<li>major.minor.patchの構成</li>
<li>マイナーとパッチは自動アップグレードも可能</li>
<li>アップグレードにはDBの停止を伴うことを想定する</li>
<li>コミュニティサポート期限が切れると現行以降のメジャーバージョンに自動アップグレードされてしまうので注意</li>
</ul>
</li>
<li>レプリケーションとフェイルオーバー
<ul>
<li>レプリケーション
<ul>
<li>プライマリインスタンスに書き込みが発生すると、通常100ミリ秒以下の遅延でレプリカ側でも書き込まれたデータを参照可能になる</li>
<li>レプリカは最大15台をクラスタに組み込めるので、読み込み負荷の高いアプリケーションはAuroraを検討すると良い</li>
<li>複数リージョンにまたがるグローバルデータベースでも、レプリケーションが1秒以内</li>
<li>レプリケーション先にDBインスタンスは不要(クラスタボリュームがあるため)</li>
<li>DR対策としてもAuroraは優位性がある</li>
</ul>
</li>
<li>フェイルオーバー
<ul>
<li>プライマリに障害が発生すると、レプリカが昇格する</li>
<li>フェイルオーバーの開始から終了までは通常30秒以内</li>
<li>なおシングルインスタンス構成の場合は、障害が発生したAZにDBインスタンスを作成しようとする</li>
</ul>
</li>
</ul>
</li>
<li>スケーリング
<ul>
<li>最大128TiBまで容量を自動拡張する
<ul>
<li>拡張時にパフォーマンス影響なし</li>
</ul>
</li>
<li>手動でインスタンスクラスを変更すると、容量だけでなくCPUやメモリもスペックアップ可能だが、サービス停止が発生するので注意</li>
<li>無停止でインスタンスクラスが自動スケールするAuroraServerlessもある</li>
</ul>
</li>
</ul>
<h4 id="auroraserverless">AuroraServerless<a hidden class="anchor" aria-hidden="true" href="#auroraserverless">#</a></h4>
<ul>
<li>ユーザーが事前に設定した範囲で自動スケールアップ</li>
</ul>
<h3 id="dynamodb">DynamoDB<a hidden class="anchor" aria-hidden="true" href="#dynamodb">#</a></h3>
<ul>
<li>フルマネージド型のNoSQLデータベース</li>
<li>DynamoDBの特徴
<ul>
<li>高信頼性
<ul>
<li>リージョン内3AZに同期されるので、高い可用性と耐障害性</li>
</ul>
</li>
<li>高スループット
<ul>
<li>テーブルごとのRead/Writeそれぞれにスループットキャパシティを柔軟に割り当てられる</li>
</ul>
</li>
<li>サーバーレス
<ul>
<li>VPCの設計が不要</li>
<li>事前に設定するキャパシティに基づいて自動スケーリングできる</li>
<li>容量無制限</li>
<li>データのパーティショニングも自動で行われる</li>
</ul>
</li>
</ul>
</li>
<li>整合性モデル
<ul>
<li>DynamoDBはデフォルトで「結果整合性のある読み込み」を行う</li>
<li>DynamoDBでは少なくとも2AZで書き込み完了後、およそ1秒以内にAck(確認応答)を返す</li>
<li>書き込み後1秒の間にアクセスした際のデータ不整合を許容できる場合はデフォルトのままで良い</li>
<li>「強力な整合性のある読み込み」をするには、DynamoDBへのリクエスト時に「ConsistentReadパラメータ」を付与する(追加でコストがかかる点に注意)</li>
<li>トランザクション読み込み/書き込みAPIもある</li>
</ul>
</li>
<li>モード
<ul>
<li>実際に使用した分にかかる「オンデマンドキャパシティ」と事前に予測可能な場合に有用な「プロビジョンドキャパシティ」がある</li>
<li>単位や請求内容が異なるので注意</li>
<li>インスタンスを用いるRDSよりは、多くの場合で費用を削減できる</li>
</ul>
</li>
</ul>
<h4 id="dynamodbの設計">DynamoDBの設計<a hidden class="anchor" aria-hidden="true" href="#dynamodbの設計">#</a></h4>
<ul>
<li>以下のプライマリキーが必要
<ul>
<li>パーティションキー(必須)
<ul>
<li>テーブルのアイテムはパーティションという領域に配置される</li>
<li>このパーティションキーの値を元に配置先のパーティションが決定される</li>
</ul>
</li>
<li>ソートキー
<ul>
<li>パーティションキーが同一であるアイテムに対し、並び順を保証するために使用される</li>
</ul>
</li>
</ul>
</li>
<li>この辺り理解甘いから公式ドキュメントを読み込みたい
<ul>
<li><a href="https://docs.aws.amazon.com/ja_jp/amazondynamodb/latest/developerguide/best-practices.html">DynamoDB を使用した設計とアーキテクチャの設計に関するベストプラクティス - Amazon DynamoDB</a></li>
</ul>
</li>
</ul>
<h2 id="7ストレージ">7.ストレージ<a hidden class="anchor" aria-hidden="true" href="#7ストレージ">#</a></h2>
<ul>
<li>大量のデータを保存したい場合：S3</li>
<li>Lambdaや複数のLinux系EC2インスタンスからデータを利用したい場合：EFS</li>
</ul>
<h3 id="ebs">EBS<a hidden class="anchor" aria-hidden="true" href="#ebs">#</a></h3>
<ul>
<li>オンプレミスサーバに例えると、搭載する物理ディスクにあたる</li>
<li>費用は、プロビジョニングされた容量に対して発生するので、インスタンスが停止していても課金されるので注意</li>
</ul>
<h3 id="s3">S3<a hidden class="anchor" aria-hidden="true" href="#s3">#</a></h3>
<ul>
<li>オブジェクトストレージ</li>
<li>インターネットからアクセスを受け付けるS3には適切なセキュリティ対策が必要</li>
</ul>
<h4 id="セキュリティ">セキュリティ<a hidden class="anchor" aria-hidden="true" href="#セキュリティ">#</a></h4>
<ul>
<li>データ保護
<ul>
<li>2023年1月より、S3に追加される全てのオブジェクトにはSSE-S3での暗号化が自動適用されるようになった
<ul>
<li>監査や鍵の一元管理が不要であれば、追加費用かからず管理の手間もないSSE-S3を利用すると良い</li>
</ul>
</li>
</ul>
</li>
<li>アクセスポリシーの全体像
<ul>
<li>リソースベースのポリシーとユーザーベースのポリシーを利用して、リソースへのアクセスを管理できる</li>
<li>リソースベースのポリシー
<ul>
<li>バケットポリシー</li>
<li>バケットアクセスコントロールリスト(ACL)</li>
<li>オブジェクトACL
<ul>
<li>バケットアクセスコントロールリスト(ACL)とオブジェクトACLは、使用する必要がないケースが多い</li>
</ul>
</li>
<li>バケットポリシーとユーザーポリシーで同じ対象に異なるアクセス制限(拒否と許可など)がされている場合は、より厳しい制限が適用されるので注意</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="8アプリーション統合">8.アプリーション統合<a hidden class="anchor" aria-hidden="true" href="#8アプリーション統合">#</a></h2>
<h3 id="amazon-api-gateway">Amazon API Gateway<a hidden class="anchor" aria-hidden="true" href="#amazon-api-gateway">#</a></h3>
<ul>
<li>2種類のAPIが用意されており、RestfulAPIとチャットなどのリアルタイム双方向通信を行うステートフルなWebSocketAPIがある</li>
<li>RestfulAPIには、WAF統合やクライアントごとのスロットリングなどの多機能なREST APIと、機能を絞り費用を抑えたHTTP APIが存在する
<ul>
<li>以下を参考に、要件に対して必要な機能を検討してどちらかを選ぶようにする</li>
<li><a href="https://docs.aws.amazon.com/ja_jp/apigateway/latest/developerguide/http-api-vs-rest.html">REST API と HTTP API のどちらかを選択する - Amazon API Gateway</a></li>
</ul>
</li>
<li>マッピングテンプレートを使用すると、リクエストやレスポンスの整形が可能</li>
<li>トークンバケットアルゴリズムを使用したスロットリング</li>
<li>公式が出しているベストプラクティスもある
<ul>
<li><a href="https://docs.aws.amazon.com/ja_jp/apigateway/latest/developerguide/security-best-practices.html">Amazon API Gateway のセキュリティのベストプラクティス - Amazon API Gateway</a></li>
<li>書かれているのは、最小権限やアクセスログの記録・アラート設定、CloudTrailの有効化など</li>
</ul>
</li>
</ul>
<h3 id="eventbridge">EventBridge<a hidden class="anchor" aria-hidden="true" href="#eventbridge">#</a></h3>
<ul>
<li>EventBridgeの特徴
<ul>
<li>EventBridgeは、様々なAWS内やSaaSアプリケーションのイベントを受信・処理し、ターゲットであるAWSサービスへ渡すイベント駆動型のマネージドサービス</li>
<li>スケジュールをトリガーとしたルール実行も可能</li>
</ul>
</li>
<li>イベントバスの種類
<ul>
<li>イベントバスと呼ばれるパイプラインでイベントを受信する</li>
</ul>
</li>
<li>アクセス制御
<ul>
<li>デフォルトのイベントバスは、操作しているAWSアカウントからのイベントを許可する</li>
<li>各サービスのアクセス制御は、ターゲット側のポリシーで許可するorEventBridgeのルールのIAMロールでポリシーを設定する</li>
</ul>
</li>
</ul>
<h4 id="eventbridgeのルールと入力トランスフォーマー">EventBridgeのルールと入力トランスフォーマー<a hidden class="anchor" aria-hidden="true" href="#eventbridgeのルールと入力トランスフォーマー">#</a></h4>
<ul>
<li>ターゲットは5つまで指定できる</li>
<li>並列実行が可能</li>
<li>DatadogやNewRelic等のサードパーティツールにも統合可能</li>
<li>入力トランスフォーマーでターゲットに渡す情報を編集できる</li>
</ul>
<h4 id="snsやsqsとの使い分け">SNSやSQSとの使い分け<a hidden class="anchor" aria-hidden="true" href="#snsやsqsとの使い分け">#</a></h4>
<ul>
<li>同じイベント駆動型アプリケーションであるSNSやSQSとの使い分けについて</li>
<li>SNSやSQSを使用するケースは以下の通り
<ul>
<li>低レイテンシが求められる</li>
<li>多数のエンドポイントが必要</li>
<li>対人メッセージングに利用(SNSを使うべし)</li>
<li>順序保証が必要</li>
</ul>
</li>
<li>SNS
<ul>
<li>プッシュ方式
<ul>
<li>プロデューサー == ブローカー == コンシューマーという構成でブローカーからコンシューマーへジョブがプッシュされる</li>
</ul>
</li>
</ul>
</li>
<li>SQS
<ul>
<li>プル方式
<ul>
<li>コンシューマー側が能動的にブローカー(キュー)からメッセージを取得する</li>
</ul>
</li>
<li>P2P方式
<ul>
<li>プロデューサーとコンシューマが1：1で連携する方式</li>
</ul>
</li>
</ul>
</li>
<li>EventBridge
<ul>
<li>スケジュール実行・SaaSサービスとの連携・メッセージの加工はEventBridgeにしかない機能</li>
</ul>
</li>
<li>要件に合わせて使い分けることが大切</li>
</ul>
<h2 id="9可用性">9.可用性<a hidden class="anchor" aria-hidden="true" href="#9可用性">#</a></h2>
<ul>
<li>疎結合化の文脈で、システムのつなぎ目に拡張性・耐障害性に優れた機能を配置すると良い
<ul>
<li>例えば、ロードバランサやDNS・メッセージキュー</li>
<li>つなぎ目にはできるだけ非同期処理を行うコンポーネントを配置する
<ul>
<li>EventBridge,SQS,Kinesisシリーズ群,Step Functions</li>
<li>SQS(スタンダードキュー)は、1秒間にほぼ無限にAPIコールを受け付けられるため、可用性は問題にならない</li>
</ul>
</li>
<li>疎結合には、スケールアウトした時に他のコンポーネントへの影響が少ないことや障害発生時の切り分けもしやすいことがメリットになる</li>
</ul>
</li>
</ul>
<h3 id="sla">SLA<a hidden class="anchor" aria-hidden="true" href="#sla">#</a></h3>
<ul>
<li>AWSはSLAを満たせなかった場合、サービスクレジットとして還元される
<ul>
<li>キャッシュバックではなく、今後請求される支払いに対して利用できるもの</li>
<li>契約者は、いくつかの情報を揃えてAWSに提出する必要がある(自動で適用されるものではない点に注意)</li>
</ul>
</li>
</ul>
<h2 id="10セキュリティ">10.セキュリティ<a hidden class="anchor" aria-hidden="true" href="#10セキュリティ">#</a></h2>
<ul>
<li>クラウド事業者の選定
<ul>
<li>ISMAPのクラウドサービスリスト: <a href="https://www.ismap.go.jp/csm?id=cloud_service_list">https://www.ismap.go.jp/csm?id=cloud_service_list</a></li>
</ul>
</li>
<li>Amazon Inspector
<ul>
<li>CIS Benchmarksに沿って、EC2やECRのOSやミドルウェア設定を確認・可視化できる</li>
<li>ベストプラクティスに準拠していない場合はレポート出力される</li>
</ul>
</li>
<li>リスク検出を支援するAWSサービス
<ul>
<li>無料で手軽に：TrustedAdvisor, IAM Access Analyzer</li>
<li>ルールをカスタマイズもできる：AWS Config</li>
<li>それほど料金かからない：SecurityHub</li>
</ul>
</li>
</ul>
<h2 id="11ジョブ管理">11.ジョブ管理<a hidden class="anchor" aria-hidden="true" href="#11ジョブ管理">#</a></h2>
<ul>
<li>バッチ処理を行うシステムをジョブ管理システムという</li>
<li>AWSのジョブ実行に関連するサービスはいくつかある
<ul>
<li>15分以内ならLambdaで実装するのが良い
<ul>
<li>ECS Scheduled TaskやBatchと比較して安価</li>
</ul>
</li>
<li>ECS Scheduled Taskは、EventBridgeでのトリガを元にECSを実行するというもの</li>
</ul>
</li>
</ul>
<h3 id="batch">Batch<a hidden class="anchor" aria-hidden="true" href="#batch">#</a></h3>
<ul>
<li>長時間、高負荷な処理はBatchでの実装を検討すると良い
<ul>
<li>逆に短時間で終わるものや即時実行が必要なジョブには向いていない</li>
</ul>
</li>
<li>Batchはコンテナ環境を使って処理を行うので、注意すべきポイントがいくつかある</li>
<li>Batchの特徴
<ul>
<li>コンポーネント
<ul>
<li>BatchのジョブはECSやEKSのコンテナ上で実行される</li>
</ul>
</li>
<li>スポットインスタンスの活用
<ul>
<li>コストを安くできる反面、発生しうる中断に対してのケアが必要
<ul>
<li>冪等性を考慮したジョブ設計にし、リトライできるようにする</li>
</ul>
</li>
<li>ジョブを短時間で終わるように設計する
<ul>
<li>定期的に結果をS3やEFSに出力するチェックポイント方式にする</li>
</ul>
</li>
<li>ジョブの再試行回数を設定する</li>
<li>実際の設計例では、
<ul>
<li>優先度の高いジョブはオンデマンドに処理させて、そうではないジョブはスポットインスタンスにするとか</li>
<li>スポットインスタンスで失敗したジョブをSNSに通知→Lambdaを経由して、オンデマンド用キュー→オンデマンドインスタンスでジョブを再実行とか方法がある</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="step-functions">Step Functions<a hidden class="anchor" aria-hidden="true" href="#step-functions">#</a></h3>
<ul>
<li>AWSサービスやAPIを組み合わせ、ワークフローを視覚的に作成・実行できるサービス</li>
<li>ワークフロータイプ
<ul>
<li>StandardとExpressがある
<ul>
<li>実行頻度の高い処理を短時間で処理させる場合はExpressを選択する</li>
</ul>
</li>
</ul>
</li>
<li>料金
<ul>
<li>Lambdaよりは割高</li>
<li>状態遷移の回数で課金される</li>
<li>EventBridgeーLambdaの構成であれば無料利用枠内に収まるなんてこともあるので、見積もりを慎重に行う</li>
</ul>
</li>
<li>StepFunctionsはデバッグがしやすい
<ul>
<li>ステートごとに入出力やイベントが見やすかったり</li>
<li>ステートごとにログが時系列でわかりやすく並んでいたりする</li>
</ul>
</li>
</ul>
<h2 id="12バックアップ">12.バックアップ<a hidden class="anchor" aria-hidden="true" href="#12バックアップ">#</a></h2>
<ul>
<li>オンプレでもクラウドでもバックアップの重要性は変わらない</li>
</ul>
<h3 id="awsのバックアップ">AWSのバックアップ<a hidden class="anchor" aria-hidden="true" href="#awsのバックアップ">#</a></h3>
<ul>
<li>EC2
<ul>
<li>Amazon Data Lifecycle Managerで定期的にスナップショットを取得</li>
</ul>
</li>
<li>RDS
<ul>
<li>自動バックアップの有効化、手動バックアップの実行</li>
</ul>
</li>
<li>S3
<ul>
<li>バージョニング有効、ライフサイクル管理</li>
</ul>
</li>
</ul>
<h3 id="aws-backup">AWS Backup<a hidden class="anchor" aria-hidden="true" href="#aws-backup">#</a></h3>
<ul>
<li>フルマネージドなバックアップサービス</li>
<li>最低料金や初期費用が発生しない</li>
<li>バックアップの自動化や保存期間が過ぎたデータなどバックアップに関する一元管理が可能</li>
<li>対象は、AWSリソースのみ</li>
<li>概要
<ul>
<li>バックアッププランを作成し、ルールで指定したスケジュールでバックアップを行う</li>
<li>バックアッププランで、AWSリソースを指定する</li>
</ul>
</li>
<li>想定外にかかる費用
<ul>
<li>簡単に設定できてしまう反面、想定より費用がかかるケースがある</li>
<li>バックアップを一定期間運用した後は、定期的に適切な範囲に収まっているかを確認した方が良い</li>
</ul>
</li>
</ul>
<h2 id="13監視">13.監視<a hidden class="anchor" aria-hidden="true" href="#13監視">#</a></h2>
<ul>
<li>RDS
<ul>
<li>スロークエリなどを出力したい場合は、パラメータグループのlog_outputをFILEにする</li>
</ul>
</li>
<li>VPC
<ul>
<li>VPC内のトラフィック情報をCloudWatch Logsに出力するには、VPCフローログが必要</li>
</ul>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share AWS設計スキルアップガイド on x"
            href="https://x.com/intent/tweet/?text=AWS%e8%a8%ad%e8%a8%88%e3%82%b9%e3%82%ad%e3%83%ab%e3%82%a2%e3%83%83%e3%83%97%e3%82%ac%e3%82%a4%e3%83%89&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f003_aws%25E8%25A8%25AD%25E8%25A8%2588%25E3%2582%25B9%25E3%2582%25AD%25E3%2583%25AB%25E3%2582%25A2%25E3%2583%2583%25E3%2583%2597%25E3%2582%25AC%25E3%2582%25A4%25E3%2583%2589%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share AWS設計スキルアップガイド on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f003_aws%25E8%25A8%25AD%25E8%25A8%2588%25E3%2582%25B9%25E3%2582%25AD%25E3%2583%25AB%25E3%2582%25A2%25E3%2583%2583%25E3%2583%2597%25E3%2582%25AC%25E3%2582%25A4%25E3%2583%2589%2f&amp;title=AWS%e8%a8%ad%e8%a8%88%e3%82%b9%e3%82%ad%e3%83%ab%e3%82%a2%e3%83%83%e3%83%97%e3%82%ac%e3%82%a4%e3%83%89&amp;summary=AWS%e8%a8%ad%e8%a8%88%e3%82%b9%e3%82%ad%e3%83%ab%e3%82%a2%e3%83%83%e3%83%97%e3%82%ac%e3%82%a4%e3%83%89&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2f003_aws%25E8%25A8%25AD%25E8%25A8%2588%25E3%2582%25B9%25E3%2582%25AD%25E3%2583%25AB%25E3%2582%25A2%25E3%2583%2583%25E3%2583%2597%25E3%2582%25AC%25E3%2582%25A4%25E3%2583%2589%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share AWS設計スキルアップガイド on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2f003_aws%25E8%25A8%25AD%25E8%25A8%2588%25E3%2582%25B9%25E3%2582%25AD%25E3%2583%25AB%25E3%2582%25A2%25E3%2583%2583%25E3%2583%2597%25E3%2582%25AC%25E3%2582%25A4%25E3%2583%2589%2f&title=AWS%e8%a8%ad%e8%a8%88%e3%82%b9%e3%82%ad%e3%83%ab%e3%82%a2%e3%83%83%e3%83%97%e3%82%ac%e3%82%a4%e3%83%89">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share AWS設計スキルアップガイド on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2f003_aws%25E8%25A8%25AD%25E8%25A8%2588%25E3%2582%25B9%25E3%2582%25AD%25E3%2583%25AB%25E3%2582%25A2%25E3%2583%2583%25E3%2583%2597%25E3%2582%25AC%25E3%2582%25A4%25E3%2583%2589%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share AWS設計スキルアップガイド on whatsapp"
            href="https://api.whatsapp.com/send?text=AWS%e8%a8%ad%e8%a8%88%e3%82%b9%e3%82%ad%e3%83%ab%e3%82%a2%e3%83%83%e3%83%97%e3%82%ac%e3%82%a4%e3%83%89%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2f003_aws%25E8%25A8%25AD%25E8%25A8%2588%25E3%2582%25B9%25E3%2582%25AD%25E3%2583%25AB%25E3%2582%25A2%25E3%2583%2583%25E3%2583%2597%25E3%2582%25AC%25E3%2582%25A4%25E3%2583%2589%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share AWS設計スキルアップガイド on telegram"
            href="https://telegram.me/share/url?text=AWS%e8%a8%ad%e8%a8%88%e3%82%b9%e3%82%ad%e3%83%ab%e3%82%a2%e3%83%83%e3%83%97%e3%82%ac%e3%82%a4%e3%83%89&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f003_aws%25E8%25A8%25AD%25E8%25A8%2588%25E3%2582%25B9%25E3%2582%25AD%25E3%2583%25AB%25E3%2582%25A2%25E3%2583%2583%25E3%2583%2597%25E3%2582%25AC%25E3%2582%25A4%25E3%2583%2589%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share AWS設計スキルアップガイド on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=AWS%e8%a8%ad%e8%a8%88%e3%82%b9%e3%82%ad%e3%83%ab%e3%82%a2%e3%83%83%e3%83%97%e3%82%ac%e3%82%a4%e3%83%89&u=http%3a%2f%2flocalhost%3a1313%2fposts%2f003_aws%25E8%25A8%25AD%25E8%25A8%2588%25E3%2582%25B9%25E3%2582%25AD%25E3%2583%25AB%25E3%2582%25A2%25E3%2583%2583%25E3%2583%2597%25E3%2582%25AC%25E3%2582%25A4%25E3%2583%2589%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">nyuusen blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
