<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet type="text/xsl" href="http://localhost:1313/xml/base.min.xml" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My New Hugo Site</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 25 Jun 2025 09:47:54 +0900</lastBuildDate>
    <atom:link href="http://localhost:1313/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CloudFrontのキャッシュについて</title>
      <link>http://localhost:1313/posts/cloudfront-cache/</link>
      <pubDate>Wed, 25 Jun 2025 09:47:54 +0900</pubDate>
      <guid>http://localhost:1313/posts/cloudfront-cache/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cloudfront-cache/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;新規システム構築時にキャッシュ戦略を考えたのでまとめる&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;キャッシュする場所&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cloudfront-cache/#%e3%82%ad%e3%83%a3%e3%83%83%e3%82%b7%e3%83%a5%e3%81%99%e3%82%8b%e5%a0%b4%e6%89%80&#34;&gt;キャッシュする場所&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;クライアント(ブラウザ) ---- CDN(CloudFront) ---- オリジンサーバー&lt;/code&gt; という構成の場合、キャッシュする場所としては以下がある。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ブラウザ&lt;/li&gt;&#xA;&lt;li&gt;CloudFront(CDN)&#xA;※オリジンサーバ側にも何らかのキャッシュ機構があるかもしれないが話が逸れるので割愛&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ブラウザキャッシュ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cloudfront-cache/#%e3%83%96%e3%83%a9%e3%82%a6%e3%82%b6%e3%82%ad%e3%83%a3%e3%83%83%e3%82%b7%e3%83%a5&#34;&gt;ブラウザキャッシュ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ブラウザキャッシュは、ブラウザのメモリやストレージにデータを保持する形でキャッシュを実現する。&lt;br&gt;&#xA;どのように、どのくらいキャッシュを行うかは、CloudFrontから返却される&lt;code&gt;Cache-Control&lt;/code&gt;ヘッダの設定値による。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;cloudfrontキャッシュ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cloudfront-cache/#cloudfront%e3%82%ad%e3%83%a3%e3%83%83%e3%82%b7%e3%83%a5&#34;&gt;CloudFrontキャッシュ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;キャッシュポリシーで設定する。キャッシュポリシーはビヘイビアごとに設定が可能。&lt;br&gt;&#xA;ビヘイビアにはパスパターンで対象の拡張子やファイルパスを元に対象を特定し、キャッシュ以外にもリクエスト・レスポンス周りやオリジンの設定が可能。&lt;/p&gt;&#xA;&lt;p&gt;キャッシュポリシーでは、オリジンからCache-Controlが返却された場合、どのように扱う(それを適用する/無視してCloudFrontの設定を使用する等)かも設定できる。&lt;br&gt;&#xA;キャッシュ保持時間を表すTTLには、min,default,maxの項目がある（これがちょっとややこしい..）&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;min: オリジンからの指定有無に関係なく、CloudFrontがキャッシュする最小時間&lt;/li&gt;&#xA;&lt;li&gt;default: オリジンから指定がなかったらこの値が使用される&lt;/li&gt;&#xA;&lt;li&gt;max: オリジンの指定がこの値を超えていた場合に使用される、CloudFrontがキャッシュする最大時間&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;cloudfrontを採用するメリット&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cloudfront-cache/#cloudfront%e3%82%92%e6%8e%a1%e7%94%a8%e3%81%99%e3%82%8b%e3%83%a1%e3%83%aa%e3%83%83%e3%83%88&#34;&gt;CloudFrontを採用するメリット&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテンツの高速配信&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全国にあるエッジサーバーからコンテンツを返却できるので低遅延かつ高速なレスポンスが期待できる（例え日本国内にあったとしても）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;（真偽に100％の自信はないが）S3はディスク保存なのに対し、CloudFrontはメモリor高速なSSDにあると思われるので高速&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;オリジンサーバーの負荷軽減にもつながる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;可用性向上&#xA;&lt;ul&gt;&#xA;&lt;li&gt;オリジンサーバー障害時でもCDNキャッシュにより一部コンテンツの継続提供が可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;セキュリティ強化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HTTPS対応&lt;/li&gt;&#xA;&lt;li&gt;WAF&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;キャッシュ設定を細かく制御できる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CDN上でA/Bテストやコンテンツ切り替えが可能&lt;/li&gt;&#xA;&lt;li&gt;圧縮や画像の自動最適化もサポートされていることが多い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;キャッシュを検討する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cloudfront-cache/#%e3%82%ad%e3%83%a3%e3%83%83%e3%82%b7%e3%83%a5%e3%82%92%e6%a4%9c%e8%a8%8e%e3%81%99%e3%82%8b&#34;&gt;キャッシュを検討する&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;フロントエンド資材&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cloudfront-cache/#%e3%83%95%e3%83%ad%e3%83%b3%e3%83%88%e3%82%a8%e3%83%b3%e3%83%89%e8%b3%87%e6%9d%90&#34;&gt;フロントエンド資材&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;Next.jsのようなJavaScriptフレームワークを使用しており、ビルド資材をS3に格納し、CloudFrontで配信するというような場合の設定例&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;staticファイル:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JSやCSS、publicフォルダにないimage等は、ファイル名にハッシュ値が設定されるのでURLが変わるため、長めの設定で問題ない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;上記以外のhtml,publicフォルダやappディレクトリ直下にあるicon画像等の静的資材:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;上とは異なり、ファイル名が固定値(ex:index.html)であるため、短い時間が安全&lt;/li&gt;&#xA;&lt;li&gt;もしくはno-cacheで毎回新鮮かを問い合わせるとか&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;api&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cloudfront-cache/#api&#34;&gt;API&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;ユーザー固有の情報を返すようなAPIの場合はキャッシュ無効化(no-store)やプライベート化(private)にすべき。&lt;br&gt;&#xA;キャッシュが他のユーザーの情報を返してしまい事故リスクがあるため。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;cache-control&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cloudfront-cache/#cache-control&#34;&gt;Cache-Control&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;以下を見れば全てがわかる!!&lt;br&gt;&#xA;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Cache-Control&#34;&gt;Cache-Control - HTTP | MDN&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;気になった箇所だけちょっと補足&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;privateとno-storeの違い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;private: クライアント側のキャッシュに限定（CDNにはキャッシュしない）&lt;/li&gt;&#xA;&lt;li&gt;no-store: キャッシュを完全に無効化&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;max-ageとs-maxageの違い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;max-age: レスポンスが生成されてから、新鮮である期間を示す（新鮮とみなす＝つまりキャッシュする時間）&lt;/li&gt;&#xA;&lt;li&gt;s-maxage: max-ageと同じ意味だが、これは共有キャッシュ(CDN)特有の値となる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;条件付きリクエストによる再検証&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cloudfront-cache/#%e6%9d%a1%e4%bb%b6%e4%bb%98%e3%81%8d%e3%83%aa%e3%82%af%e3%82%a8%e3%82%b9%e3%83%88%e3%81%ab%e3%82%88%e3%82%8b%e5%86%8d%e6%a4%9c%e8%a8%bc&#34;&gt;条件付きリクエストによる再検証&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;if-modified-since--last-modified&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cloudfront-cache/#if-modified-since--last-modified&#34;&gt;If-Modified-Since + Last-Modified&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;オリジンから&lt;code&gt;Last-Modified&lt;/code&gt;が返却され、キャッシュはそれを保持&lt;/li&gt;&#xA;&lt;li&gt;キャッシュから&lt;code&gt;If-Modified-Since&lt;/code&gt;に&lt;code&gt;Last-Modified&lt;/code&gt;の値をセットし、このキャッシュって新鮮かどうかを確認&lt;/li&gt;&#xA;&lt;li&gt;オリジンは、200+コンテンツ or 304+コンテンツなしを返却&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;if-none-match--etag&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cloudfront-cache/#if-none-match--etag&#34;&gt;If-None-Match + ETag&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;オリジンから&lt;code&gt;ETag&lt;/code&gt;が返却され、キャッシュはそれを保持&lt;/li&gt;&#xA;&lt;li&gt;次のリクエスト時に &lt;code&gt;If-None-Match: &amp;quot;&amp;lt;ETagの値&amp;gt;&amp;quot;&lt;/code&gt; を付けて問い合わせ&lt;/li&gt;&#xA;&lt;li&gt;オリジンは、200+コンテンツ or 304+コンテンツなしを返却&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;どちらを使うか&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cloudfront-cache/#%e3%81%a9%e3%81%a1%e3%82%89%e3%82%92%e4%bd%bf%e3%81%86%e3%81%8b&#34;&gt;どちらを使うか&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;S3オリジンの場合はETagが自動で返却される&lt;/li&gt;&#xA;&lt;li&gt;カスタムオリジンの場合は返すヘッダ次第で決める&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>ネットワークはなぜつながるのか</title>
      <link>http://localhost:1313/posts/014_%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%81%AF%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%AA%E3%81%8C%E3%82%8B%E3%81%AE%E3%81%8B/</link>
      <pubDate>Wed, 25 Jun 2025 09:47:54 +0900</pubDate>
      <guid>http://localhost:1313/posts/014_%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%81%AF%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%AA%E3%81%8C%E3%82%8B%E3%81%AE%E3%81%8B/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;1章-webブラウザがメッセージを作る&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/014_%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%81%AF%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%AA%E3%81%8C%E3%82%8B%E3%81%AE%E3%81%8B/#1%e7%ab%a0-web%e3%83%96%e3%83%a9%e3%82%a6%e3%82%b6%e3%81%8c%e3%83%a1%e3%83%83%e3%82%bb%e3%83%bc%e3%82%b8%e3%82%92%e4%bd%9c%e3%82%8b&#34;&gt;1章 Webブラウザがメッセージを作る&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ファイルとディレクトリの違い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;末尾/をつけるかつけないかの話&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;example.com/&lt;/code&gt;だと、&lt;code&gt;example.com&lt;/code&gt;というWebサーバーの&lt;code&gt;/&lt;/code&gt;(ルート)にあるデフォルトファイルを指定する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;HTTPプロトコル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;何を（URI）どうして欲しいか（メソッド）をクライアントからサーバーに送る&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;HTTP通信の宛先の指定がIPアドレス行われる理由&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IPアドレスは4バイトしかないので処理効率が高いため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ドメインからIPアドレス変換(名前解決)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンピュータが扱いやすいIPアドレス、人間が扱いやすいドメイン、この間をとりもち変換の役割を行うのがDNS&lt;/li&gt;&#xA;&lt;li&gt;クライアントはDNSリゾルバといい、ブラウザに限らず、いろんなアプリケーションが必要としているので、ライブラリという形で提供されている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;また、ネットワークでデータ送信する機能とセットなっており、そのまとめ方はOSや言語により異なる&lt;/li&gt;&#xA;&lt;li&gt;ほとんどのOSや言語が「Socketライブラリ」と呼ぶものの考え方を採用している&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;具体的には、C言語で書かれたプログラムの中から&lt;code&gt;gethostbyname(&#39;example.com&#39;)&lt;/code&gt;と呼び、IPアドレスが返却される形となる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;それを受け取ったリゾルバは、アプリケーション側から指定されたメモリ領域にIPアドレスを書き込む&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;データ送受信処理（ここの話はP40〜P41を見ながらがわかりやすい）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クライアント側の準備&#xA;&lt;ul&gt;&#xA;&lt;li&gt;まずはドメインからIPアドレスへの変換&lt;/li&gt;&#xA;&lt;li&gt;次はソケット生成して接続情報を管理（Socketライブラリ内のsocketという関数を実行する）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ソケットとは？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ホテルチェックイン時のアカウント作成みたいなイメージ（その人が何か注文するたびにそのアカウントに追記していき、そのアカウントを見ればどのような状態＝会計済み等）&lt;/li&gt;&#xA;&lt;li&gt;アカウントのことをソケットといい、アカウントに紐づけられた情報のことを制御情報とし、メモリー領域を用意するのが目的となる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;その後、ディスクリプタという値をアプリケーションに返す&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ディスクリプタ＝TCP/IPソフトがそれぞれのアプリケーションに渡す番号札のようなもの&lt;/li&gt;&#xA;&lt;li&gt;以後、アプリケーションは、TCP/IPソフトにデータ送受信を依頼するとき、このディスクリプタを提出する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;socketの実行が終わり、ディスクリプタが返ってきたら、次はconnectというプログラムを呼び出して接続動作を実行する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバーのIPアドレスとTCP/IPソフトに通知する&lt;/li&gt;&#xA;&lt;li&gt;TCP/IPソフトは、渡されたIPアドレスに対して、制御用のバケットを送り、通信開始を知らせる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サーバー側の待ち受けの準備&#xA;&lt;ul&gt;&#xA;&lt;li&gt;socket&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ソケット生成&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;bind&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ソケットに「通信を許可するIPアドレス」と「自分自身のポート番号」を登録する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;「通信を許可するIPアドレス」は、どこからそれが届いたのかを調べ、許可するか拒否するかの判断に使用する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例：ローカルマシンだけから接続可能にする場合は、&lt;code&gt;127.0.0.1&lt;/code&gt;を設定&lt;/li&gt;&#xA;&lt;li&gt;例：どこからでもOKの場合は&lt;code&gt;0.0.0.0&lt;/code&gt;を設定&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;「自分自身のポート番号」は、TCP/IPソフトがパケットを受信した時にそれをどのアプリケーションに渡すべきかを&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;listen&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ソケットがクライアントからの接続を待ち受けるものであることをTCP/IPソフトに通知&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;accept&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クライアントから通信開始の制御バケットを待ち受ける状態&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サーバー側でクライアントから通信開始の制御バケットが届いたら&#xA;&lt;ul&gt;&#xA;&lt;li&gt;bindでIPアドレスして照合するかを確認&lt;/li&gt;&#xA;&lt;li&gt;応答バケットを送り返す&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;データ送受信&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ここまでしてようやく準備完了&lt;/li&gt;&#xA;&lt;li&gt;クライアント&#xA;&lt;ul&gt;&#xA;&lt;li&gt;write&#xA;&lt;ul&gt;&#xA;&lt;li&gt;送信データとそのデータの長さを渡す&lt;/li&gt;&#xA;&lt;li&gt;すると、TCP/IPソフトがそのデータをサーバーに送ってくれる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サーバー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバー側のTCP/IPソフトがそのデータを内部のバッファ・メモリに格納する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;バッファというのは、OSカーネルが管理するメモリ領域であり、TCPバケットが到着するとすぐにソケットに対応したバッファに格納される&lt;/li&gt;&#xA;&lt;li&gt;バッファが&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;read&lt;/strong&gt;が呼び出されると、受信バッファ用のメモリ領域を通知するので、TCP/IPソフトはそのメモリ領域にデータを格納して、サーバープログラムに制御を戻す&#xA;&lt;ul&gt;&#xA;&lt;li&gt;readを呼び出すのはアプリケーション側&lt;/li&gt;&#xA;&lt;li&gt;readを呼び出した後、カーネルはバッファからアプリのメモリ領域にデータをコピーする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サーバ側の処理がなされた後は、&lt;strong&gt;write&lt;/strong&gt;を呼び出す&#xA;&lt;ul&gt;&#xA;&lt;li&gt;この時にレスポンスデータは送信バッファに格納され、クライアントに送り返す&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;close&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバー側から通信終了を知らせる&lt;/li&gt;&#xA;&lt;li&gt;クライアントもcloseを呼び出し、ソケットを抹消&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;自分用の整理メモ&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以前サーバー側の処理を以下で実装してみたけど、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/nyuusen/pure-go-web-app/blob/main/server/main.go&#34;&gt;https://github.com/nyuusen/pure-go-web-app/blob/main/server/main.go&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;基本的にはサーバー側のアプリケーションは、OSの機能を使いながら、ネットワークを介してパケット受信したりしている&lt;/li&gt;&#xA;&lt;li&gt;そのためとして、ソケットを作って、そこに必要な自分の情報をセットして、接続を受け付けている&lt;/li&gt;&#xA;&lt;li&gt;結局ソケットって何？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;色々難しいことが書かれていたけど、シンプルに理解するなら&lt;strong&gt;ソケット＝通信に必要な情報の塊&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;必要な情報＝通信状態や接続先情報、送受信バッファ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;役割としては&lt;strong&gt;内部（アプリケーション）と外部（ネットワーク）を繋ぐ橋渡し役&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ロジックとしてはアプリケーションから通信したい。通信するにはOSカーネルに依頼する必要があるという前提でがある&lt;/li&gt;&#xA;&lt;li&gt;OSカーネルに依頼するにはシステムコール発行が必要でそれがsocketというもの&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アプリケーションにはSocketライブラリというものがあり、それを通じてソケットを生成する&lt;/li&gt;&#xA;&lt;li&gt;アプリケーションからOSカーネルにソケット生成を依頼し、ソケットはシステムコール発行の対象（＝操作されるカーネル内の構造体）となる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ソケットはどのアプリケーションから呼ばれたか？とか外（ネットワーク）からもらった情報を一時的にバッファに格納してくれたりとかやってくれる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;2章-tcpipのデータを電気信号にして送る&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/014_%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%81%AF%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%AA%E3%81%8C%E3%82%8B%E3%81%AE%E3%81%8B/#2%e7%ab%a0-tcpip%e3%81%ae%e3%83%87%e3%83%bc%e3%82%bf%e3%82%92%e9%9b%bb%e6%b0%97%e4%bf%a1%e5%8f%b7%e3%81%ab%e3%81%97%e3%81%a6%e9%80%81%e3%82%8b&#34;&gt;2章 TCP/IPのデータを電気信号にして送る&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1章ではブラウザのURL欄に入力されたURLを解読し、それを元にHTTPリクエストを作って、TCP/IPソフトに依頼する所までがブラウザの範囲でそこの説明だった&lt;/li&gt;&#xA;&lt;li&gt;2章ではそのメッセージをサーバーに向けて送り出す所を探検する&lt;/li&gt;&#xA;&lt;li&gt;注意点として、TCP/IPソフトの役割は中身には関知せず、それをそのまま運ぶことが役割である&#xA;&lt;ul&gt;&#xA;&lt;li&gt;メッセージの中身が見られるのはサーバーに届いてからなので、それまでは中身について見ない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Socketライブラリ関連の居場所の整理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アプリケーション側（ユーザー空間）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;システムコールを発するAPI&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ソケット作成指示や接続/待受処理、データ送受信の&lt;strong&gt;指示・制御&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;具体的には標準ライブラリ(net等)の内部でシステムコールを発している&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Socketライブラリはユーザー空間にある関数・APIの集合（ユーザー空間ライブラリ）であり、OSのソケット機能を使いやすくするためのものである&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;OS側（カーネル）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;socketの基本機能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コネクション管理やバッファ管理などの&lt;strong&gt;実体の処理&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;以下のような構成&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- アプリケーション&#xA;- Socketライブラリ(DNSリゾルバ)&#xA;- TCP/UDP&#xA;- IP&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ソケットの実体とは？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;TCP/IPソフトの内部にあるメモリ領域であり、TCP・UDPどちらを使うかや通信動作がどのような状態かを表す制御情報が格納されている（これがソケットの実体）&lt;/li&gt;&#xA;&lt;li&gt;通信というのは、遠方にあるマシンとやりとりすることになり、ちゃんと送れているかやエラーが起きていないかなどの情報の管理が重要になる&lt;/li&gt;&#xA;&lt;li&gt;この重要な制御情報を管理しているのが「ソケット」になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;流れ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ソケットの実体はメモリ領域であるが、最初からメモリ領域があるわけではない&lt;/li&gt;&#xA;&lt;li&gt;OSに依頼してソケット1つ分のメモリ領域を確保する&lt;/li&gt;&#xA;&lt;li&gt;そのメモリ領域に制御情報を記録していく&lt;/li&gt;&#xA;&lt;li&gt;ソケットを作って通信の準備が終わったら、socketは呼び出し元のアプリケーションにディスクリプタを返却する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ディスクリプタ：TCP/IPソフトの内部にある多数のソケットの中のどれを指すかを表す情報&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;以降アプリケーション側からは、通信相手の情報を毎度送る代わりにディスクリプタを通知する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;TCP/IPソフトがやること&#xA;&lt;ul&gt;&#xA;&lt;li&gt;①ソケット作成（socket呼び出す）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;メモリ領域確保&lt;/li&gt;&#xA;&lt;li&gt;制御情報（IPv4を使う・TCP使う等）を記録&lt;/li&gt;&#xA;&lt;li&gt;socketからディスクリプタが返却される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ディスクリプタとは？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OSが保持するファイルディスクリプタテーブルの配列インデックス（単なるint型の番号）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ファイルディスクリプタテーブル：そのプロセスが現在開いているリソース一覧（ファイル・ソケット）を管理しているテーブル&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;カーネル側ではそのインデックスに紐づかれた本当の構造体のポイントを内部で持っている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;以降の処理はディスクリプタを指定することでソケットを特定する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;②TCPでパイプを繋ぐ（Socketライブラリのconnectプログラム呼び出し）＝通信相手との接続動作&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通信開始を知らせる制御情報をやりとりする&lt;/li&gt;&#xA;&lt;li&gt;アプリケーションからOSに「このソケットで相手のアドレス・ポートに接続してくれ」と依頼する&lt;/li&gt;&#xA;&lt;li&gt;クライアントとサーバーのポートを論理的に接続する＝これはパイプのようなものであり、通り道自体をコネクションと呼ぶ&lt;/li&gt;&#xA;&lt;li&gt;このコネクションはデータ送受信中はずっと存在し続け、送受信が終わり、closeが呼び出された時に通信終了を知らせる制御情報が流れることで、コネクション消滅＋ソケット削除という流れになる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;③制御情報を納めたTCPヘッダを作る&#xA;&lt;ul&gt;&#xA;&lt;li&gt;「これからデータを送ります」という意味の制御情報を作成する&lt;/li&gt;&#xA;&lt;li&gt;TCPは何らかの送信動作を行う際は「TCPヘッダ」という制御情報をデータに付加する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;どのフェーズのどの動作か、データが正しく届いたかを確認するための情報、ポート番号など&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;TCPヘッダに含まれるコントロールビット&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SYN（synchronize）のビットを1にする＝これからデータを送りますという意味&lt;/li&gt;&#xA;&lt;li&gt;ACK（Acknowledge）のビットを1にする＝了解しました&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;宛先と送信元ポート番号をセット&#xA;&lt;ul&gt;&#xA;&lt;li&gt;宛先：アプリケーションからconnect呼び出し時に指定された番号&lt;/li&gt;&#xA;&lt;li&gt;送信元：無作為に決定（指定したい場合はbindを呼び出すことで可能）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;④IPアドレスを納めたIPヘッダを作る&#xA;&lt;ul&gt;&#xA;&lt;li&gt;TCPヘッダを作ったらそれをIPに渡す&lt;/li&gt;&#xA;&lt;li&gt;するとIPはIPヘッダを作って、TCPヘッダの頭にくっつける&lt;/li&gt;&#xA;&lt;li&gt;IPヘッダの中で一番重要なのはそれをどこに届けるかを表す「宛先IPアドレス」（アプリケーションから指定されるもの）&lt;/li&gt;&#xA;&lt;li&gt;送信元のIPアドレスもセットする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;複数のネットワークインターフェイス（例：LANアダプタなど）がある場合は少し曲者&lt;/li&gt;&#xA;&lt;li&gt;OSのルーティングテーブルに基づいて、送信先IPアドレスから、送信元IPアドレスが決まる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;⑤イーサネット用にMACヘッダを作る&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IPヘッダを作ったら次はMACヘッダを作る&lt;/li&gt;&#xA;&lt;li&gt;IPヘッダに宛先IPアドレスは書いてあるが、イーサネットにはこのTCP/IPの考えが通用しない（異なる方法でパケットを運ぶ必要がある）&lt;/li&gt;&#xA;&lt;li&gt;イーサネットの宛先判断に使うのが「MACヘッダ」となる&lt;/li&gt;&#xA;&lt;li&gt;送信元MACアドレスをセットする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;LANアダプタを製造するときにそのROMに書かれているので、LANドライバに依頼して、それを読み込んでMACヘッダにセットする&lt;/li&gt;&#xA;&lt;li&gt;LANドライバは、単なるハードウェア（LANアダプタ）とOSを橋渡しするソフトウェアを指す&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;送信先MACアドレスは調べる必要ある（次のステップへ）&lt;/li&gt;&#xA;&lt;li&gt;ちなみにIPアドレスは動的に変わることがあったり、あくまで論敵的な住所なので、パケットを届ける際は物理的な住所であるMACアドレスが必要となる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;⑥ARPで送信先ルーターのMACアドレスを調べる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Address Resolution Protocol&lt;/li&gt;&#xA;&lt;li&gt;送った信号が全員に届くイーサネットの仕組みを活用して、「XXXのIPアドレスを持った人はいませんか？」でMACアドレスを聞く&lt;/li&gt;&#xA;&lt;li&gt;ARPに数分程度のキャッシュ機構がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;⑦IPパケットを電気や光の信号に変換して送信&#xA;&lt;ul&gt;&#xA;&lt;li&gt;MACヘッダをIPヘッダの上につけたらパケットは完成&#xA;&lt;ul&gt;&#xA;&lt;li&gt;このパケットを作るまでがIPno担当&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;パケットはメモリに格納されたデジタルデータなので、電気や光の信号に変換してケーブルに送り出す必要がある&lt;/li&gt;&#xA;&lt;li&gt;これをやるのがLANアダプタ（＋ドライバ）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;⑧さらにパケットに3つの制御用データを付ける&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;5章-webサーバーに遂にたどり着く&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/014_%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%81%AF%E3%81%AA%E3%81%9C%E3%81%A4%E3%81%AA%E3%81%8C%E3%82%8B%E3%81%AE%E3%81%8B/#5%e7%ab%a0-web%e3%82%b5%e3%83%bc%e3%83%90%e3%83%bc%e3%81%ab%e9%81%82%e3%81%ab%e3%81%9f%e3%81%a9%e3%82%8a%e7%9d%80%e3%81%8f&#34;&gt;5章 Webサーバーに遂にたどり着く&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;負荷分散：キャッシュサーバー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;キャッシュサーバーにあるキャッシュが古くなっていないかを確認する方法として、If-Modified-Sinceヘッダを使用してその日時以降にデータの変更があったかを尋ねる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;変更があればコンテンツを返すし、変更なければ304レスポンス（ボディなし）を返却する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>ECSのロギング設定</title>
      <link>http://localhost:1313/posts/ecs-logging/</link>
      <pubDate>Tue, 24 Jun 2025 21:29:31 +0900</pubDate>
      <guid>http://localhost:1313/posts/ecs-logging/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;タスク定義でログドライバを設定可能&lt;/li&gt;&#xA;&lt;li&gt;シンプルにCloudWatchLogsに吐かせるならそれを設定するだけで良いが、例えば特定の監視ツールにも転送したいとかなると、FluentBitのようなログルータ的なものが必要になる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FluentBitは、ログを集約・整形して転送してくれるログの便利屋さん&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;FluentBitの動かし方？としてはいくつか選択肢がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;サイドカー&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/ecs-logging/#%e3%82%b5%e3%82%a4%e3%83%89%e3%82%ab%e3%83%bc&#34;&gt;サイドカー&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同一タスク内に別コンテナとしてサイドカーとしてFluentBitコンテナを動かす&lt;/li&gt;&#xA;&lt;li&gt;アプリケーションコンテナからは標準出力 or 特定ファイルにログを出力し、ホストとそれぞれが同一のボリュームマウントすることで、FluentBitコンテナを内部的にはそのファイルをtailするなどすることでログを収集してくれる&lt;/li&gt;&#xA;&lt;li&gt;ECS設定的にはcontainerDefinitions(配列)に&lt;code&gt;fluent/fluent-bit:latest&lt;/code&gt;のような形でタスクを定義する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;daemonサービス&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/ecs-logging/#daemon%e3%82%b5%e3%83%bc%e3%83%93%e3%82%b9&#34;&gt;Daemonサービス&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;データプレーンとしてEC2を採用している場合、ホストに別プロセスとしてFluentBitを常駐させておく&lt;/li&gt;&#xA;&lt;li&gt;1コンテナ1プロセスの原則に反する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;外から見た時に片方が落ちていることも気づきにくいので可観測性が落ちる（ので非推奨）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;firelens&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/ecs-logging/#firelens&#34;&gt;FireLens&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWS推奨＆公式ECSロギング機構&lt;/li&gt;&#xA;&lt;li&gt;タスク定義のログドライバに&lt;code&gt;awsfirelens&lt;/code&gt;を設定するだけ&lt;/li&gt;&#xA;&lt;li&gt;内部的には背後にFluentBitがサイドカーとして自動で立ち上がる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;業務での設定例&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/ecs-logging/#%e6%a5%ad%e5%8b%99%e3%81%a7%e3%81%ae%e8%a8%ad%e5%ae%9a%e4%be%8b&#34;&gt;業務での設定例&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ECSのログドライバとしてCloudWatch Logsを設定&lt;/li&gt;&#xA;&lt;li&gt;CloudWatch Logsにログが吐かれたらLambdaを実行し、LambdaでNewRelicにログ転送&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Lambdaトリガーはサブスクリプションフィルターを使って、特定のロググループに新しいログが出力されるたびにLambdaにストリーミングする設定&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;メトリクスは、メトリクスストリームを設定して、NewRelicで収集&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>JavaScriptとTypeScriptとその周辺理解</title>
      <link>http://localhost:1313/posts/basic/</link>
      <pubDate>Mon, 23 Jun 2025 23:26:25 +0900</pubDate>
      <guid>http://localhost:1313/posts/basic/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;javascriptとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic/#javascript%e3%81%a8%e3%81%af&#34;&gt;JavaScriptとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;JavaScriptは、ウェブブラウザ上で動作するプログラミング言語であり、主に以下の特徴がある。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;動的型付け&lt;/strong&gt;: 変数の型を明示的に指定する必要がなく、実行時に型が決まる。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;インタプリタ言語&lt;/strong&gt;: ソースコードを逐次解釈しながら実行する。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;オブジェクト指向&lt;/strong&gt;: オブジェクトを使ったプログラミングが可能。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;イベント駆動&lt;/strong&gt;: ユーザーの操作や他のイベントに応じて動作を制御する。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;JavaScriptは、ウェブページの動的な操作やユーザーインターフェースの構築に広く利用されている。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ecmascriptとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic/#ecmascript%e3%81%a8%e3%81%af&#34;&gt;ECMAScriptとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ECMAScriptは、JavaScriptの標準仕様を定めたスクリプト言語。ECMAScriptの仕様は、ECMAインターナショナルによって策定されている。以下のようなバージョンがある。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;ES5 (ECMAScript 5)&lt;/strong&gt;: 2009年にリリースされ、多くのブラウザでサポートされている。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ES6 (ECMAScript 2015)&lt;/strong&gt;: 2015年にリリースされ、クラス構文やモジュール、アロー関数など多くの新機能が追加された。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ESNext&lt;/strong&gt;: ES6以降、毎年新しいバージョンがリリースされており、最新の仕様を指す。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;ECMAScriptは、JavaScriptの進化を支える基盤となっており、ブラウザやNode.jsなどの実行環境でサポートされている。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;実行環境ブラウザとnodejsについて&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic/#%e5%ae%9f%e8%a1%8c%e7%92%b0%e5%a2%83%e3%83%96%e3%83%a9%e3%82%a6%e3%82%b6%e3%81%a8nodejs%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6&#34;&gt;実行環境(ブラウザとNode.js)について&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;JavaScriptは、主に以下の2つの実行環境で動作する。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ブラウザ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic/#%e3%83%96%e3%83%a9%e3%82%a6%e3%82%b6&#34;&gt;ブラウザ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;ブラウザは、ウェブページを表示するためのソフトウェアであり、JavaScriptを実行するためのエンジンを内蔵している。代表的なブラウザには、Google Chrome、Mozilla Firefox、Microsoft Edge、Safariなどがある。ブラウザ環境では、以下のような特徴がある。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;DOM操作&lt;/strong&gt;: ドキュメントオブジェクトモデル (DOM) を通じて、HTMLやCSSを動的に操作できる。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;イベントハンドリング&lt;/strong&gt;: ユーザーの操作（クリック、入力など）に応じて動作を制御できる。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;セキュリティ制限&lt;/strong&gt;: クロスサイトスクリプティング (XSS) やクロスオリジンリソースシェアリング (CORS) などのセキュリティ制限がある。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;nodejs&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic/#nodejs&#34;&gt;Node.js&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;Node.jsは、サーバーサイドでJavaScriptを実行するためのランタイム環境。GoogleのV8 JavaScriptエンジンを使用しており、高速な実行性能を持つ。Node.js環境では、以下のような特徴がある。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;非同期I/O&lt;/strong&gt;: 非同期処理を標準でサポートしており、高いスループットを実現する。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;モジュールシステム&lt;/strong&gt;: CommonJSモジュールシステムを使用して、モジュールのインポートやエクスポートが可能。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;豊富なパッケージ&lt;/strong&gt;: npm (Node Package Manager) を通じて、多数のパッケージを簡単に利用できる。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;ブラウザとNode.jsは、それぞれ異なる用途に特化した実行環境であり、JavaScriptの多様な利用シーンを支えている。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;javascriptにおけるモジュールシステム&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic/#javascript%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8b%e3%83%a2%e3%82%b8%e3%83%a5%e3%83%bc%e3%83%ab%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0&#34;&gt;JavaScriptにおけるモジュールシステム&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;そもそもモジュールシステムとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic/#%e3%81%9d%e3%82%82%e3%81%9d%e3%82%82%e3%83%a2%e3%82%b8%e3%83%a5%e3%83%bc%e3%83%ab%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e3%81%a8%e3%81%af&#34;&gt;そもそもモジュールシステムとは？&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;モジュールシステムとは、コードを再利用可能な部品（モジュール）に分割し、他の部分からインポートして使用できる仕組みのこと。これにより、コードの管理が容易になり、再利用性が向上する。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;モジュールシステムがないことの辛み&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic/#%e3%83%a2%e3%82%b8%e3%83%a5%e3%83%bc%e3%83%ab%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e3%81%8c%e3%81%aa%e3%81%84%e3%81%93%e3%81%a8%e3%81%ae%e8%be%9b%e3%81%bf&#34;&gt;モジュールシステムがないことの辛み&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;モジュールシステムがない場合、以下のような問題が発生する。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;グローバルスコープの汚染&lt;/strong&gt;: すべての変数や関数がグローバルスコープに存在するため、名前の衝突が発生しやすい。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;依存関係の管理が困難&lt;/strong&gt;: どのスクリプトがどのスクリプトに依存しているかを手動で管理する必要がある。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;コードの再利用が難しい&lt;/strong&gt;: 同じコードを複数の場所で使いたい場合、コピー＆ペーストするしかない。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;commonjsの誕生&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic/#commonjs%e3%81%ae%e8%aa%95%e7%94%9f&#34;&gt;CommonJSの誕生&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;CommonJSは、サーバーサイドJavaScript（特にNode.js）向けに設計されたモジュールシステム。以下の特徴がある。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;同期的なモジュール読み込み&lt;/strong&gt;: &lt;code&gt;require&lt;/code&gt; 関数を使ってモジュールを同期的に読み込む。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;モジュールのエクスポート&lt;/strong&gt;: &lt;code&gt;module.exports&lt;/code&gt; を使ってモジュールの公開インターフェースを定義する。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;esmodulesの誕生&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic/#esmodules%e3%81%ae%e8%aa%95%e7%94%9f&#34;&gt;ESModulesの誕生&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;ESModules（ESM）は、ECMAScript 2015（ES6）で標準化されたモジュールシステム。以下の特徴がある。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;静的なモジュール読み込み&lt;/strong&gt;: &lt;code&gt;import&lt;/code&gt; 文を使ってモジュールを静的に読み込む。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;モジュールのエクスポート&lt;/strong&gt;: &lt;code&gt;export&lt;/code&gt; 文を使ってモジュールの公開インターフェースを定義する。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;非同期的なモジュール読み込み&lt;/strong&gt;: ブラウザやNode.jsの実装では、モジュールを非同期に読み込むことができる。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;commonjsとesmodulesの比較&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic/#commonjs%e3%81%a8esmodules%e3%81%ae%e6%af%94%e8%bc%83&#34;&gt;CommonJSとESModulesの比較&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;読み込み方法&lt;/strong&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CommonJS: &lt;code&gt;require&lt;/code&gt; 関数を使って同期的に読み込む。&lt;/li&gt;&#xA;&lt;li&gt;ESModules: &lt;code&gt;import&lt;/code&gt; 文を使って静的に読み込む。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;エクスポート方法&lt;/strong&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CommonJS: &lt;code&gt;module.exports&lt;/code&gt; を使ってエクスポートする。&lt;/li&gt;&#xA;&lt;li&gt;ESModules: &lt;code&gt;export&lt;/code&gt; 文を使ってエクスポートする。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;実行環境&lt;/strong&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CommonJS: 主にNode.jsで使用される。&lt;/li&gt;&#xA;&lt;li&gt;ESModules: ブラウザとNode.jsの両方で使用される。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;依存関係の解析&lt;/strong&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CommonJS: 実行時に依存関係を解析する。&lt;/li&gt;&#xA;&lt;li&gt;ESModules: 静的に依存関係を解析するため、ビルドツールによる最適化が容易。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;非同期読み込み&lt;/strong&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CommonJS: 同期的な読み込みのみサポート。&lt;/li&gt;&#xA;&lt;li&gt;ESModules: 非同期的な読み込みをサポート。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;これらの違いにより、ESModulesはモダンなJavaScript開発において推奨されるモジュールシステムとなっている。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;typescriptによる型システムの誕生&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic/#typescript%e3%81%ab%e3%82%88%e3%82%8b%e5%9e%8b%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e3%81%ae%e8%aa%95%e7%94%9f&#34;&gt;TypeScriptによる型システムの誕生&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;typescriptとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic/#typescript%e3%81%a8%e3%81%af&#34;&gt;TypeScriptとは？&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;TypeScriptは、Microsoftによって開発されたJavaScriptのスーパーセット。静的型付けをサポートし、開発時に型チェックを行うことで、バグを未然に防ぐことができる。TypeScriptはJavaScriptのすべての機能を含んでおり、追加の型システムや最新のJavaScript機能を利用できる。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;typescriptとjavascriptの関係性&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic/#typescript%e3%81%a8javascript%e3%81%ae%e9%96%a2%e4%bf%82%e6%80%a7&#34;&gt;TypeScriptとJavaScriptの関係性&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;TypeScriptはJavaScriptのスーパーセットであり、すべてのJavaScriptコードは有効なTypeScriptコードでもある。TypeScriptは、JavaScriptに型システムを追加することで、コードの品質と保守性を向上させる。TypeScriptで書かれたコードは、最終的にJavaScriptにコンパイルされ、ブラウザやNode.jsで実行される。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;typescriptをjavascriptに変換して実行するまでの流れ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic/#typescript%e3%82%92javascript%e3%81%ab%e5%a4%89%e6%8f%9b%e3%81%97%e3%81%a6%e5%ae%9f%e8%a1%8c%e3%81%99%e3%82%8b%e3%81%be%e3%81%a7%e3%81%ae%e6%b5%81%e3%82%8c&#34;&gt;TypeScriptをJavaScriptに変換して実行するまでの流れ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;TypeScriptでソースコードを記述する&lt;/strong&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;TypeScriptファイル（.ts）を作成し、コードを記述する。&lt;/li&gt;&#xA;&lt;li&gt;型注釈やインターフェースを使用して、型安全なコードを書く。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;tsconfig.jsonを設定する&lt;/strong&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プロジェクトのルートにtsconfig.jsonファイルを作成し、コンパイルオプションを設定する。&lt;/li&gt;&#xA;&lt;li&gt;コンパイルターゲットやモジュールシステム、出力ディレクトリなどを指定する。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;TypeScriptコンパイラ（tsc）を使用してコンパイルする&lt;/strong&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;tsc&lt;/code&gt;コマンドを実行して、TypeScriptコードをJavaScriptにコンパイルする。&lt;/li&gt;&#xA;&lt;li&gt;コンパイルされたJavaScriptファイルは、指定された出力ディレクトリに生成される。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;JavaScriptファイルを実行する&lt;/strong&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンパイルされたJavaScriptファイルをNode.jsやブラウザで実行する。&lt;/li&gt;&#xA;&lt;li&gt;Node.jsの場合、&lt;code&gt;node&lt;/code&gt;コマンドを使用して実行する。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;この流れにより、TypeScriptで書かれたコードをJavaScriptに変換し、実行することができる。TypeScriptは、型システムを活用することで、より安全で保守性の高いコードを書くことができる。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;まとめ的な&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic/#%e3%81%be%e3%81%a8%e3%82%81%e7%9a%84%e3%81%aa&#34;&gt;まとめ的な&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;各関係者やファイルの整理&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic/#%e5%90%84%e9%96%a2%e4%bf%82%e8%80%85%e3%82%84%e3%83%95%e3%82%a1%e3%82%a4%e3%83%ab%e3%81%ae%e6%95%b4%e7%90%86&#34;&gt;各関係者やファイルの整理&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Node.js&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ランタイム&lt;/li&gt;&#xA;&lt;li&gt;サーバーサイド JavaScript 実行環境&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;npm (package.json と package-lock.json)&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パッケージ管理システム&lt;/li&gt;&#xA;&lt;li&gt;外部パッケージを読み込んで使ったりすることを簡単にしてくれる&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;package.json&lt;/code&gt; はプロジェクトの依存関係やスクリプトを定義&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;package-lock.json&lt;/code&gt; は依存関係の正確なバージョンを固定&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;tsconfig.json&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;TypeScript を JavaScript にトランスパイルするときの設定ファイル&lt;/li&gt;&#xA;&lt;li&gt;トランスパイル時のターゲットバージョンやモジュールシステムなどの設定が書かれている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;コンパイルツール(tsx や ts-node)&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;TypeScript ランタイム&lt;/li&gt;&#xA;&lt;li&gt;TypeScript ファイルを直接実行するためのライブラリ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;ビルドツール(webpack や esbuild)&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JavaScript のビルドツール&lt;/li&gt;&#xA;&lt;li&gt;トランスパイルやバンドルを行う&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;webpack&lt;/code&gt; はプラグインやローダーが豊富で柔軟性が高い&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;esbuild&lt;/code&gt; は非常に高速なビルドが特徴&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;サーバーサイドにおける開発から実行までの流れ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic/#%e3%82%b5%e3%83%bc%e3%83%90%e3%83%bc%e3%82%b5%e3%82%a4%e3%83%89%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8b%e9%96%8b%e7%99%ba%e3%81%8b%e3%82%89%e5%ae%9f%e8%a1%8c%e3%81%be%e3%81%a7%e3%81%ae%e6%b5%81%e3%82%8c&#34;&gt;サーバーサイドにおける開発から実行までの流れ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;TypeScript でソースコードを記述する&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;直接 TypeScript ファイルを書いたり&lt;/li&gt;&#xA;&lt;li&gt;npm を使用して外部パッケージを使ったり&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;tsx や ts-node を使用して TypeScript を JavaScript に変換する&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;開発中に直接実行する場合に便利&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;esbuild や webpack を使用して 1 つの JavaScript ファイルにバンドルする&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;本番環境向けに最適化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;minify: 変数名短くしたり、スペース削除して、ファイルサイズを小さくする&lt;/li&gt;&#xA;&lt;li&gt;tree shaking: 未使用モジュールを削除&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://zenn.dev/righttouch/articles/86457bf2908379#%E5%90%84%E3%83%84%E3%83%BC%E3%83%AB%E3%81%AE%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%93%E3%81%A8%E6%95%B4%E7%90%86&#34;&gt;JavaScriptビルドツールの整理 各ツールの機能と依存関係&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Node.js がインストールされた環境で、JavaScript ファイルを実行する&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;各用語の整理&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic/#%e5%90%84%e7%94%a8%e8%aa%9e%e3%81%ae%e6%95%b4%e7%90%86&#34;&gt;各用語の整理&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;バンドル&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;複数の JavaScript ファイルを 1 つに束ねる&lt;/li&gt;&#xA;&lt;li&gt;依存関係を解決し、1 つのファイルにまとめることで読み込みを効率化&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;トランスパイル&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;TypeScript の文脈では、TypeScript ファイルを特定のバージョンの JavaScript に書き出す&lt;/li&gt;&#xA;&lt;li&gt;JavaScript の文脈では、JavaScript ファイルを特定のバージョンの JavaScript に書き出す&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;ビルド&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;上記のバンドルやトランスパイルをまとめて、ソースコードを実行可能な状態まで仕上げる全体的な工程を指している&lt;/li&gt;&#xA;&lt;li&gt;使用する人によって意味がブレる（言葉自体の定義がふわっとしている）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Node.js</title>
      <link>http://localhost:1313/posts/what-is-nodejs/</link>
      <pubDate>Mon, 23 Jun 2025 23:26:25 +0900</pubDate>
      <guid>http://localhost:1313/posts/what-is-nodejs/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/what-is-nodejs/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Node.jsでサーバーサイドの開発って結局微妙なのでは？複雑性増すよね？というようなトピックでXが盛り上がっていた。&lt;/p&gt;&#xA;&lt;p&gt;雰囲気でしか掴めていなかったので、改めてNode.jsとは何者なのか？他と比較した時の優位性は何なのか？をちょっと調べてみた。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;そもそもnodejsとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/what-is-nodejs/#%e3%81%9d%e3%82%82%e3%81%9d%e3%82%82nodejs%e3%81%a8%e3%81%af&#34;&gt;そもそもNode.jsとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ブラウザ外でJavaScriptを動かす実行環境&lt;/li&gt;&#xA;&lt;li&gt;シングルスレッドで動作する&lt;/li&gt;&#xA;&lt;li&gt;Node.jsはいくつかのモジュールが組み合わされて構成されている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;そのうち理解する上で大事なのが「V8」と「Libuv」&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;v8とは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/what-is-nodejs/#v8%e3%81%a8%e3%81%af&#34;&gt;V8とは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;V8は、Googleが開発するJavaScriptエンジン&#xA;&lt;ul&gt;&#xA;&lt;li&gt;つまり、JavaScriptで書かれたソースコードを受け取り、機械語に変換してOS上で実行してくれるやつ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;chromeとNode.jsはJavaScriptエンジンとしてV8を採用している。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;libuvとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/what-is-nodejs/#libuv%e3%81%a8%e3%81%af&#34;&gt;Libuvとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OSによるディスクへの書き込みや通信などの処理に関するイベントを監視し、そのステータスをNode.jsに通知する機能を持つ&lt;/li&gt;&#xA;&lt;li&gt;イベント監視はOSによって仕様や実現方法が異なるが、この辺りを抽象化し、OSを気にすることなく使えるようにしているのがLibuvである&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;nodejsの特徴&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/what-is-nodejs/#nodejs%e3%81%ae%e7%89%b9%e5%be%b4&#34;&gt;Node.jsの特徴&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;非同期io&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/what-is-nodejs/#%e9%9d%9e%e5%90%8c%e6%9c%9fio&#34;&gt;非同期I/O&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;I/Oとは、Input/Outputのことでファイルの読み書き/ネットワーク通信/データベースアクセスなど、プログラム外とのやりとりする処理全般を指す&lt;/li&gt;&#xA;&lt;li&gt;非同期I/Oとは、リソースを効率的に利用するための手法&lt;/li&gt;&#xA;&lt;li&gt;具体的には、時間のかかるI/O操作の完了を待たずに次の処理を進められるので、大量の同時接続を効率的に処理することができる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;[memo]&lt;!-- raw HTML omitted --&gt;&#xA;なぜ非同期I/Oを採用しているかというと、Node.jsはシングルスレッドで動作するという背景があるらしい。&lt;!-- raw HTML omitted --&gt;&#xA;マルチスレッドの場合は複数のスレッドに分散して処理を実行できるが、シングルスレッドの場合は文字の通りそれができない。&lt;!-- raw HTML omitted --&gt;&#xA;なので、時間軸で分散させる目的で、非同期I/Oを採用している。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;イベント駆動モデル&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/what-is-nodejs/#%e3%82%a4%e3%83%99%e3%83%b3%e3%83%88%e9%a7%86%e5%8b%95%e3%83%a2%e3%83%87%e3%83%ab&#34;&gt;イベント駆動モデル&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;イベントが発生するたびに対応するコールバック関数が呼び出される仕組みのこと&lt;/li&gt;&#xA;&lt;li&gt;具体的には、以下のように動作する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;イベント登録：非同期操作(I/O操作)が発生すると、その操作に対するコールバックがイベントキューに登録される&lt;/li&gt;&#xA;&lt;li&gt;イベント処理: イベントループがイベントキューを監視し、キューに入ると対応するコールバックを実行する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;これにより、Node.jsはシングルスレッドでありながら、並行処理を効率的に行うことができる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;nodejsの優位性&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/what-is-nodejs/#nodejs%e3%81%ae%e5%84%aa%e4%bd%8d%e6%80%a7&#34;&gt;Node.jsの優位性&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;c10k問題の解決&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/what-is-nodejs/#c10k%e5%95%8f%e9%a1%8c%e3%81%ae%e8%a7%a3%e6%b1%ba&#34;&gt;C10K問題の解決&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;C10K問題とは「同時に10,000（K=1000）クライアントを処理する際に効率的に処理できない」という問題のこと&lt;/li&gt;&#xA;&lt;li&gt;従来のサーバー設計は、1接続ごとに1つのスレッドとプロセスを割り当てることが一般的だった&#xA;&lt;ul&gt;&#xA;&lt;li&gt;この方法では、スレッドやプロセスのオーバーヘッドが大きくなり、メモリ消費やコンテキストスイッチの負荷が高くなるので、10000以上の同時接続を効率的に処理するのは難しいよねという意味&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;この問題に対し、Node.jsは面で優位性がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1つのスレッドで多くのI/O操作や非ブロッキングで処理できるため、少ないリソースで多数の同時接続を捌くことができる&lt;/li&gt;&#xA;&lt;li&gt;従来のスレッド/プロセスベースのアプローチと異なり、Node.jsは各接続にスレッドやプロセスを割り当てるのではなく、イベントループを利用してI/O操作の完了を待ち受けるため、メモリ使用量が低く抑えられ、コンテキストスイッチのオーバーヘッドがない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ロングポーリングの効率的な処理&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/what-is-nodejs/#%e3%83%ad%e3%83%b3%e3%82%b0%e3%83%9d%e3%83%bc%e3%83%aa%e3%83%b3%e3%82%b0%e3%81%ae%e5%8a%b9%e7%8e%87%e7%9a%84%e3%81%aa%e5%87%a6%e7%90%86&#34;&gt;ロングポーリングの効率的な処理&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ロングポーリングとは、HTTPのみで擬似的にプッシュ通信(サーバー→クライアントへの通信)を実現する手法の1つ。&lt;/li&gt;&#xA;&lt;li&gt;具体的には、クライアントがサーバーにHTTPリクエストを送信し、サーバーは応答せず受付のみし、保留のまま接続を維持しておき、サーバー側が任意のタイミングで保留を解除して応答する。応答を受け取ったクライアント側はすぐさま同じくサーバーにHTTPリクエストを送信し、これを繰り返すことでリアルタイム通信を実現することができる。&lt;/li&gt;&#xA;&lt;li&gt;Node.jsは非同期I/Oとイベント駆動モデルを採用しているため、ロングポーリングのような多くのオープンな接続を効率的に処理するのに適している&#xA;&lt;ul&gt;&#xA;&lt;li&gt;非同期I/O: リクエストを非ブロッキングで処理するため、I/O操作の完了を待たずに次の操作を開始できるため、リソースの効率的な使用が可能である&lt;/li&gt;&#xA;&lt;li&gt;イベント駆動モデル: リクエストが来るたびにNode.jsはイベントキューに追加し、非同期に処理できるため、同時に多数のリクエストを効率的に処理できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/what-is-nodejs/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://qiita.com/Shiruba/items/709044782cffbd2aaeda&#34;&gt;Node.jsの設計をつらつらと概観する #JavaScript - Qiita&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://xtech.nikkei.com/it/article/COLUMN/20120725/411442/&#34;&gt;I/Oのイベント管理がキモ | 日経クロステック（xTECH）&lt;/a&gt;&#xA;→分かりやすい図あり&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://zenn.dev/mmomm/articles/ff83eb49a7b642&#34;&gt;Node.jsを理解する (libuv)&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://blog.koh.dev/2024-04-23-nodejs-typescript-module/&#34;&gt;Node.js + TypeScriptのモジュールを整理してみる&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>TS(JS)でのサーバーサイド開発</title>
      <link>http://localhost:1313/posts/backend/</link>
      <pubDate>Mon, 23 Jun 2025 23:26:25 +0900</pubDate>
      <guid>http://localhost:1313/posts/backend/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/backend/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;XでTSのバックエンド開発が向いてないよねという話題が盛り上がってたので、少し深掘りしてみる。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;向いてないと思われている理由&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/backend/#%e5%90%91%e3%81%84%e3%81%a6%e3%81%aa%e3%81%84%e3%81%a8%e6%80%9d%e3%82%8f%e3%82%8c%e3%81%a6%e3%81%84%e3%82%8b%e7%90%86%e7%94%b1&#34;&gt;向いてないと思われている理由&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;シングルスレッドで動作するから&lt;/li&gt;&#xA;&lt;li&gt;プロトタイプ汚染&lt;/li&gt;&#xA;&lt;li&gt;数値計算や等価演算の挙動に怪しい箇所がある&lt;/li&gt;&#xA;&lt;li&gt;バッチ処理に向かない&lt;/li&gt;&#xA;&lt;li&gt;デプロイが割と面倒&lt;/li&gt;&#xA;&lt;li&gt;ライブラリの依存関係のあれでRAMが太る&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;シングルスレッドで動作するから&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/backend/#%e3%82%b7%e3%83%b3%e3%82%b0%e3%83%ab%e3%82%b9%e3%83%ac%e3%83%83%e3%83%89%e3%81%a7%e5%8b%95%e4%bd%9c%e3%81%99%e3%82%8b%e3%81%8b%e3%82%89&#34;&gt;シングルスレッドで動作するから&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Nodeは1つのスレッドで全ての処理（リクエスト対応など）を処理する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CやJavaはリクエストごとにスレッドを作成して並列処理をする&lt;/li&gt;&#xA;&lt;li&gt;Goでも同じで、リクエスト単位で&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Nodeは1つのメインスレッドを順番にタスク処理していくことで、シンプルで軽量な動作を実現している&lt;/li&gt;&#xA;&lt;li&gt;具体的にはイベントループという仕組みで、非同期処理を効率的に捌いている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これは基本的には処理中は裏で待機、完了したら次の処理（コールバック）を実行していく&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;これはリクエストごとに完全に独立した環境で処理するわけではない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;あるリクエストに対する処理がメモリリークを起こした場合、同じプロセス内の他のリクエスト処理にも影響が発生するということ&lt;/li&gt;&#xA;&lt;li&gt;例えば画像変換や圧縮などのCPUを大量に使う処理が1件あると、それだけでメインスレッドが占有されて、他のリクエストが滞ってしまう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;逆に向いているシーン&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/backend/#%e9%80%86%e3%81%ab%e5%90%91%e3%81%84%e3%81%a6%e3%81%84%e3%82%8b%e3%82%b7%e3%83%bc%e3%83%b3&#34;&gt;逆に向いているシーン&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;I/Oバウンド処理（シンプルなAPI・DBアクセスが多いなど）が多い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;I/Oの特性としてCPUが働く時間は少ないが、外部の応答を待っている時間が多いというのがある&lt;/li&gt;&#xA;&lt;li&gt;イベントループは、その待ち時間に次の処理を進めることができる&lt;/li&gt;&#xA;&lt;li&gt;逆にマルチスレッド方式だと、スレッド数が限られている中で、I/O中は待機＝ブロッキング状態となる&lt;/li&gt;&#xA;&lt;li&gt;I/O中にノンブロッキング状態で他の処理を進められるという点で優位性がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>モジュールシステム</title>
      <link>http://localhost:1313/posts/module-system/</link>
      <pubDate>Mon, 23 Jun 2025 23:26:25 +0900</pubDate>
      <guid>http://localhost:1313/posts/module-system/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;ES ModulesとCommonJSの2種類がある&lt;/li&gt;&#xA;&lt;li&gt;Node.jsではデフォルトがCommonJSであり、Next.jsではデフォルトがES Modulesとなっている&lt;/li&gt;&#xA;&lt;li&gt;設定箇所&#xA;&lt;ol&gt;&#xA;&lt;li&gt;tsconfig.jsonのcompilerOption.module&lt;/li&gt;&#xA;&lt;li&gt;package.jsonのtypeフィールド(moduleかcommonjsを設定)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;上記設定の違い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;tsconfig.jsonでの設定&#xA;&lt;ul&gt;&#xA;&lt;li&gt;TSがトランスパイル時に生成するJSコードのモジュール形式をしている(トランスパイル後のJSコードの指定されたモジュールシステムになる)&lt;/li&gt;&#xA;&lt;li&gt;TSコンパイラが、import/export構文をどのモジュール形式に変換するかを決定する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;package.jsonでの設定&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Node.jsが実行時のJSファイルをどのモジュールシステム形式として扱うかを指定する&lt;/li&gt;&#xA;&lt;li&gt;.jsファイルをESMとして扱うか、CJSとして扱うか&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;双方の設定を合わせることで、トランスパイル時・実行時のモジュール形式を統一させることができる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ファイル拡張子&#xA;&lt;ul&gt;&#xA;&lt;li&gt;js: プロジェクトの設定次第&lt;/li&gt;&#xA;&lt;li&gt;mjs: 常にESMとして扱われる&lt;/li&gt;&#xA;&lt;li&gt;cjs: 常にCJSとして扱われる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CommonJS&#xA;&lt;ul&gt;&#xA;&lt;li&gt;exportsはただのオブジェクト&lt;/li&gt;&#xA;&lt;li&gt;それ故にそのファイルが全て評価される必要がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>First Post</title>
      <link>http://localhost:1313/posts/first-post/</link>
      <pubDate>Sun, 22 Jun 2025 23:09:44 +0900</pubDate>
      <guid>http://localhost:1313/posts/first-post/</guid>
      <description>&lt;p&gt;1つ目の記事です。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Docker</title>
      <link>http://localhost:1313/posts/docker/</link>
      <pubDate>Wed, 18 Jun 2025 11:40:43 +0900</pubDate>
      <guid>http://localhost:1313/posts/docker/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;概要&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#%e6%a6%82%e8%a6%81&#34;&gt;概要&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;なんとなく触っているDockerを以下を題材にきちんと学ぶ。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://y-ohgi.com/introduction-docker/&#34;&gt;入門 Docker&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;基礎編&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#%e5%9f%ba%e7%a4%8e%e7%b7%a8&#34;&gt;基礎編&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;dockerとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#docker%e3%81%a8%e3%81%af&#34;&gt;Dockerとは&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dockerは任意のタイミングの状態（ランタイム・ライブラリ・コードのバージョン）を1つのスナップショットとして保存している&lt;/li&gt;&#xA;&lt;li&gt;従来のVM型の仮想化は、物理レイヤの仮想化から行なっている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;つまりVMには、&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;一方DockerはLinuxカーネルの機能を用いて1プロセスとして隔離された環境を実現している&lt;/li&gt;&#xA;&lt;li&gt;なのでDockerの方が軽量でオーバーヘッドが少ない環境を実現できる&lt;/li&gt;&#xA;&lt;li&gt;DockerはImmutable InfrastructureをDockerfileとイメージという機能で実現&#xA;&lt;ul&gt;&#xA;&lt;li&gt;任意の時点で確実に動作するスナップショット（何か変更する場合は新しく構築する）&lt;/li&gt;&#xA;&lt;li&gt;かつてはサーバーへ変更を加えて実現するMutableなものだった&lt;/li&gt;&#xA;&lt;li&gt;また、イメージにはバージョン情報がつくので、それを指定することでロールバックが可能になり、可用性が向上する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;コンテナ自体は古くからある概念で、Dockerが流行ったのは「配布の容易性」がある（スナップショットを取得し配布を標準の機能として提供している）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;vmとdocker&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#vm%e3%81%a8docker&#34;&gt;VMとDocker&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;どちらも隔離された環境を提供する技術&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;VMはコンピュータ自体の抽象化（仮想化）するのに対し、Dockerはプロセス自体の抽象化（仮想化）を行う&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;この2つは競合するのではなく、むしろ共存する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;vm&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#vm&#34;&gt;VM&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ハードウェアから上、ハードウェア・カーネル（OS）、ユーザースペースの低レイヤから仮想化を行う&lt;/li&gt;&#xA;&lt;li&gt;例えばmacOS上でWindowsを動かすことが可能だったりして、非常に自由度が高い&lt;/li&gt;&#xA;&lt;li&gt;仮想化の対象となる領域が広いためオーバーヘッドが大きくなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;docker&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#docker&#34;&gt;Docker&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Linuxカーネルの機能を用いた技術で、cgroup・namespace・Capabilityのような機能を組み合わせて実現している&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;VMとは異なり、ホストOSとリソースを共有し、効率的にホストOSのリソースを使うことができるので、高速化つ軽量な仮想化を実現している&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Linuxカーネルとは？&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OSの中核となる部分で、ハードウェアとアプリケーションの間を取り持つ橋渡し役&lt;/li&gt;&#xA;&lt;li&gt;例えばファイルの読み書き・ネットワーク通信・メモリ管理・CPU割り当てなどの低レイヤ処理を全てカーネルが担っている&lt;/li&gt;&#xA;&lt;li&gt;UbuntuやCentOSなどのディストリビューションは全てLinuxカーネルをベースにしている&lt;/li&gt;&#xA;&lt;li&gt;カーネルが主に行なっているのは以下の4つ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プロセス管理：プロセスに対してCPU割り当て（今どのプロセスにCPU時間を割り当てるかをスケジュール・切り替え＝コンテキストスイッチ）&lt;/li&gt;&#xA;&lt;li&gt;メモリ管理：アプリケーションへのメモリ割り当て（他のプロセスのメモリ領域を勝手にアクセスできないようにしたり、メモリ不足時はディスクにスワッピングしたり）&lt;/li&gt;&#xA;&lt;li&gt;ファイルシステム管理：ファイル操作を仲介（実際にディスクを触るのはカーネルが行なっている）&lt;/li&gt;&#xA;&lt;li&gt;ネットワーク管理：カーネルがパケット処理を行なっている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;でもDockerfileでFROM句にubuntu:latestみたいな記述をしているよね&amp;hellip;？&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ホスト側のLinuxカーネルを使うのに、コンテナ側でOS指定が必要な理由は何？という話&lt;/li&gt;&#xA;&lt;li&gt;結論、これはユーザースペースのOS環境を指定しているだけ&lt;/li&gt;&#xA;&lt;li&gt;ユーザースペースというのは、コマンドやライブラリ（bashとか）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Distrolessとか軽量なOSイメージを指定すると、デフォルトのままではcurl等のコマンドがインストールされておらず使用できないのは、コンテナ側のユーザースペースを使っているため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;docker-image&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#docker-image&#34;&gt;Docker Image&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;イメージは、任意のタイミングのスナップショットとしての役割を持つ&lt;/li&gt;&#xA;&lt;li&gt;ファイルシステムのスナップショットである&#xA;&lt;ul&gt;&#xA;&lt;li&gt;もっとシンプルに表現すると、OSの中身のフォルダ構造一式をZIP圧縮したようなもの&lt;/li&gt;&#xA;&lt;li&gt;例えばubuntuイメージの中身は、ユーザースペース（&lt;code&gt;ls /&lt;/code&gt;した時に見るような bin/,etc/,lib/等）のファイル・フォルダ一式が入っている（でもカーネル部分は含まない）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;てっきりイメージ＝プロセスのスナップショットと理解していたけどそれは間違っていて、&lt;strong&gt;イメージ＝実行前のファイル群&lt;/strong&gt;が正しい表現&lt;/li&gt;&#xA;&lt;li&gt;イメージを指定するときの命名は&amp;lt;イメージ名&amp;gt;:&amp;lt;タグ&amp;gt;であり、&amp;lt;タグ&amp;gt;を省略するとlatestタグが自動的に付与される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;レイヤー構造&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#%e3%83%ac%e3%82%a4%e3%83%a4%e3%83%bc%e6%a7%8b%e9%80%a0&#34;&gt;レイヤー構造&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dockerイメージはレイヤーの積み重ね&lt;/li&gt;&#xA;&lt;li&gt;RUNやCOPY毎に新しいレイヤが作られる&lt;/li&gt;&#xA;&lt;li&gt;レイヤは読み取り専用で、キャッシュとして使い回せる&lt;/li&gt;&#xA;&lt;li&gt;レイヤー構造である理由&#xA;&lt;ul&gt;&#xA;&lt;li&gt;キャッシュ：同じベースイメージなら、そのレイヤはpull済み&lt;/li&gt;&#xA;&lt;li&gt;ストレージ節約：変更があった部分だけ新しいレイヤに保存&#xA;&lt;ul&gt;&#xA;&lt;li&gt;もし仮にレイヤ構造ではない場合はフルフルのものを保存しなければいけない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;高速化：レイヤー単位でダウンロード・展開&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;docker pushすると以下のようなハッシュ値が表示されるが、これがまさにレイヤ構造（レイヤ単位で処理している）&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  The push refers to repository [123456789012.dkr.ecr.us-east-1.amazonaws.com/myapp]&#xA;  d4f4f6a4b8c2: Pushed &#xA;  7a0437f04f83: Pushed &#xA;  8c662931926f: Pushed &#xA;  ...&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;各レイヤのコンテンツハッシュ(SHA256)らしい&#xA;&lt;ul&gt;&#xA;&lt;li&gt;具体的にはそのレイヤの差分をtarアーカイブをgzipなりで圧縮→圧縮されたバイナリファイルをSHA256ハッシュ計算している&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;整理すると、Dockerイメージはファイルシステムのスナップショットであり、それはレイヤー構造になっている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以下のDockerfileを例に考えると、&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  FROM ubuntu:latest&#xA;  RUN apt-get update&#xA;  RUN apt-get install -y curl&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;各行がレイヤとなっていて、そのレイヤで変更があったファイル群を持っているイメージ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;この上に、Dockerはコンテナ起動した時に、書き込みできるレイヤを作っている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;イメージとコンテナの違い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;イメージ: 読み込み専用の複数のレイヤを重ねたもの&lt;/li&gt;&#xA;&lt;li&gt;コンテナ: イメージに読み書き可能なレイヤを追加して起動したもの&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;参考リンク&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.docker.jp/build/guide/layers.html&#34;&gt;レイヤ — Docker-docs-ja 24.0 ドキュメント&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://qiita.com/kompiro/items/4153b4066a1837be7f98&#34;&gt;Dockerのまとめ - コンテナとイメージ編 #Docker - Qiita&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;dockerfile&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#dockerfile&#34;&gt;Dockerfile&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;COPY&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2つの引数を設定する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1つ目はホスト側のディレクトリ、2つ目はDocker側のディレクトリ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ホスト側のディレクトリは &lt;code&gt;docker build .&lt;/code&gt; で指定したディレクトリ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;この場合 &lt;code&gt;.&lt;/code&gt; を指定しており、カレントディレクトリが参照される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Docker側はデフォルトのパス、もしくは &lt;code&gt;WORKDIR&lt;/code&gt; で定義されたディレクトリを参照する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;EXPOSE&#xA;&lt;ul&gt;&#xA;&lt;li&gt;このポートを使いますよというドキュメント的な宣言&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CMD&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dockerはここで設定したコマンドがフォアグラウンドで実行されている間が生存期間となる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;run-vs-cmd&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#run-vs-cmd&#34;&gt;RUN vs CMD&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RUN:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;イメージビルド時に実行される&lt;/li&gt;&#xA;&lt;li&gt;レイヤとしてファイルシステムに反映されキャッシュが効く&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CMD:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテナ起動時に実行される&lt;/li&gt;&#xA;&lt;li&gt;イメージには反映せず、ただの実行時オプション&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;cmd-vs-entrypoint&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#cmd-vs-entrypoint&#34;&gt;CMD vs ENTRYPOINT&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CMDはデフォルト設定で、オーバーライド可能&lt;/li&gt;&#xA;&lt;li&gt;一方、ENTRYPOINTは起動時に必ず実行される&lt;/li&gt;&#xA;&lt;li&gt;テクニックとしてENTRYPOINTでコマンドを指定し、CMDで引数を指定するというのがある（引数だけ利用者側で指定可能となる）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;基本的に CMD を使うのが良いでしょう。&#xA;ENTRYPOINT はDocker起動時のコマンドを強制します。&#xA;コマンドのラップをするDocker Image の場合は ENTRYPOINT のほうが好ましいですが、一般的なWebアプリケーションの場合は CMD を使用する方がユーザーにとって使いやすいDocker Image になります。&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;copyは最後に実行するとキャッシュが効きやすい&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#copy%e3%81%af%e6%9c%80%e5%be%8c%e3%81%ab%e5%ae%9f%e8%a1%8c%e3%81%99%e3%82%8b%e3%81%a8%e3%82%ad%e3%83%a3%e3%83%83%e3%82%b7%e3%83%a5%e3%81%8c%e5%8a%b9%e3%81%8d%e3%82%84%e3%81%99%e3%81%84&#34;&gt;COPYは最後に実行するとキャッシュが効きやすい&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dockerfileの前段で、&lt;code&gt;COPY . .&lt;/code&gt;を実行してしまうと、ローカル側のソースコードが1文字でも変わっていると、そのレイヤのキャッシュが効かなくなる&lt;/li&gt;&#xA;&lt;li&gt;レイヤーのキャッシュは、親が変わると問答無用でキャッシュ無効化されるので、&lt;code&gt;COPY . .&lt;/code&gt;以降は全てキャッシュが利用されなくなる（レイヤは差分を持っているようなものだから、親が変更があったら当然子にも影響あるよねということだと理解した）&lt;/li&gt;&#xA;&lt;li&gt;なので、変更が頻繁にあるような&lt;code&gt;COPY . .&lt;/code&gt;の処理は、Dockerfileの中で後ろの方に持っていくと良い&lt;/li&gt;&#xA;&lt;li&gt;Nodeならpackage系だけを最初にコピーする→依存関係をインストール→ソースコードをコピーしてくるみたいな形で工夫できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;container&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#container&#34;&gt;Container&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;イメージがスナップショットだとすると、そのスナップショットから起動したプロセスがコンテナ&lt;/li&gt;&#xA;&lt;li&gt;コンテナは「1つのコマンド（プロセス）をフォアグラウンドで動かす」ように設計されている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテナは1つのコマンドを隔離された環境で実行し、そのコマンドの実行がフォアグラウンドで終了するまで生存する&lt;/li&gt;&#xA;&lt;li&gt;ライフサイクル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Image &amp;ndash; (docker run &amp;lt;$IMAGE&amp;gt;) &amp;ndash;&amp;gt; RUNNING &amp;ndash; STOPPED &amp;ndash; DELETED&lt;/li&gt;&#xA;&lt;li&gt;正常終了 or 異常終了 or docker killするとSTOPPED&lt;/li&gt;&#xA;&lt;li&gt;docker rmするとDELETED&lt;/li&gt;&#xA;&lt;li&gt;pauseすると停止状態を表すPAUSEDにもなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;プロセスの隔離&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテナ内のプロセスはホストマシンや他のコンテナと隔離されて実行される&lt;/li&gt;&#xA;&lt;li&gt;CMDもしくはENTRYPOINTで定義されたプロセスはPID 1となる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;network&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#network&#34;&gt;Network&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dockerではネットワークの扱いが重要となる&lt;/li&gt;&#xA;&lt;li&gt;1コンテナでは1プロセスを動かす設計となっている&lt;/li&gt;&#xA;&lt;li&gt;nginxとphp-fpmのように複数プロセスを協調して動かす必要があるときはソケットではなく、ネットワークで通信を行うことが推奨されている&lt;/li&gt;&#xA;&lt;li&gt;Dockerでのネットワークは特にKubernetes・ECS・docker-composeのような各種オーケストレーションツールを使用する際に意識する必要がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;driverの種類&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#driver%e3%81%ae%e7%a8%ae%e9%a1%9e&#34;&gt;Driverの種類&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ネットワークドライバーはネットワークの振る舞いの定義で、デフォルトでは2種類ある&lt;/li&gt;&#xA;&lt;li&gt;複数のコンテナ（プロセス）はネットワークを介して通信を行う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;bridge&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#bridge&#34;&gt;bridge&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本的にはこれ&lt;/li&gt;&#xA;&lt;li&gt;コンテナごとに仮想IPが割り振られ、同じネットワークに属するコンテナ間で通信が可能&lt;/li&gt;&#xA;&lt;li&gt;こうすることでコンテナ同士はコンテナ名で互いに名前解決して通信できる&lt;/li&gt;&#xA;&lt;li&gt;少し深掘りすると..&#xA;&lt;ul&gt;&#xA;&lt;li&gt;何も指定せずにコンテナ起動すると、docker0という名前のbridgeネットワークに所属する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;docker0というのははホストOS上に仮想ブリッジという仮想スイッチ&lt;/li&gt;&#xA;&lt;li&gt;hostネットワーク &amp;ndash; docker0（仮想ブリッジ） &amp;ndash; コンテナA, B&amp;hellip;という構成&lt;/li&gt;&#xA;&lt;li&gt;この構成では、各コンテナに独立した仮想ネットワーク内のIPが与えられ、同じネットワークにいるコンテナ間はIPやホスト名で通信できる&lt;/li&gt;&#xA;&lt;li&gt;コンテナに対し、外部からアクセスしたい場合はNAT変換によるポートフォワードが必要(ex: &lt;code&gt;docker run -p 8080:80 nginx&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Linuxカーネルのbridgeネットワークを使用する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;host&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#host&#34;&gt;host&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテナがホストのIPアドレスとポート空間（ネットワーク名前空間）をそのまま使う&#xA;&lt;ul&gt;&#xA;&lt;li&gt;仮想NICやブリッジを介さずに、直接ホストのIP・ポート空間にアクセスできる&lt;/li&gt;&#xA;&lt;li&gt;例：コンテナが80番でListenすると、それはホスト側の80番ポートを使うことになる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;オーバーヘッドが少ない分通信が速いが、ポートの競合に注意する必要がある&lt;/li&gt;&#xA;&lt;li&gt;ホスト側のlocalhost:80等でそのままコンテナにアクセスできるような仕組み&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;none&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#none&#34;&gt;none&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテナにネットワークを割り当てない&lt;/li&gt;&#xA;&lt;li&gt;セキュリティ上、外部から完全に切り離したい時に使う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;docker-composeにおけるネットワークの考え方&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#docker-compose%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8b%e3%83%8d%e3%83%83%e3%83%88%e3%83%af%e3%83%bc%e3%82%af%e3%81%ae%e8%80%83%e3%81%88%e6%96%b9&#34;&gt;Docker Composeにおけるネットワークの考え方&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Docker Composeはマルチコンテナを簡単に定義・管理できるツール&lt;/li&gt;&#xA;&lt;li&gt;内部ネットワークは自動で作成される&lt;/li&gt;&#xA;&lt;li&gt;各サービスは、自動で同じカスタムネットワークに所属するので、互いにサービス名で名前解決が可能となる（内部DNSによって解決されている）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;volume&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#volume&#34;&gt;Volume&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;データを永続化するための機能&lt;/li&gt;&#xA;&lt;li&gt;Dockerコンテナは基本的にはエフェメラル（短命）なもので、ライフサイクルの終了とともにコンテナ上で作成されたファイルは消失する&lt;/li&gt;&#xA;&lt;li&gt;ボリュームタイプには以下の2種類がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;data-volume&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#data-volume&#34;&gt;Data Volume&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテナのライフサイクルの外で管理されるファイル/ディレクトリの設定&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-v &amp;lt;CONTAINER PATH&amp;gt;&lt;/code&gt; or &lt;code&gt;-v &amp;lt;HOST PATH&amp;gt;:&amp;lt;CONTAINER PATH&amp;gt;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;コンテナの外側＝ホスト側にファイルが保管される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;data-volume-container&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#data-volume-container&#34;&gt;Data Volume Container&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;他のコンテナで指定されているボリュームを参照するための機能（コンテナ間でボリュームを共有する）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;--volumes-from&lt;/code&gt;でコンテナ名を指定することで、別のコンテナのボリュームを参照できる&lt;/li&gt;&#xA;&lt;li&gt;今の時代では、Named Volume(&lt;code&gt;-v mydata:data&lt;/code&gt;)や上記のData VolumeのBind Mount(&lt;code&gt;-v &amp;lt;HOST PATH&amp;gt;:&amp;lt;CONTAINER PATH&amp;gt;&lt;/code&gt;)を使用するケースが多そう&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Named Volumeの補足として、Linuxの場合は大抵&lt;code&gt;/var/lib/docker/volumes/mydata/_data/&lt;/code&gt;に保存される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;プロダクションでの活用tips&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#%e3%83%97%e3%83%ad%e3%83%80%e3%82%af%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%a7%e3%81%ae%e6%b4%bb%e7%94%a8tips&#34;&gt;プロダクションでの活用Tips&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;セキュリティ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3&#34;&gt;セキュリティ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;rootユーザーを使わない&lt;/li&gt;&#xA;&lt;li&gt;野良のイメージをベースイメージにしない&lt;/li&gt;&#xA;&lt;li&gt;ビルド時に機微情報を与えない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ビルド時にパスワードや秘密鍵のような機微情報を与え、最終イメージに残らないようにする&lt;/li&gt;&#xA;&lt;li&gt;ビルド後に環境変数として渡すことがベストプラクティス&lt;/li&gt;&#xA;&lt;li&gt;もし仮にプライベートリポジトリをクローンするなどをしたい場合、&amp;ndash;secretや&amp;ndash;sshオプションを使用する(シークレット情報を格納したファイルを渡すイメージ)ことで、ビルド時に一時的にファイルにアクセスし、最終的なイメージには残らないようにセキュアなビルドを行うようにする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;この方法がなぜイメージに残らないのかというと、一時的なマウント(仮想的なtmpfs)としてビルド中のコンテナに提供されるだけであり、COPYやRUNコマンドで明示的に保存しない限り、イメージのレイヤーには一切含まれないため&lt;/li&gt;&#xA;&lt;li&gt;逆に1行の中でRUN echo &amp;ldquo;secret&amp;rdquo; &amp;gt; /tmp/hoge.txt &amp;amp;&amp;amp; rm -f /tmp/hoge.txtなどとまとめれば、レイヤーのスナップショットには残らない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これを2行に分けてしまうとRUN echo &amp;ldquo;secret&amp;rdquo; &amp;gt; /tmp/hoge.txtのみキャッシュが効いてしまい、最終イメージにファイルがそのまま残ってしまう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;.dockerignoreファイルでローカルの不要なパスを無視する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;.envのようなDBへの接続情報が記載されているようなファイルをビルドに含めないように、.dockerignoreを管理する（そうすればビルド時に無視される）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;具体的には、Dockerクライアントはdocker build実行時にビルドコンテキスト全体をDockerデーモンに送るが、.dockerignoreで指定されたものは転送対象から除外される（COPYコマンドでも同じ）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;まぁそもそも.envに直接ベタでセキュアな情報を残すのも良くないとは思うが（ローカルでは必要ないはずだし、クラウド環境の秘匿情報はクラウド上の適した場所＝AWSならSecretsManager等に保存するべきはずだし..）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;イメージを塩漬けにしない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ECRのイメージスキャンやDependabot Security Update等を活用したら良さそう&lt;/li&gt;&#xA;&lt;li&gt;GitHub ActionsでDocker社公式のdocker/scout-actionというCVEベースの脆弱性検知を行ってくれるみたい&lt;/li&gt;&#xA;&lt;li&gt;Dockerfileでマルチステージビルドを行い、Dockerfile内でセキュリティツールを実行する&lt;/li&gt;&#xA;&lt;li&gt;Snykをサイドカーとして動かしてリアルタイムでの自動検知&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ファイルのマウントが必要な場合は最小限にする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ホストのファイルをマウントする場合はRead-Onlyなど権限は必要最低限にする&lt;/li&gt;&#xA;&lt;li&gt;特にdockerソケット(&lt;code&gt;/var/run/docker.sock&lt;/code&gt;)の扱いは注意&#xA;&lt;ul&gt;&#xA;&lt;li&gt;dockerソケットとは、Dockerデーモンが提供するUNIXソケットファイル&lt;/li&gt;&#xA;&lt;li&gt;このソケットを通じて、docker buildやrunなどのCLIコマンドはデーモンと通信している（つまりDocker APIの入口）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ホストファイルシステムの改ざん（削除して破壊等）やホストネットワークの操作・盗聴などなど&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ただ、CIや監視などでdockerソケットのマウントを要求するツールはあるので、その場合はRead-Onlyでマウントするようにする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;マルチステージビルド&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#%e3%83%9e%e3%83%ab%e3%83%81%e3%82%b9%e3%83%86%e3%83%bc%e3%82%b8%e3%83%93%e3%83%ab%e3%83%89&#34;&gt;マルチステージビルド&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;イメージのサイズが大きいとPullに時間がかかってしまい、リードタイムが長くなる&lt;/li&gt;&#xA;&lt;li&gt;リードタイムが長くなると、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;デプロイ・ロールバックが遅くなる&lt;/li&gt;&#xA;&lt;li&gt;スケールアウトが遅くなり、コンテナ起動が間に合わず、リクエストを捌けなくなる&lt;/li&gt;&#xA;&lt;li&gt;レジストリの保存料が高くなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;イメージの仕組みと設計&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#%e3%82%a4%e3%83%a1%e3%83%bc%e3%82%b8%e3%81%ae%e4%bb%95%e7%b5%84%e3%81%bf%e3%81%a8%e8%a8%ad%e8%a8%88&#34;&gt;イメージの仕組みと設計&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DockerイメージはDockerfileによって作成されるスナップショットであり、そのDockerイメージをもとに起動するのがコンテナ&lt;/li&gt;&#xA;&lt;li&gt;1コンテナ1プロセスの原則&#xA;&lt;ul&gt;&#xA;&lt;li&gt;なぜ1コンテナ1プロセスが良いか？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可観測性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プロセス単位でメトリクスやログ収集がしやすい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;責務の明確化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;まぁ責務は明確にして分離すべきという話&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;リソース制御&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPUやメモリの利用量をプロセス単位で制御できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;障害隔離性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;複数のプロセスが同一コンテナにあると、一方のクラッシュがもう一方に影響しやすい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;とは言っても、全てのケースで1コンテナ＝1プロセスといく訳ではないので、1つのコンテナにつき1つの責務を目安にすると良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;コンテナ設計の指針となるThe Twelve-Factor App&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://12factor.net/ja/&#34;&gt;The Twelve-Factor App （日本語訳）&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ファイルシステム&#xA;&lt;ul&gt;&#xA;&lt;li&gt;イメージはRead-Onlyで、その上にRead-Write可能なコンテナレイヤが立ち上がるのがイメージとコンテナの仕組み&#xA;&lt;ul&gt;&#xA;&lt;li&gt;下位コンポーネントがイメージ（Read-Only）、上位コンポーネントがコンテナ（Read-Write）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ステートレスなコンテナにする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテナは廃棄容易性に優れている反面、データの永続化を苦手としている&lt;/li&gt;&#xA;&lt;li&gt;ステートを持たないことで特定の環境に依存せず、高い可搬性を実現できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ログは標準出力に出す&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ファイルに吐くとステートを持つことになる&lt;/li&gt;&#xA;&lt;li&gt;標準出力に吐いて収集するようにする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;dockerfileのベストプラクティス&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#dockerfile%e3%81%ae%e3%83%99%e3%82%b9%e3%83%88%e3%83%97%e3%83%a9%e3%82%af%e3%83%86%e3%82%a3%e3%82%b9&#34;&gt;Dockerfileのベストプラクティス&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;軽量なベースイメージを選択する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;公式が提供するイメージは軽量なslimというタグがついたイメージが存在する&lt;/li&gt;&#xA;&lt;li&gt;Google Cloudはdistrolessというシェルなどが入っていないシンプルで軽量なイメージを提供している&lt;/li&gt;&#xA;&lt;li&gt;理想はdisrolessだが、シェルなどのツール群が入っていないのでまずはslimを使用するのがおすすめ&lt;/li&gt;&#xA;&lt;li&gt;alpineイメージがおすすめできない理由&#xA;&lt;ul&gt;&#xA;&lt;li&gt;軽量ではあるが、alpineのベースOSの歴史的系異常扱いが非常に難しい&lt;/li&gt;&#xA;&lt;li&gt;元々フロッピーディスクに入るような軽量なOSとして開発された軽量化に特化したもので、逆にそれ以外の非機能要件を満たせないことが多々ある&lt;/li&gt;&#xA;&lt;li&gt;調べると色々出てくるけど、基本的には標準ライブラリが（一般的なLinuxディストリビューションと）異なるための互換性が弱いこととパフォーマンス面に懸念があることっぽい&#xA;&lt;ul&gt;&#xA;&lt;li&gt;参考: &lt;a href=&#34;https://engineering.nifty.co.jp/blog/26586&#34;&gt;とりあえずでDockerイメージにAlpine Linuxを選択するのはやめましょうという話 - NIFTY engineering&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;.dockerignoreを使用する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dockerビルド時に無視するファイル・ディレクトリを指定することができる&lt;/li&gt;&#xA;&lt;li&gt;Dockerfile自体不要だし、node_modulesもイメージビルド時にインストールするから不要とかそんな感じ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ビルド時に複数のアーキテクチャに対応させる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Docker v19からbuildxというサブコマンドが増えた（ex: &lt;code&gt;docker buildx build&lt;/code&gt;）&lt;/li&gt;&#xA;&lt;li&gt;以下のようなコマンドで、複数アーキテクチャに対応可能&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  $ docker buildx build \&#xA;  --load \&#xA;  --platform linux/amd64,linux/arm64 \&#xA;  -t multi-platform \&#xA;  .&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;本番とローカルでアーキテクチャが異なる場合に便利&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;自分で調べたこと&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#%e8%87%aa%e5%88%86%e3%81%a7%e8%aa%bf%e3%81%b9%e3%81%9f%e3%81%93%e3%81%a8&#34;&gt;自分で調べたこと&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;識別子&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#%e8%ad%98%e5%88%a5%e5%ad%90&#34;&gt;識別子&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;Dockerのイメージやコンテナを識別する時、結局何で識別するんだっけ？となりがちなのでまとめる。&#xA;ここでいう識別というのは「イメージを指定してコンテナ起動」とか「コンテナを指定して停止・削除する」とかその辺りを指してます。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;イメージ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;イメージ名で識別する&lt;/li&gt;&#xA;&lt;li&gt;イメージ名は「リポジトリ名:タグ名」で構成される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;タグ名は省略可能で、省略した場合はlatestが付与される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;docker build -t repository-name:tag-name&lt;/code&gt; といった形で&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;コンテナ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテナ名 or コンテナID&lt;/li&gt;&#xA;&lt;li&gt;コンテナ名は、起動時に指定が可能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;docker run --name mycontainer image-name&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;コンテナIDは、起動時に自動付与される一意の識別子&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通常64文字の英数字だが、先頭の12文字程度で識別可能&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;docker ps&lt;/code&gt;で確認可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>試して理解 Linuxのしくみ</title>
      <link>http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/</link>
      <pubDate>Wed, 18 Jun 2025 11:40:43 +0900</pubDate>
      <guid>http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;第1章-linuxの概要&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e7%ac%ac1%e7%ab%a0-linux%e3%81%ae%e6%a6%82%e8%a6%81&#34;&gt;第1章 Linuxの概要&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;プログラムとプロセス&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%a0%e3%81%a8%e3%83%97%e3%83%ad%e3%82%bb%e3%82%b9&#34;&gt;プログラムとプロセス&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Linuxではさまざまなプログラム（一連の命令）が動いている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンパイラ言語ではビルド後の実行ファイルがプログラムで、スクリプト言語ではソースコードそのものがプログラムとなる&lt;/li&gt;&#xA;&lt;li&gt;そしてカーネルもプログラムの1種&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;マシンの電源を入れるとまずカーネルが起動する。それ以外のすべてのプログラムはカーネルの後に起動する。&lt;/li&gt;&#xA;&lt;li&gt;起動後に動作中のプログラムのことを「プロセス」という（広義にはこれもプログラムと呼ぶこともある）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;カーネル&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e3%82%ab%e3%83%bc%e3%83%8d%e3%83%ab&#34;&gt;カーネル&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;カーネルとは何か？なぜ必要か？というのをプロセスがストレージデバイスに直接アクセスできるシステムを例に考えてみる&lt;/li&gt;&#xA;&lt;li&gt;例えばある異なる別のプロセスの実行順序が制御されず、意図しない領域へのアクセスができてしまうと問題になる&lt;/li&gt;&#xA;&lt;li&gt;このような問題に対処するのが、（ハードウェアの力を借りた）カーネルである&lt;/li&gt;&#xA;&lt;li&gt;一般的なPCやサーバーのCPUには、カーネルモードとユーザーモードという2つのモードがある&lt;/li&gt;&#xA;&lt;li&gt;Linuxでは、カーネル（モード）のみがデバイスにアクセスできる&lt;/li&gt;&#xA;&lt;li&gt;それに対して、プロセスはユーザーモードで動作するため、デバイスにアクセスできないので、カーネルを介して間接的にデバイスにアクセスする&lt;/li&gt;&#xA;&lt;li&gt;まとめると&#xA;&lt;ul&gt;&#xA;&lt;li&gt;カーネルは、システム内の全てのプロセスが共有するリソースを一元管理して、システム上のプロセスに配分する&lt;/li&gt;&#xA;&lt;li&gt;そのために、カーネルモードで動作するプログラムが「カーネル」なのである&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;システムコール&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e3%82%b3%e3%83%bc%e3%83%ab&#34;&gt;システムコール&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;システムコールとは、プロセスがカーネルに処理を依頼するための方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プロセスやメモリ、通信、ファイルシステムやデバイス管理あたり&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;プロセスはユーザーモードで動いているが、システムコールを発行すると、CPUにおいて例外イベントが発生する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これをきっかけに&lt;strong&gt;CPUのモードがユーザーモードからカーネルモードに遷移&lt;/strong&gt;し、依頼内容に応じたカーネルの処理が動作する&lt;/li&gt;&#xA;&lt;li&gt;この動作が終わると、再びユーザーモードに戻ってプロセス本体の動作を継続する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;システムコールの冒頭で、プロセスからカーネルへの要求が正当なものかをチェックする（保有している量を超えるメモリが要求されていないかなど）&lt;/li&gt;&#xA;&lt;li&gt;システムコール以外で、プロセスからCPUのモードを変更する方法はない（もしあったら任意の悪意あるプロセスから攻撃できてしまう）&lt;/li&gt;&#xA;&lt;li&gt;システムコール発行の可視化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Goでhello worldを出力するプログラムを書き、straceコマンドでシステムコールを確認&lt;/li&gt;&#xA;&lt;li&gt;自分の環境では&lt;code&gt;write(1, &amp;quot;Hello, World!\n&amp;quot;, 14)&lt;/code&gt;と出力されていた&#xA;&lt;ul&gt;&#xA;&lt;li&gt;このwriteがシステムコールにあたるもの&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;カーネルに処理を依頼する時は、システムコールを発行することを確認できた&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;システムコールしている時間の割合&#xA;&lt;ul&gt;&#xA;&lt;li&gt;sarコマンドで論理CPUの処理割合を確認&lt;/li&gt;&#xA;&lt;li&gt;親プロセスのプロセスIDを取得するループ処理を実行し、CPUがユーザーモード・カーネルモードがそれぞれのモードで動いていることを数値で確認できた&lt;/li&gt;&#xA;&lt;li&gt;この辺りのシステムの統計情報は、システムが想定通りに動いているかを把握するために非常に重要&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これを人間やるのが辛いので、ZabbixやDatadogなどのツールを用いて、正常状態を定義し、異常になった際に通知するアラート機能と合わせて使用することが多い&lt;/li&gt;&#xA;&lt;li&gt;また併せて、数値の羅列では可視性が良くないので、ダッシュボード（上記のツールに包含されていることが多い）もよく使われる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ライブラリ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e3%83%a9%e3%82%a4%e3%83%96%e3%83%a9%e3%83%aa&#34;&gt;ライブラリ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;標準Cライブラリ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;C言語にはISOによって定められた標準ライブラリがある（Linuxでもこの標準Cライブラリが提供されている）&lt;/li&gt;&#xA;&lt;li&gt;通常はGNUプロジェクトが提供するglibcを標準Cライブラリとして使用する（単にlibcと表記されることが多い）&lt;/li&gt;&#xA;&lt;li&gt;libcは、ユーザースペース用のライブラリ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;printf、malloc、fopen、write など、アプリケーションが便利に使える関数を提供している&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;そもそも標準Cライブラリってなぜ必要？何をする？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ほとんどのプログラムがlibcを内部的に利用している（高級言語たちのランタイムも同様）&lt;/li&gt;&#xA;&lt;li&gt;LinuxのようなUNIX系OSでは、ユーザープログラムとカーネルの間を取り持つ役目としてlibcが使われる&lt;/li&gt;&#xA;&lt;li&gt;libcは各ユーザーモードで動いているプロセスから、ファイル書き込みや標準出力などの処理依頼を受けて、内部的にシステムコールを発している&lt;/li&gt;&#xA;&lt;li&gt;つまりlibcはカーネルとのインターフェイス層みたいなもの&#xA;&lt;ul&gt;&#xA;&lt;li&gt;そもそもカーネル本体がほぼC言語で書かれている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ldd /bin/echo&lt;/code&gt;でechoコマンドがどのようなライブラリをリンクしているかを確認&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;libc.so.6 =&amp;gt; /lib/aarch64-linux-gnu/libc.so.6&lt;/code&gt;という結果から、内部的にlibcを利用して動いていることがわかる&lt;/li&gt;&#xA;&lt;li&gt;catもpython3コマンドでも同様&lt;/li&gt;&#xA;&lt;li&gt;普段C言語を触ることは少ないが、OSレベルでは縁の下の力持ちとして重要な言語であることがわかる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;一旦ここまでまとめ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e4%b8%80%e6%97%a6%e3%81%93%e3%81%93%e3%81%be%e3%81%a7%e3%81%be%e3%81%a8%e3%82%81&#34;&gt;一旦ここまでまとめ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ユーザープロセスがechoなどの処理を実行する&lt;/li&gt;&#xA;&lt;li&gt;echoの処理は内部的にlibcが提供する関数を実行する(write())&lt;/li&gt;&#xA;&lt;li&gt;write()が実行されると、内部でアセンブリを用いてsyscall命令が実行され、カーネルに処理を依頼&lt;/li&gt;&#xA;&lt;li&gt;カーネルが標準出力を行う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;ライブラリをリンクするという表現について&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e3%83%a9%e3%82%a4%e3%83%96%e3%83%a9%e3%83%aa%e3%82%92%e3%83%aa%e3%83%b3%e3%82%af%e3%81%99%e3%82%8b%e3%81%a8%e3%81%84%e3%81%86%e8%a1%a8%e7%8f%be%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6&#34;&gt;ライブラリを「リンクする」という表現について&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;p&gt;これも気になったのでちょっと調べた。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;C言語はコンパイルすると.oファイルが出来上がる&lt;/li&gt;&#xA;&lt;li&gt;その中で外部ライブラリの関数を使っていた場合、コンパイラは「この関数が必要です」と記録するが、中身は含めない&lt;/li&gt;&#xA;&lt;li&gt;その後のリンクという工程で、ライブラリの関数本体と繋げる＝リンクする必要がある&lt;/li&gt;&#xA;&lt;li&gt;.oファイルは中間ファイルであり、リンク処理が行われることで.oから.outファイルができ上がる（.outは実行ファイル）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;なぜcpuモードを分ける必要があるのか&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e3%81%aa%e3%81%9ccpu%e3%83%a2%e3%83%bc%e3%83%89%e3%82%92%e5%88%86%e3%81%91%e3%82%8b%e5%bf%85%e8%a6%81%e3%81%8c%e3%81%82%e3%82%8b%e3%81%ae%e3%81%8b&#34;&gt;なぜCPUモードを分ける必要があるのか？&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;p&gt;全部カーネルモードで動ければ、システムコール発行してCPUモード切り替えてという必要がなくなるのでは？と思ったので調べてみた&#xA;→結論、セキュリティ・安全性を守るために、CPUモードを分けている&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OSカーネルは、全プロセスの情報・全メモリ・全デバイスにアクセスできる&lt;/li&gt;&#xA;&lt;li&gt;もし普通のアプリケーション（ユーザープログラム）がカーネルと同じように動けてしまったら、他人の情報を盗んだり、OSクラッシュも可能になってしまう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;システムコールのラッパー関数&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e3%82%b3%e3%83%bc%e3%83%ab%e3%81%ae%e3%83%a9%e3%83%83%e3%83%91%e3%83%bc%e9%96%a2%e6%95%b0&#34;&gt;システムコールのラッパー関数&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;libcは標準Cライブラリだけではなく、システムコールのラッパー関数というものを提供している&lt;/li&gt;&#xA;&lt;li&gt;システムコールは、通常の関数呼び出しとは異なり、C言語などの高級言語から直接呼び出すことはできず、代わりにアーキテクチャ依存のアセンブリコードを使って呼び出す必要がある&lt;/li&gt;&#xA;&lt;li&gt;ユーザープログラムからは、各言語に対して容易されているシステムコールのラッパー関数を呼び出すだけで済む&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;静的ライブラリと共有ライブラリ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e9%9d%99%e7%9a%84%e3%83%a9%e3%82%a4%e3%83%96%e3%83%a9%e3%83%aa%e3%81%a8%e5%85%b1%e6%9c%89%e3%83%a9%e3%82%a4%e3%83%96%e3%83%a9%e3%83%aa&#34;&gt;静的ライブラリと共有ライブラリ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ライブラリは2種類ある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;静的ライブラリ: リンク時にライブラリ内の関数をプログラムに組み込む&lt;/li&gt;&#xA;&lt;li&gt;共有ライブラリ: リンク時にこのライブラリ内の関数を呼び出すといった情報だけを実行ファイルに埋め込む&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;以下の理由で共有ライブラリが多く使われてきた&#xA;&lt;ul&gt;&#xA;&lt;li&gt;システム全体としてサイズを小さくできる&lt;/li&gt;&#xA;&lt;li&gt;ライブラリに問題があった際に共有ライブラリを書き換えるだけでOK&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;静的リンクの復権&#xA;&lt;ul&gt;&#xA;&lt;li&gt;理由として、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;メモリやストレージの大容量化&lt;/li&gt;&#xA;&lt;li&gt;プログラムが1つのファイルだけで動けば、そのファイルをコピーするだけで別の環境でも動くので扱いが楽&lt;/li&gt;&#xA;&lt;li&gt;実行時に共有ライブラリをリンクしなくて良いので起動が高速&lt;/li&gt;&#xA;&lt;li&gt;共有ライブラリのDLL地獄（互換性がなくなった時のプログラムが動作しない問題）を回避&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Goは基本的にライブラリを全て静的リンクしている&lt;/li&gt;&#xA;&lt;li&gt;Goがシングルバイナリで実行できるのはこれが理由&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;各言語ランタイムとlibcの関係性&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e5%90%84%e8%a8%80%e8%aa%9e%e3%83%a9%e3%83%b3%e3%82%bf%e3%82%a4%e3%83%a0%e3%81%a8libc%e3%81%ae%e9%96%a2%e4%bf%82%e6%80%a7&#34;&gt;各言語(ランタイム)とlibcの関係性&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;気になったので調べた。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;go&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#go&#34;&gt;Go&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通常Goプログラムはlibcを使わない&lt;/li&gt;&#xA;&lt;li&gt;システムコールを使う場合は、Goのランタイムまたは標準ライブラリが直接syscallを発行している&lt;/li&gt;&#xA;&lt;li&gt;ただし、CGOを使った場合は、GoプログラムからC言語ライブラリを使うようになり、libcが必要となる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;node&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#node&#34;&gt;Node&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;内部的にC/C++で書かれたネイティブコード(libuvなど)を含み、これらがOSに対してシステムコールを発行する際にlibcを使用する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;JavaScript コード&#xA;↓&#xA;Node.js 実行環境&#xA; ├ V8エンジン（GoogleのJSエンジン）&#xA; ├ libuv（I/O処理・非同期など）&#xA; ├ C/C++コード（Nodeの本体部分）&#xA; ↓&#xA; libc.so → システムコール → Linuxカーネル&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;カーネルシステムコールのまとめ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e3%82%ab%e3%83%bc%e3%83%8d%e3%83%ab%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e3%82%b3%e3%83%bc%e3%83%ab%e3%81%ae%e3%81%be%e3%81%a8%e3%82%81&#34;&gt;カーネル・システムコールのまとめ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;デバイス制御等を行うにはカーネルモードで動作するCPUが処理をする必要がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;デバイスI/Oはハードウェアへのアクセスを含むため、特権命令が必要→カーネルモードでしか実行できない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;カーネルモードで動作するCPUに処理を依頼するにはシステムコールの発行が必要&lt;/li&gt;&#xA;&lt;li&gt;システムコールの発行にはlibcのラッパー関数を呼び出す必要がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;もしくはlibcを使わなくても、Goプログラムのように直接アセンブリ等で発行可能&lt;/li&gt;&#xA;&lt;li&gt;アセンブリは、低級言語であり、より低レベルな形で記述する必要がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;例えばNode.jsプログラムが動いている（プロセス）とした場合、Nodeランタイムに含まれるlibuvからlibc関数を実行→システムコール発行→デバイス制御等を行うという流れ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;第2章-プロセス管理基礎編&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e7%ac%ac2%e7%ab%a0-%e3%83%97%e3%83%ad%e3%82%bb%e3%82%b9%e7%ae%a1%e7%90%86%e5%9f%ba%e7%a4%8e%e7%b7%a8&#34;&gt;第2章 プロセス管理（基礎編）&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;新しくプロセスを生成する目的は「同じプログラムの処理を複数のプロセスに分けて処理する（Webサーバーの複数リクエスト受付）」と「別のプログラムを生成する」&lt;/li&gt;&#xA;&lt;li&gt;同じプロセスを生成するのは以下の流れで、libcの中でsyscallラッパー関数のfork()が実行される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;親プロセスがfork()を呼ぶ&lt;/li&gt;&#xA;&lt;li&gt;CPUがカーネルモード切り替わる（システムコール発行）&lt;/li&gt;&#xA;&lt;li&gt;カーネルがプロセスの複製を行う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;同じプロセスの生成とは&amp;hellip;？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;身の回りでよくあるのが「シェルコマンド実行」と「サーバーが複数のリクエストを捌く時」&lt;/li&gt;&#xA;&lt;li&gt;シェルコマンド実行の例では、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;親プロセスとしてbashなどが常駐している&lt;/li&gt;&#xA;&lt;li&gt;ユーザーがコマンドを実行すると、親プロセスが子プロセスを作る&lt;/li&gt;&#xA;&lt;li&gt;なぜこのようなことをするのかというと、次のコマンド入力を受け付けできるようにしておくため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;シグナル&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e3%82%b7%e3%82%b0%e3%83%8a%e3%83%ab&#34;&gt;シグナル&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;あるプロセスから他のプロセスに何かを通知して、外部から実行の流れを強制的に変えるための仕組み&lt;/li&gt;&#xA;&lt;li&gt;よく使われるのがctrl + CのSIGINT&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SIGINTを受け取ったプロセスは、デフォルトでは終了する&lt;/li&gt;&#xA;&lt;li&gt;シグナルハンドラという処理をあらかじめ登録しておくことで無視したりすることができる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SIGKILL&#xA;&lt;ul&gt;&#xA;&lt;li&gt;絶対プロセス殺すマン&lt;/li&gt;&#xA;&lt;li&gt;シグナルハンドラによる挙動変更はできない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;デーモン&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e3%83%87%e3%83%bc%e3%83%a2%e3%83%b3&#34;&gt;デーモン&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;デーモンは常駐プロセスであり、システムの開始から終了まで存在し続ける&lt;/li&gt;&#xA;&lt;li&gt;端末が割り当てられていない＝ログインセッションなどと結び付かずにバックグラウンドで動く&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;第5章-プロセス管理応用編&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e7%ac%ac5%e7%ab%a0-%e3%83%97%e3%83%ad%e3%82%bb%e3%82%b9%e7%ae%a1%e7%90%86%e5%bf%9c%e7%94%a8%e7%b7%a8&#34;&gt;第5章 プロセス管理(応用編)&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;複数のプログラムが強調動作するために、各プロセスがデータを共有したりする機能は、OSが「プロセス間通信」として提供している&lt;/li&gt;&#xA;&lt;li&gt;Linuxでは、目的別にたくさんのプロセス間の通信を提供されており、その一部を紹介する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;共有メモリ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e5%85%b1%e6%9c%89%e3%83%a1%e3%83%a2%e3%83%aa&#34;&gt;共有メモリ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;mmapシステムコールを使用する&lt;/li&gt;&#xA;&lt;li&gt;複数プロセスで同じファイルを同じメモリアドレスにマップすれば共有メモリとして使える&lt;/li&gt;&#xA;&lt;li&gt;ポインタを共有する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;シグナル-1&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e3%82%b7%e3%82%b0%e3%83%8a%e3%83%ab-1&#34;&gt;シグナル&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SIGINTなどのシグナルもプロセス間通信の1つ&lt;/li&gt;&#xA;&lt;li&gt;POSIXでは、SIGUSR1とSIGUSR2という、プログラマが自由に用途を決めて良いシグナルがある&lt;/li&gt;&#xA;&lt;li&gt;ただしシグナルは原始的な仕組みなので、送信先にシグナルが届いたという情報しか送れず、データを受け渡すには別の方法を検討する必要がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;パイプ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e3%83%91%e3%82%a4%e3%83%97&#34;&gt;パイプ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パイプを介して複数のプロセス間通信が可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;マルチプロセスとマルチスレッド&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e3%83%9e%e3%83%ab%e3%83%81%e3%83%97%e3%83%ad%e3%82%bb%e3%82%b9%e3%81%a8%e3%83%9e%e3%83%ab%e3%83%81%e3%82%b9%e3%83%ac%e3%83%83%e3%83%89&#34;&gt;マルチプロセスとマルチスレッド&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPUのマルチコア化によって、プログラムの並列動作の重要性が高まっている&lt;/li&gt;&#xA;&lt;li&gt;並列動作させるには「別のことをする複数のプログラムを同時に動かすこと」と「ある目的を持った1つのプログラムを複数の流れに分割して実行すること」&lt;/li&gt;&#xA;&lt;li&gt;このセクションでは後者の「ある目的を持った1つのプログラムを複数の流れに分割して実行すること」を説明していく&lt;/li&gt;&#xA;&lt;li&gt;この方法を実現するには「マルチプロセス」と「マルチスレッド」がある&lt;/li&gt;&#xA;&lt;li&gt;マルチプロセス: 上で説明したfork関数などを使って必要なだけプロセスを生成し、それぞれがプロセス間通信によってやり取りしながら処理していく&lt;/li&gt;&#xA;&lt;li&gt;マルチスレッド: プロセス内に複数の流れを作る&lt;/li&gt;&#xA;&lt;li&gt;マルチスレッドの長所&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ページテーブルのコピーが不要なため、生成時間が短い&lt;/li&gt;&#xA;&lt;li&gt;様々なリソースをスレッド間で共有するため、メモリをはじめリソース消費量が少ない&lt;/li&gt;&#xA;&lt;li&gt;全スレッド間でメモリを共有するため、見かけ上の協調動作がしやすい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;マルチスレッドの短所&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1つのスレッドの障害が、全スレッドに影響する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1つのスレッドが不正なアドレスを参照して異常終了した場合、プロセス全体が異常終了する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;各スレッドが実行する処理がマルチスレッドプログラムから呼び出して良いかを熟知しておく必要がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;グルーバル変数を排他制御なしにアクセスしている場合はスレッドセーフではない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;マルチスレッドプログラムを期待通りに作るのは大変なのでマルチスレッド化の恩恵を受けながら、プログラミングを簡単にする様々な方法が存在する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えばGoのgoroutineは、言語の組み込み機能によってスレッドの扱いを簡単にしている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;マルチプロセススレッドについてもう少し深掘り&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e3%83%9e%e3%83%ab%e3%83%81%e3%83%97%e3%83%ad%e3%82%bb%e3%82%b9%e3%82%b9%e3%83%ac%e3%83%83%e3%83%89%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6%e3%82%82%e3%81%86%e5%b0%91%e3%81%97%e6%b7%b1%e6%8e%98%e3%82%8a&#34;&gt;マルチプロセス・スレッドについてもう少し深掘り&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;マルチプロセス&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プロセス: OSが管理する実行中のプログラムの単位（メモリ空間を独立して持つ）&lt;/li&gt;&#xA;&lt;li&gt;プロセス間で通信するには、パイプ・ソケット・共有メモリなどが必要&lt;/li&gt;&#xA;&lt;li&gt;1つのプロセスが落ちても他に影響しにくい&lt;/li&gt;&#xA;&lt;li&gt;メリット&#xA;&lt;ul&gt;&#xA;&lt;li&gt;安定性が高い&lt;/li&gt;&#xA;&lt;li&gt;障害が局所化しやすい&lt;/li&gt;&#xA;&lt;li&gt;マルチコアCPUを最大限に活かしやすい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;デメリット&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プロセス生成や通信のオーバヘッドが大きい&lt;/li&gt;&#xA;&lt;li&gt;メモリ共有が難しい（非効率）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;マルチスレッド&#xA;&lt;ul&gt;&#xA;&lt;li&gt;スレッド: プロセスの中の処理の流れ&lt;/li&gt;&#xA;&lt;li&gt;マルチスレッドは、1つのプロセス内に複数のスレッドを作り、それぞれが並行に処理する方式&lt;/li&gt;&#xA;&lt;li&gt;スレッドは同じメモリ空間を共有する&lt;/li&gt;&#xA;&lt;li&gt;スレッド間通信がメモリ経由で行えるので簡単&lt;/li&gt;&#xA;&lt;li&gt;goroutineなど、言語ごとに実装が用意されている&lt;/li&gt;&#xA;&lt;li&gt;メリット&#xA;&lt;ul&gt;&#xA;&lt;li&gt;メモリ共有なので通信が高速&lt;/li&gt;&#xA;&lt;li&gt;スレッド生成が軽量で高速&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;デメリット&#xA;&lt;ul&gt;&#xA;&lt;li&gt;共有メモリの競合によるバグ（レースコンディション）が発生しやすい&lt;/li&gt;&#xA;&lt;li&gt;1つのスレッドがクラッシュすると、プロセス全体が落ちることがある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;「マルチスレッドを自作するのは難しい」という件&#xA;&lt;ul&gt;&#xA;&lt;li&gt;難しいポイント&#xA;&lt;ul&gt;&#xA;&lt;li&gt;スレッド生成・破棄などの管理（OSに依頼）&lt;/li&gt;&#xA;&lt;li&gt;ロックなどの制御&lt;/li&gt;&#xA;&lt;li&gt;デッドロックや競合状態への対処&lt;/li&gt;&#xA;&lt;li&gt;スレッドごとのスタック管理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;なのでgoroutineのように言語側の仕組みとして用意している&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;goroutine&#xA;&lt;ul&gt;&#xA;&lt;li&gt;軽量な仮想スレッド（※OSスレッドではない）&lt;/li&gt;&#xA;&lt;li&gt;GoランタイムがOSスレッドを数本確保していて、goroutineをスケジュールしている&lt;/li&gt;&#xA;&lt;li&gt;ユーザーはスレッドプールやロックなどを意識せずに並行処理できる&lt;/li&gt;&#xA;&lt;li&gt;goroutineは仮想CPUにキューされて、仮想CPUが空いているOSスレッドにgoroutineをアサインする流れ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;スケジューラとは？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;複数の実行単位（スレッド・タスク）をどのCPUコアでいつ実行するかを決める制御機構のこと&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;第6章-デバイスアクセス&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e7%ac%ac6%e7%ab%a0-%e3%83%87%e3%83%90%e3%82%a4%e3%82%b9%e3%82%a2%e3%82%af%e3%82%bb%e3%82%b9&#34;&gt;第6章 デバイスアクセス&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プロセスはデバイスに直接アクセスできない&lt;/li&gt;&#xA;&lt;li&gt;代わりにカーネルに代行してもらう&#xA;&lt;ul&gt;&#xA;&lt;li&gt;具体的には、デバイスファイルという特殊なファイルがインターフェイスとなって操作を行う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;プロセスがデバイスファイルを操作すると、カーネルの中のデバイスドライバというソフトウェアが、ユーザの代わりにデバイスにアクセスする&lt;/li&gt;&#xA;&lt;li&gt;デバイスファイルは、&lt;code&gt;/dev/&lt;/code&gt;配下にある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;console  core  fd  full  mqueue  null  ptmx  pts  random  shm  stderr  stdin  stdout  tty  urandom  zero&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;第7章-ファイルシステム&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e7%ac%ac7%e7%ab%a0-%e3%83%95%e3%82%a1%e3%82%a4%e3%83%ab%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0&#34;&gt;第7章 ファイルシステム&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;各種デバイスはデバイスファイルを介してアクセスできるが、ストレージデバイスはほとんどファイルシステムを介してアクセスする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;第11章-コンテナ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#%e7%ac%ac11%e7%ab%a0-%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a&#34;&gt;第11章 コンテナ&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;namespace&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/013_linux%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF/#namespace&#34;&gt;namespace&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;システム上の色々なリソースに存在し、所属プロセスに対し見かけ上は独立したリソースにみせる機能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Terraformの公式ドキュメントを読み漁る</title>
      <link>http://localhost:1313/posts/terraform-docs/</link>
      <pubDate>Sun, 15 Jun 2025 23:49:25 +0900</pubDate>
      <guid>http://localhost:1313/posts/terraform-docs/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://developer.hashicorp.com/terraform&#34;&gt;https://developer.hashicorp.com/terraform&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;入門&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/terraform-docs/#%e5%85%a5%e9%96%80&#34;&gt;入門&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Terraformはプロバイダを利用して、各クラウドのAPIを利用できるようにしている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>SQS設計</title>
      <link>http://localhost:1313/posts/sqs/</link>
      <pubDate>Sat, 14 Jun 2025 15:07:36 +0900</pubDate>
      <guid>http://localhost:1313/posts/sqs/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;sqsの構成要素&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/sqs/#sqs%e3%81%ae%e6%a7%8b%e6%88%90%e8%a6%81%e7%b4%a0&#34;&gt;SQSの構成要素&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パブリッシャー &amp;mdash; SQS &amp;mdash; コンシューマー(ワーカー)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;キューの種類&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/sqs/#%e3%82%ad%e3%83%a5%e3%83%bc%e3%81%ae%e7%a8%ae%e9%a1%9e&#34;&gt;キューの種類&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;標準&#xA;&lt;ul&gt;&#xA;&lt;li&gt;高スループット、順序保証なし、少なくとも1回の配信（重複あり）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;FIFO&#xA;&lt;ul&gt;&#xA;&lt;li&gt;順序保証（メッセージグループ単位）、重複排除&lt;/li&gt;&#xA;&lt;li&gt;注文・決済処理など&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;多くのケースでは標準で良いはず&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ただし同じメッセージに対して複数処理が走っても結果が同じになる「冪等性」を担保すること&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;sqs自体の設定&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/sqs/#sqs%e8%87%aa%e4%bd%93%e3%81%ae%e8%a8%ad%e5%ae%9a&#34;&gt;SQS自体の設定&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可視性タイムアウト&#xA;&lt;ul&gt;&#xA;&lt;li&gt;メッセージを取得した後、指定時間は他のコンシューマからは見えなくなる設定&lt;/li&gt;&#xA;&lt;li&gt;長すぎると遅延、短すぎると再処理されてしまうリスクがある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;デッドレターキュー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;処理失敗したメッセージを隔離して格納するキュー&lt;/li&gt;&#xA;&lt;li&gt;エラーハンドリングや再試行の仕組みが必要なら必須&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;sqs-vs-sns--sqs&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/sqs/#sqs-vs-sns--sqs&#34;&gt;SQS vs SNS + SQS&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;単一SQSかSNS＋SQS構成&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;sqs-only&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/sqs/#sqs-only&#34;&gt;SQS Only&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;シンプルな設計&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;snssqs構成&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/sqs/#snssqs%e6%a7%8b%e6%88%90&#34;&gt;SNS＋SQS構成&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;前段にSNSを配置することで、複数のSQSにメッセージを通知できる（ファンアウト構成）&lt;/li&gt;&#xA;&lt;li&gt;通知先を増やしたい場合は、SQSを新しく作り、SNSの通知先を登録するだけで良い（アプリケーション改修不要）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当初はメール通知だけでも良いけど、その後プッシュ通知も送りたいとかなる可能性がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;コンシューマー設計&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/sqs/#%e3%82%b3%e3%83%b3%e3%82%b7%e3%83%a5%e3%83%bc%e3%83%9e%e3%83%bc%e8%a8%ad%e8%a8%88&#34;&gt;コンシューマー設計&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;大前提としてシンプルに作れるのはLambda&lt;/li&gt;&#xA;&lt;li&gt;長時間実行、メモリをたくさん使うような処理なのであればECSやEC2が次点の選択肢となる&lt;/li&gt;&#xA;&lt;li&gt;判断軸&#xA;&lt;ul&gt;&#xA;&lt;li&gt;処理時間: Lambdaは最長15分&lt;/li&gt;&#xA;&lt;li&gt;メモリ: Lambdaは10GBまで&lt;/li&gt;&#xA;&lt;li&gt;デプロイ:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;イベントソース型Lambdaであれば暗黙的にポーリング・メッセージ受信をやってくれるので気にしなくて良い&lt;/li&gt;&#xA;&lt;li&gt;代わりにECSなどを使用する場合はデプロイ機構を検討する必要がある（常時起動 or 定期実行）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;オートスケーリング:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Lambdaだと考慮不要&lt;/li&gt;&#xA;&lt;li&gt;自前するケースだと、メッセージ数に応じてスケーリング設定をしたりする必要がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;EventBridge Pipesを使うという選択肢&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ワーカーがLambda以外の場合で良いかも？&lt;/li&gt;&#xA;&lt;li&gt;SQSとECSの間に置き、中間処理を任せる&lt;/li&gt;&#xA;&lt;li&gt;ポーリング自動、フィルタ・変換等を行なってくれる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アプリケーションロジックにこれらの処理を書かなくて良くなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/sqs/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://dev.classmethod.jp/articles/sqs-consumer-pattern/&#34;&gt;Amazon SQSワーカーのアーキテクチャーをLambdaイベントソース/EventBridge Pipes/独自の3パターンで比較してみた | DevelopersIO&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>AWS Transfer Family For SFTP</title>
      <link>http://localhost:1313/posts/transfer-family-for-sftp/</link>
      <pubDate>Mon, 09 Jun 2025 23:48:17 +0900</pubDate>
      <guid>http://localhost:1313/posts/transfer-family-for-sftp/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;やりたいこと&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/transfer-family-for-sftp/#%e3%82%84%e3%82%8a%e3%81%9f%e3%81%84%e3%81%93%e3%81%a8&#34;&gt;やりたいこと&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;バッチ処理で出力したファイルをS3に置く&lt;/li&gt;&#xA;&lt;li&gt;そのファイルをSFTPで任意のPCからダウンロードする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;登場人物&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/transfer-family-for-sftp/#%e7%99%bb%e5%a0%b4%e4%ba%ba%e7%89%a9&#34;&gt;登場人物&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;バッチ処理環境&lt;/li&gt;&#xA;&lt;li&gt;S3バケット&lt;/li&gt;&#xA;&lt;li&gt;Transfer Family For SFTP（SFTPサーバー）&lt;/li&gt;&#xA;&lt;li&gt;SFTPクライアント&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;必要な設定&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/transfer-family-for-sftp/#%e5%bf%85%e8%a6%81%e3%81%aa%e8%a8%ad%e5%ae%9a&#34;&gt;必要な設定&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;S3バケット作成&#xA;&lt;ul&gt;&#xA;&lt;li&gt;バケットポリシー定義&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Transfer Family For SFTP作成&#xA;&lt;ul&gt;&#xA;&lt;li&gt;バックエンドはS3を設定&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SFTPユーザーの作成&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ユーザーのSSH公開鍵を設定（作成する必要あり）&lt;/li&gt;&#xA;&lt;li&gt;ホームディレクトリ: 転送を行うS3バケットのパス名&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SFTPクライアント設定（WinSCPとか）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接続先&lt;/li&gt;&#xA;&lt;li&gt;ユーザー名（上記で設定したユーザー名）&lt;/li&gt;&#xA;&lt;li&gt;パスワード（秘密鍵）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>ゼロからはじめるLinuxサーバー構築・運用ガイド</title>
      <link>http://localhost:1313/posts/009_%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E3%81%AF%E3%81%98%E3%82%81%E3%82%8Blinux%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E6%A7%8B%E7%AF%89%E9%81%8B%E7%94%A8%E3%82%AC%E3%82%A4%E3%83%89/</link>
      <pubDate>Fri, 06 Jun 2025 19:15:39 +0900</pubDate>
      <guid>http://localhost:1313/posts/009_%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E3%81%AF%E3%81%98%E3%82%81%E3%82%8Blinux%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E6%A7%8B%E7%AF%89%E9%81%8B%E7%94%A8%E3%82%AC%E3%82%A4%E3%83%89/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;1章-linuxって何&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/009_%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E3%81%AF%E3%81%98%E3%82%81%E3%82%8Blinux%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E6%A7%8B%E7%AF%89%E9%81%8B%E7%94%A8%E3%82%AC%E3%82%A4%E3%83%89/#1%e7%ab%a0-linux%e3%81%a3%e3%81%a6%e4%bd%95&#34;&gt;1章 Linuxって何？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;1-linuxとはどのようなosか&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/009_%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E3%81%AF%E3%81%98%E3%82%81%E3%82%8Blinux%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E6%A7%8B%E7%AF%89%E9%81%8B%E7%94%A8%E3%82%AC%E3%82%A4%E3%83%89/#1-linux%e3%81%a8%e3%81%af%e3%81%a9%e3%81%ae%e3%82%88%e3%81%86%e3%81%aaos%e3%81%8b&#34;&gt;1. LinuxとはどのようなOSか&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Linux誕生当初はUnixが強力なOSとして存在していたが、一般の人たちが使える状況ではなかった&#xA;&lt;ul&gt;&#xA;&lt;li&gt;そこでUnixっぽいOSとして作られたのがLinux&lt;/li&gt;&#xA;&lt;li&gt;Unixは発展の過程でいくつも枝分かれしてきており、現在Unixという1つのOSがあるわけではない&lt;/li&gt;&#xA;&lt;li&gt;現在あるものとしては、macOSやAIXなどがある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Linuxは、上記のUnixとは異なり、ゼロから開発されたOSである&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ただし、Unixの標準仕様であるPOSIXに準拠しているので、Unix系OSと呼ばれる&lt;/li&gt;&#xA;&lt;li&gt;Linuxは、Unix系OSと多くのコマンドが共通しており、Unix向けソフトウェアの多くはLinuxでも使用できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Linuxというのは「カーネル」の名前&#xA;&lt;ul&gt;&#xA;&lt;li&gt;カーネルは、OSの中核となるプログラムであり、カーネルだけではOSとして使えない&lt;/li&gt;&#xA;&lt;li&gt;利用者とカーネルの仲介役となる「シェル」等があることで初めてOSとして利用できる&lt;/li&gt;&#xA;&lt;li&gt;カーネルとこれら周辺のソフトウェアを組み合わせたものを「ディストリビューション」と呼ぶ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ディストリビューションは、大きく分けるとRedHat系とDebian系の2つの系統がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;RedHat系&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Fedora: 先進的。半年に1回バージョンアップがあるので長期利用には向かない。&lt;/li&gt;&#xA;&lt;li&gt;RHEL: 企業向け。Fedoraの成果を取り込んで安定したソフトウェアを提供。バージョンアップ速度もゆったり。&lt;/li&gt;&#xA;&lt;li&gt;CentOS Stream:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;元々CentOSは、RHELからサポートを取り除いた同じバイナリ互換性を持っており、人気だった。&lt;/li&gt;&#xA;&lt;li&gt;が、CentOSはサポートが停止され、RHELの開発版に近い位置付けでCentOS Streamが提供される形となっている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Rocky Linux: 従来のCentOSに近い。中期的なスパンで安定してアップデートされる。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Debian系&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Debian GNU/Linux&#xA;&lt;ul&gt;&#xA;&lt;li&gt;フリーソフトウェアだけで作られており、長い歴史がある&lt;/li&gt;&#xA;&lt;li&gt;無償&lt;/li&gt;&#xA;&lt;li&gt;サーバー・クライアントどちらでも使用可能&lt;/li&gt;&#xA;&lt;li&gt;初心者にはややハードルが高い&lt;/li&gt;&#xA;&lt;li&gt;GNUとは？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;フリーソフトウェアのみを使用し、UNIX互換のコンピュータ環境を作ることを目標としているプロジェクト&lt;/li&gt;&#xA;&lt;li&gt;カーネルはGNUの製品ではないものの、ディストリビューションの多くはGNUの製品であり、GNU/Linuxと呼ぶべきという意見もある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Ubuntu&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Debian GNU/Linuxから枝分かれした派生ディストリビューション&lt;/li&gt;&#xA;&lt;li&gt;初心者に配慮した使いやすさを追求&lt;/li&gt;&#xA;&lt;li&gt;デスクトップ用途で人気があり、サーバー版もある&lt;/li&gt;&#xA;&lt;li&gt;半年に1度の(メジャー)バージョンアップ&lt;/li&gt;&#xA;&lt;li&gt;2年に1回LTS版が出るので、バージョンアップをなるべく避けたい場合はそちらを使うと良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;2-linuxとソフトウェア&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/009_%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E3%81%AF%E3%81%98%E3%82%81%E3%82%8Blinux%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E6%A7%8B%E7%AF%89%E9%81%8B%E7%94%A8%E3%82%AC%E3%82%A4%E3%83%89/#2-linux%e3%81%a8%e3%82%bd%e3%83%95%e3%83%88%e3%82%a6%e3%82%a7%e3%82%a2&#34;&gt;2. Linuxとソフトウェア&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;img src=&#34;https://www.pc-koubou.jp/magazine/wp-content/uploads/2019/03/iiyama_linux_01.png&#34; alt=&#34;image&#34;&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;シェル:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;カーネルとユーザーを仲介するプログラム&lt;/li&gt;&#xA;&lt;li&gt;入力を受け付けて実行したりする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;コマンド:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;多くは実行形式のプログラム&lt;/li&gt;&#xA;&lt;li&gt;シェルにコマンド名を入力すると対応するプログラムが実行される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ライブラリ:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プログラムの共通部品&lt;/li&gt;&#xA;&lt;li&gt;プログラムが正常動作するには、そのプログラムが利用するライブラリが適切なバージョンでインストールされている必要がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;GUI:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;グラフィカルなユーザーインターフェイス&lt;/li&gt;&#xA;&lt;li&gt;Linuxカーネルとは別のプログラム群で作られており、サーバー版ではGUIなしの軽量なシステムとして運用できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;カーネル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;img src=&#34;https://cdn-xtech.nikkei.com/atcl/nxt/column/18/02898/072200001/zu02.jpg?__scale=w:500,h:273&amp;amp;_sh=0f1067090c&#34; alt=&#34;image&#34;&gt;&lt;/li&gt;&#xA;&lt;li&gt;OSの中核プログラム&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;3章-基本的なコマンドを覚えよう&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/009_%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E3%81%AF%E3%81%98%E3%82%81%E3%82%8Blinux%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E6%A7%8B%E7%AF%89%E9%81%8B%E7%94%A8%E3%82%AC%E3%82%A4%E3%83%89/#3%e7%ab%a0-%e5%9f%ba%e6%9c%ac%e7%9a%84%e3%81%aa%e3%82%b3%e3%83%9e%e3%83%b3%e3%83%89%e3%82%92%e8%a6%9a%e3%81%88%e3%82%88%e3%81%86&#34;&gt;3章 基本的なコマンドを覚えよう&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Linuxで扱われるファイルを分類すると以下の4種類となる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通常ファイル&lt;/li&gt;&#xA;&lt;li&gt;ディレクトリ&lt;/li&gt;&#xA;&lt;li&gt;リンクファイル&lt;/li&gt;&#xA;&lt;li&gt;特殊ファイル（デバイスを表すデバイスファイルなど）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;デバイスファイルはUnix系OS特有であり、&lt;strong&gt;Linuxでは全てをファイルで表す&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンピュータに接続されているデバイス、モニター、キーボードなどそれぞれに対応したデバイスファイルが存在する&lt;/li&gt;&#xA;&lt;li&gt;例えば、プリンターを表すデバイスファイルに文字を書き込むと、プリンタから出力されるようなイメージ&lt;/li&gt;&#xA;&lt;li&gt;全てをファイルとして抽象化することで、デバイスの扱いをシンプルにしている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Windowsでは、.txtや.exeといった拡張子が意味を持ち、アプリケーションと関連付けられているが、Linuxではファイル名の一部にすぎない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;なので、Windows&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;圧縮系のコマンド&#xA;&lt;ul&gt;&#xA;&lt;li&gt;gzip&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最も一般的&lt;/li&gt;&#xA;&lt;li&gt;高速軽量&lt;/li&gt;&#xA;&lt;li&gt;圧縮率はそこまで&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;bzip2&#xA;&lt;ul&gt;&#xA;&lt;li&gt;gzipより圧縮率高いが、遅い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;xz&#xA;&lt;ul&gt;&#xA;&lt;li&gt;圧縮率が非常に高い&lt;/li&gt;&#xA;&lt;li&gt;gzipやbzip2ほど広くサポートされていない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;zip&#xA;&lt;ul&gt;&#xA;&lt;li&gt;圧縮とアーカイブを同時に行う&lt;/li&gt;&#xA;&lt;li&gt;Windows環境との互換性が高い&lt;/li&gt;&#xA;&lt;li&gt;圧縮率はbzip2やxzより低い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;アーカイブのコマンド&#xA;&lt;ul&gt;&#xA;&lt;li&gt;tar&#xA;&lt;ul&gt;&#xA;&lt;li&gt;圧縮機能はなく、複数のファイルを1つのアーカイブ(書庫)にまとめる&lt;/li&gt;&#xA;&lt;li&gt;他の圧縮ツール(gzip)等と組み合わせて使用される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;-z(&amp;ndash;gzip)オプションでアーカイブ＋圧縮&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;圧縮とアーカイブの違い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;圧縮:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ファイルのサイズを小さくすることを目的とする&lt;/li&gt;&#xA;&lt;li&gt;ファイル内のデータをアルゴリズムを使って圧縮し、ディスク容量を節約する&lt;/li&gt;&#xA;&lt;li&gt;圧縮されたファイルは元のファイルより小さくなるが、単一のファイルとして扱われる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;アーカイブ:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;複数のファイルやディレクトリを1つのファイルにまとめることを目的とする&lt;/li&gt;&#xA;&lt;li&gt;ファイルをまとめて1つのアーカイブファイルにするが、サイズは変わらない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;圧縮とアーカイブの組み合わせ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これらはよく組み合わせて利用される&lt;/li&gt;&#xA;&lt;li&gt;複数ファイルをtarでアーカイブし、gzipで圧縮する&lt;/li&gt;&#xA;&lt;li&gt;ディスク/通信容量を削減したい・ファイル数を減らしたいバックアップや転送時によく使用される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;4章-ネットワーク&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/009_%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E3%81%AF%E3%81%98%E3%82%81%E3%82%8Blinux%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E6%A7%8B%E7%AF%89%E9%81%8B%E7%94%A8%E3%82%AC%E3%82%A4%E3%83%89/#4%e7%ab%a0-%e3%83%8d%e3%83%83%e3%83%88%e3%83%af%e3%83%bc%e3%82%af&#34;&gt;4章 ネットワーク&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IPアドレスは32ビット&#xA;&lt;ul&gt;&#xA;&lt;li&gt;人間にわかりやすいよう8桁区切り10進数で表記される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;IPアドレスはネットワーク部とホスト部で構成される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;その境界(ネットワーク部)を表すのにサブネットマスクがセットで用いられる&lt;/li&gt;&#xA;&lt;li&gt;同一ネットワークアドレス(1つのLANの中にある)機器同士は直接通信することができる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;逆にそうではない場合はルータを介す必要がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;IPアドレスとクラス&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サブネットマスクを簡潔に表現するのがCIDR表記(&lt;code&gt;192.168.0.0/255.255.255.0&lt;/code&gt;と&lt;code&gt;/24&lt;/code&gt;は同じ意味)&lt;/li&gt;&#xA;&lt;li&gt;CIDR（Classless Inter-Domain Routing）以前のIPアドレス設計とは？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ネットワーク機器の性能も乏しく、アドレスの経路制御も複雑なことはできなかった&lt;/li&gt;&#xA;&lt;li&gt;そこで考案されたのがIPアドレスをいくつかの「クラス」に分ける設計&lt;/li&gt;&#xA;&lt;li&gt;アドレス空間の管理がシンプルとなり、ルータがアドレスのプレフィックス（最初のビット）を見て簡単に判断できるという利点があった&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クラスA: ネットワーク部のビット数が8(ex: &lt;code&gt;10.0.0.0&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;li&gt;クラスB: ネットワーク部のビット数が16(ex: &lt;code&gt;172.16.0.0&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;li&gt;クラスC: ネットワーク部のビット数が24(ex: &lt;code&gt;192.168.0.0&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;プライベートIPアドレスとグローバルIPアドレス&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ホスト部のビットを全て0にしたアドレスを「ネットワークアドレス」&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ネットワークそのものを表す&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;全て1にしたアドレスを「ブロードキャストアドレス」という&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同じネットワークに属するすべてのホストに一斉送信する特殊なアドレス&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ホスト名とドメイン名&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;/etc/hosts&lt;/code&gt;ファイルはホスト名とIPアドレスを対応させるためのファイル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DNSが普及する前は、このファイルにインターネット上のホスト一覧がずらり並んでいた&lt;/li&gt;&#xA;&lt;li&gt;インターネットが大きくなるにつれ、埒があかなくなり、現在のDNSによる名前解決が行われることになった&lt;/li&gt;&#xA;&lt;li&gt;ただローカル環境や小規模環境では、&lt;code&gt;/etc/hosts&lt;/code&gt;ファイルでの名前解決で十分なので、今でも活躍するシーンはある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ちなみに名前解決をしようとする際、DNSサーバーより&lt;code&gt;/etc/hosts&lt;/code&gt;ファイルの方が優先される（OSにより設定ファイルがあったりするがデフォルトはそうなっているはず）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;6章-構築&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/009_%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E3%81%AF%E3%81%98%E3%82%81%E3%82%8Blinux%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E6%A7%8B%E7%AF%89%E9%81%8B%E7%94%A8%E3%82%AC%E3%82%A4%E3%83%89/#6%e7%ab%a0-%e6%a7%8b%e7%af%89&#34;&gt;6章 構築&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>ハイドレーション</title>
      <link>http://localhost:1313/posts/hydration/</link>
      <pubDate>Wed, 04 Jun 2025 09:46:31 +0900</pubDate>
      <guid>http://localhost:1313/posts/hydration/</guid>
      <description>&lt;p&gt;ハイドレーションの必要性がわからなかったので調べた。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ハイドレーションとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/hydration/#%e3%83%8f%e3%82%a4%e3%83%89%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%a8%e3%81%af&#34;&gt;ハイドレーションとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;React によってサーバーサイドレンダリングされたページは単純にクライアントに返却するだけでは JavaScript のイベントを受け取れるインタラクティブな状態にはなりません。onClick プロパティなどで渡されたイベントリスナーを DOM に登録する必要があります。このイベントリスナーを DOM に登録する処理を Hydrate と呼びます。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;なぜ必要&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/hydration/#%e3%81%aa%e3%81%9c%e5%bf%85%e8%a6%81&#34;&gt;なぜ必要？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SSRされたHTMLだけでは、イベントリスナー（クリックなど）がバインドされないため&#xA;&lt;ul&gt;&#xA;&lt;li&gt;素のJSで、document.querySelector(&amp;lsquo;button&amp;rsquo;).addEventListener()のように書けばイベントは効く&lt;/li&gt;&#xA;&lt;li&gt;が、Reactのような仮想DOMを使うフレームワークでは不十分&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;流れ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/hydration/#%e6%b5%81%e3%82%8c&#34;&gt;流れ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SSR（サーバー側でHTML生成し、ブラウザに返却する）&lt;/li&gt;&#xA;&lt;li&gt;ブラウザは、HTMLとともにJavaScriptファイルを読み込み実行（このJavaScriptファイルの中に状態管理やイベントバインドに関するロジックが含まれている）&lt;/li&gt;&#xA;&lt;li&gt;JavaScript(React)のハイドレーション関連の処理が実行され、SSRされたDOMとReactの仮想DOMを突き合わせて、イベント・状態等の機能を復元する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;react-server-componentsというアプローチ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/hydration/#react-server-components%e3%81%a8%e3%81%84%e3%81%86%e3%82%a2%e3%83%97%e3%83%ad%e3%83%bc%e3%83%81&#34;&gt;React Server Componentsというアプローチ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RSCには、Server ComponentsとClient Componentsがある&lt;/li&gt;&#xA;&lt;li&gt;Next.js AppRouterではRSCがデフォルト&lt;/li&gt;&#xA;&lt;li&gt;Server Components&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ビルド時にレンダリングされたものをクライアントに送るので、ハイドレーションが不要&lt;/li&gt;&#xA;&lt;li&gt;つまり、クライアントはサーバーが出力したHTMLを表示するだけ&lt;/li&gt;&#xA;&lt;li&gt;Server ComponentsとSSRとの違い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SSRは、ページ全体をサーバーサイドでレンダリングし、完全なHTMLを返却する&lt;/li&gt;&#xA;&lt;li&gt;SCは、特定のコンポーネントをサーバーサイドでレンダリングし、他の部分はクライアントサイドでレンダリングする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Client Components&#xA;&lt;ul&gt;&#xA;&lt;li&gt;useStateのようなインタラクティブなAPIを使用するにはClient Componentsを使用する&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;use client&lt;/code&gt;ディレクティブを追加することでClient Componentsとして扱える&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://ja.react.dev/reference/rsc/server-components&#34;&gt;サーバコンポーネント – React&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>WAF</title>
      <link>http://localhost:1313/posts/waf/</link>
      <pubDate>Mon, 02 Jun 2025 21:48:36 +0900</pubDate>
      <guid>http://localhost:1313/posts/waf/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;構成要素&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/waf/#%e6%a7%8b%e6%88%90%e8%a6%81%e7%b4%a0&#34;&gt;構成要素&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;WebACL&lt;/li&gt;&#xA;&lt;li&gt;ルールグループ&lt;/li&gt;&#xA;&lt;li&gt;ルール&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;webacl&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/waf/#webacl&#34;&gt;WebACL&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;対象に関連付けるエントリポイントつまりWAFの入口に当たるもの&lt;/li&gt;&#xA;&lt;li&gt;WAFを適用したい対象（CloudFront/ALB/API Gateway）に紐づける事でトラフィックをチェックする&lt;/li&gt;&#xA;&lt;li&gt;複数のルールやルールグループを含めることができる&lt;/li&gt;&#xA;&lt;li&gt;ルールの評価順序を管理する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ルールグループ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/waf/#%e3%83%ab%e3%83%bc%e3%83%ab%e3%82%b0%e3%83%ab%e3%83%bc%e3%83%97&#34;&gt;ルールグループ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;複数のルールをまとめた論理的なグループ&lt;/li&gt;&#xA;&lt;li&gt;再利用可能&lt;/li&gt;&#xA;&lt;li&gt;ルールグループとしてまとめた場合、優先度付けできるのはルールグループに対してとなる（ルールグループ内のルールに対して優先度を個別でつけることはできない）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ルール&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/waf/#%e3%83%ab%e3%83%bc%e3%83%ab&#34;&gt;ルール&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;実際のトラフィックに対する評価条件とそれに対するアクションを記述する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本的にはIF→THEN(Allow, Block, Count)の形で定義する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ルールグループとルールの使い分け&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/waf/#%e3%83%ab%e3%83%bc%e3%83%ab%e3%82%b0%e3%83%ab%e3%83%bc%e3%83%97%e3%81%a8%e3%83%ab%e3%83%bc%e3%83%ab%e3%81%ae%e4%bd%bf%e3%81%84%e5%88%86%e3%81%91&#34;&gt;ルールグループとルールの使い分け&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;再利用性と管理性が高くなるので、基本的には再利用する or 複雑(例: Webアプリケーションに対する一般的なセキュリティ機構としてXSSとSQLインジェクションを自前で定義するを1つにまとめたい)といったような目的・用途があるならルールグループを使うと良い（と理解している）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;優先度とは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/waf/#%e5%84%aa%e5%85%88%e5%ba%a6%e3%81%a8%e3%81%af&#34;&gt;優先度とは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;優先度の低いものから順に評価していく&lt;/li&gt;&#xA;&lt;li&gt;同じWebACL内にあるルールやルールグループに対して一意に設定する必要がある&lt;/li&gt;&#xA;&lt;li&gt;一致した時点でアクション(Allow, Block, Count)が実行され、&lt;strong&gt;残りのルールは評価されない&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;なので条件が厳しいルールを先に評価することで効率よくチェックが行える&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;複数のルールをpassしたトラフィックのみ通したい場合は&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/waf/#%e8%a4%87%e6%95%b0%e3%81%ae%e3%83%ab%e3%83%bc%e3%83%ab%e3%82%92pass%e3%81%97%e3%81%9f%e3%83%88%e3%83%a9%e3%83%95%e3%82%a3%e3%83%83%e3%82%af%e3%81%ae%e3%81%bf%e9%80%9a%e3%81%97%e3%81%9f%e3%81%84%e5%a0%b4%e5%90%88%e3%81%af&#34;&gt;複数のルールをPASSしたトラフィックのみ通したい場合は？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;WAFは最初にマッチしたルールでALLOWされたら以降のルールは評価されなくなる&lt;/li&gt;&#xA;&lt;li&gt;1つのルールに複数の条件（Statement）をANDで書くことで、表題を実現できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;countアクションの使い道&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/waf/#count%e3%82%a2%e3%82%af%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%ae%e4%bd%bf%e3%81%84%e9%81%93&#34;&gt;Countアクションの使い道&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ルールにマッチしてもトラフィックを通過をブロックせず、ログだけ残す動作&lt;/li&gt;&#xA;&lt;li&gt;例えば新しいルールの導入にあたり検証するため、BLOCKの前段階として使うとか&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>AWSコンテナ設計構築本格入門</title>
      <link>http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/</link>
      <pubDate>Fri, 30 May 2025 22:29:38 +0900</pubDate>
      <guid>http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.nri-net.com/books/2fxup8utd3sl/&#34;&gt;AWSコンテナ設計構築本格入門&lt;/a&gt;&#xA;&lt;a href=&#34;https://speakerdeck.com/horsewin/imanarakouzuo-ritai-awskontena-ben-ge-ru-men-hanzuon-2024nian-ban-hanzuonnogou-xiang&#34;&gt;いまならこう作りたい AWSコンテナ[本格]入門ハンズオン　〜2024年版 ハンズオンの構想〜 - Speaker Deck&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;chapter01-コンテナの概要&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#chapter01-%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e3%81%ae%e6%a6%82%e8%a6%81&#34;&gt;Chapter01 コンテナの概要&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテナは、他のプロセスとは隔離された状態でOS上にソフトウェアを実行する技術&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテナ上で実行されたソフトウェアは単に1つのプロセスとして稼働しているのにも関わらず、&lt;strong&gt;コンテナ内のソフトウェアから見ると独立したOS環境を占有している&lt;/strong&gt;ように見える&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サーバー仮想化は、ゲストOSごとにカーネルを占有する仕組み&lt;/li&gt;&#xA;&lt;li&gt;コンテナ技術は、OSとカーネルは共有し、プロセスを分離する仕組み&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテナのプロセスごとに、プロセッサやメモリ等のコンピューティングリソースが割り当てられ、アプリケーション稼働に必要なライブラリやミドルウェア等の依存関係が全て含まれる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;chapter02-コンテナの設計に必要なawsの基礎知識&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#chapter02-%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e3%81%ae%e8%a8%ad%e8%a8%88%e3%81%ab%e5%bf%85%e8%a6%81%e3%81%aaaws%e3%81%ae%e5%9f%ba%e7%a4%8e%e7%9f%a5%e8%ad%98&#34;&gt;Chapter02 コンテナの設計に必要なAWSの基礎知識&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コントロールプレーン&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテナを管理する機能&lt;/li&gt;&#xA;&lt;li&gt;ECSがこれにあたり、ECSはフルマネージドなコンテナオーケストレーターである(実行環境ではない)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;データプレーン&#xA;&lt;ul&gt;&#xA;&lt;li&gt;実際に稼働するリソース環境&lt;/li&gt;&#xA;&lt;li&gt;EC2とFargateがある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;chapter03-コンテナを利用したawsアーキテクチャ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#chapter03-%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e3%82%92%e5%88%a9%e7%94%a8%e3%81%97%e3%81%9faws%e3%82%a2%e3%83%bc%e3%82%ad%e3%83%86%e3%82%af%e3%83%81%e3%83%a3&#34;&gt;Chapter03 コンテナを利用したAWSアーキテクチャ&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Well-Architectedフレームワークに則り、アーキテクチャを考える&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;1-運用上の優秀性&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#1-%e9%81%8b%e7%94%a8%e4%b8%8a%e3%81%ae%e5%84%aa%e7%a7%80%e6%80%a7&#34;&gt;1. 運用上の優秀性&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以下のような観点から設計を検討する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;どのようにシステムの状態を把握するか&lt;/li&gt;&#xA;&lt;li&gt;どのように不具合の修正を容易にするか&lt;/li&gt;&#xA;&lt;li&gt;どのようにデプロイのリスクを軽減するか&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;モニタリングとは？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;システム内で定めた状態を確認し続けること&lt;/li&gt;&#xA;&lt;li&gt;目的は、システムの可用性を維持するために問題発生に気づくことである&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;→メモリ使用量などの定量情報である「メトリクス」や、アプリケーションの「ログ」などの定性的な情報から状態を検知し、アラートとして通知する&lt;/li&gt;&#xA;&lt;li&gt;ECSのようなコンテナサービスでは、小さなサービス同士が連携して動作することが多いので、障害発生時の影響範囲の把握や原因の特定が難しくなりがち&#xA;&lt;ul&gt;&#xA;&lt;li&gt;そこで、一連の処理内容を追えるためにするのが「トレース」&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;上記をひっくるめて、システム内部の状態を深掘りできるような状態を「オブザーバビリティ」という&#xA;&lt;ul&gt;&#xA;&lt;li&gt;オブザーバビリティを獲得することが、優れた運用に繋がる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ロギング設計&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#%e3%83%ad%e3%82%ae%e3%83%b3%e3%82%b0%e8%a8%ad%e8%a8%88&#34;&gt;ロギング設計&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CloudWatch Logsによるログ運用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ECS/Fargate構成では、CloudWatch Logsと連携することで、容易にログを収集できる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;具体的には、タスク定義のlogConfiguration.logDriverにawslogsを設定するだけ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サブスクリプションフィルターを使って特定の文字列が含まれている場合のみLambdaに連携→SNSを使って通知&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;FireLensによるログ運用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;メリットは、CloudWatch Logs以外のAWSサービスやAWS外のSaaSへのログ転送がしやすい&lt;/li&gt;&#xA;&lt;li&gt;ログルーティング機能を担うOSSのFluentBitなどの選択が可能&lt;/li&gt;&#xA;&lt;li&gt;CloudWatch Logsへの同時転送も可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CloudWatch LogsとFireLensの使い分け&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ECSタスク定義の仕様としては、コンテナごとにログ出力先を指定するログドライバーの定義は1つ&lt;/li&gt;&#xA;&lt;li&gt;まず考えられるのがCloudWatch Logsを転送→S3にエクスポートする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CloudWatch Logsはログを取り込んだタイミングで料金が発生してしまう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;コスト最適化と障害時運用の両立を図りたい場合は、FireLensがオススメ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FluentBitは、CloudWatch LogsとS3への同時ログ転送に対応している&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;一方で、CloudWatch Logsに取り込まれたログは、クエリベースでログ検索できたり、ダッシュボード表示が可能と、一概にCloudWatch Logsへの転送を避けるべきではない&lt;/li&gt;&#xA;&lt;li&gt;ログ運用で大事なのは**「ビジネス観点で、ログをどのように扱うか、ユースケースを描くこと」**である&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ビジネス目標に対して、ログ種類や保持期間、分析方法を検討し、設計する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;メトリクス設計&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#%e3%83%a1%e3%83%88%e3%83%aa%e3%82%af%e3%82%b9%e8%a8%ad%e8%a8%88&#34;&gt;メトリクス設計&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ECSで取得可能なメトリクスとして、以下が挙げられる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CloudWatchメトリクス&lt;/li&gt;&#xA;&lt;li&gt;CloudWatch Container Insights&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;以下は、ECSクラスターまたはECSサービスの単位でデフォルトで取得できる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPU使用率&lt;/li&gt;&#xA;&lt;li&gt;メモリ使用率&#xA;&lt;ul&gt;&#xA;&lt;li&gt;それぞれ1分間隔で取得&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;より詳細なメトリクスを取得するにはCloudWatch Container Insightsの有効化が必要&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ECSタスクごとに収集可能&lt;/li&gt;&#xA;&lt;li&gt;ディスクやネットワークに関するメトリクス&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;トレース設計&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#%e3%83%88%e3%83%ac%e3%83%bc%e3%82%b9%e8%a8%ad%e8%a8%88&#34;&gt;トレース設計&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;trace情報の取得をサポートするサービスとして「X-Ray」がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サービスマップのダッシュボードも提供されており、システム全体の可視化も可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ECS/FargateでX-Rayを利用する場合、以下のようなサイドカー構成となる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ECSタスク定義の中にアプリケーションコンテナとX-Rayコンテナを同梱する&lt;/li&gt;&#xA;&lt;li&gt;アプリケーション自体にAWSが提供するX-Ray用のSDKで一部コーディングを施す&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ECS上のコンテナアプリケーションからX-Rayにトレース情報を書き込むためには特定のIAM権限が必要となる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;具体的には、ECSタスクロールが必要になる&lt;/li&gt;&#xA;&lt;li&gt;タスク実行ロールではないことは注意（X-Rayにトレース情報を書き込む主体はECSコンテナエージェントではなく、ECSタスク＝X-Rayコンテナなので）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;VPCからパブリックネットワークへの通信経路が必要&#xA;&lt;ul&gt;&#xA;&lt;li&gt;X-RayはVPC外のAWSパブリックネットワーク上に存在する&lt;/li&gt;&#xA;&lt;li&gt;ECSタスクがプライベートサブネットにデプロイされている場合は、X-Ray用のVPCエンドポイントかNATゲートウェイを用意する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;cicd設計&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#cicd%e8%a8%ad%e8%a8%88&#34;&gt;CI/CD設計&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテナはポータビリティ・再現性・軽量さという観点で、CI/CDと相性が良い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;開発環境・本番環境でシステム構成が異なることはよくある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;そうなると、OSやライブラリバージョンなどビルド・デプロイ手順で意識する必要があり、手間やミスが増える&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;コンテナは、アプリケーションに必要な依存関係をパッケージ化してビルドするため、ホストマシン上で同じように振る舞う&#xA;&lt;ul&gt;&#xA;&lt;li&gt;なので、実行環境によらない再現性があるコンテナは、よりCI/CDとの相性が良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ecr&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#ecr&#34;&gt;ECR&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ECRの実体はS3&lt;/li&gt;&#xA;&lt;li&gt;各環境で1つのECRを利用する場合、ライフサイクルポリシーで商用環境が参照しているイメージを削除してしまうという点は注意&#xA;&lt;ul&gt;&#xA;&lt;li&gt;環境ごとの固有のタグを付与し、タグごとにライフサイクルポリシーを設定する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;イメージタグはコミットIDを付与することで、どのソースコードバージョンかの判別が容易となる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ガバナンスとコンプライアンス要件の考慮&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#%e3%82%ac%e3%83%90%e3%83%8a%e3%83%b3%e3%82%b9%e3%81%a8%e3%82%b3%e3%83%b3%e3%83%97%e3%83%a9%e3%82%a4%e3%82%a2%e3%83%b3%e3%82%b9%e8%a6%81%e4%bb%b6%e3%81%ae%e8%80%83%e6%85%ae&#34;&gt;ガバナンスとコンプライアンス要件の考慮&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以下の要件を満たす方法を考える&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リリースに関連したファイルの改ざん防止策を考慮すること&lt;/li&gt;&#xA;&lt;li&gt;意図しないソフトウェアリリースを防ぐ目的として、承認プロセスを設けること&lt;/li&gt;&#xA;&lt;li&gt;規定されたCI/CDパイプライン以外のリリースを禁止すること&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;まず、リリースに関連したファイルの配置先は以下になる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ステージ間でアーティファクトを受け渡すS3バケット&lt;/li&gt;&#xA;&lt;li&gt;コンテナイメージを保管するECR&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;検討できる方法としては、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;S3バケットを操作するユーザーのポリシーとバケットポリシー等による制限&lt;/li&gt;&#xA;&lt;li&gt;CodePipeline上で承認プロセスを設置&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GitHubActionsでも可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ECSやECRに書き込み・実行権限を設け、CI/CDパイプラインを介さないコンテナイメージデプロイを禁止&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;2セキュリティ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#2%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3&#34;&gt;2.セキュリティ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;「責任共有モデル」を理解することで、どのようなセキュリティ対策を行うべきかが見えてくる&lt;/li&gt;&#xA;&lt;li&gt;ECR、Trivy(OSS)によるイメージの脆弱性スキャン&#xA;&lt;ul&gt;&#xA;&lt;li&gt;継続的にスキャンすることが大事&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;dockleなどのチェックツールを利用する&lt;/li&gt;&#xA;&lt;li&gt;提供元が信頼できるベースイメージを利用する&lt;/li&gt;&#xA;&lt;li&gt;GuardDutyで、外部と不正な通信がないかをチェックする&lt;/li&gt;&#xA;&lt;li&gt;秘密情報は、SecretsManagerやSSMパラメータストアに格納し、環境変数としてコンテナ内に安全に秘密情報を挿入する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;環境変数名に対し、値としてARNを設定するだけ&lt;/li&gt;&#xA;&lt;li&gt;注意点として、SSMパラメータストアにはstringとsecure string定義が存在し、secure stringは内部的にKMSで暗号化されて、暗号・復号されるが、stringは暗号化されないので注意&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;レジストリに対する対策&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#%e3%83%ac%e3%82%b8%e3%82%b9%e3%83%88%e3%83%aa%e3%81%ab%e5%af%be%e3%81%99%e3%82%8b%e5%af%be%e7%ad%96&#34;&gt;レジストリに対する対策&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ライフサイクルを適切に設定し、古いイメージは削除する運用にする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;古いイメージは脆弱性混入しがちであり、そのイメージが誤ってデプロイされてしまうことを避ける&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;同名タグをプッシュされた時に上書きされないようにIMMUTABLE設定をする&lt;/li&gt;&#xA;&lt;li&gt;特定のIAMユーザー/ロールからしかアクセスできないようプライベートレジストリにする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;そもそもパブリックレジストリを作成できないようにIAMポリシーを作成できるので、SCPに適用し、Organizationsの組織内でそのポリシーを継承・適用するのがオススメ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;イメージプッシュは、CIからのみ許可するポリシー設定をする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;オーケストレータecsに対する対策&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#%e3%82%aa%e3%83%bc%e3%82%b1%e3%82%b9%e3%83%88%e3%83%ac%e3%83%bc%e3%82%bfecs%e3%81%ab%e5%af%be%e3%81%99%e3%82%8b%e5%af%be%e7%ad%96&#34;&gt;オーケストレータ(ECS)に対する対策&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IAMグループにポリシーを割り当て、ECSの操作スコープを制限する&lt;/li&gt;&#xA;&lt;li&gt;ECSのネットワークセキュリティはVPC全体を俯瞰して考える&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ECS/Fargateで起動するECSタスクは全てVPC上に配置される&lt;/li&gt;&#xA;&lt;li&gt;タスクに関するネットワーク接続方法はいくつかあり、「ネットワークモード」と呼ばれる&lt;/li&gt;&#xA;&lt;li&gt;Fargate上にホストされる場合は、awsvpcというネットワークモードが選択され、独自のENIが割り当てられ、そこにIPv4アドレスが割り当てられることで、ECSタスクが独立したネットワークサービスとして捉えることができる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;コンテナに対する対策&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e3%81%ab%e5%af%be%e3%81%99%e3%82%8b%e5%af%be%e7%ad%96&#34;&gt;コンテナに対する対策&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテナからの無制限ネットワークアクセスへの対策&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ECSタスクから構成されるVPCネットワークには次の3つが設計ポイントになる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パブリックネットワーク→VPCの通信&#xA;&lt;ul&gt;&#xA;&lt;li&gt;WAF - ALB - ECSの構成で、ECSはプライベートサブネットに配置する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ECSタスク間の通信&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えば、FEのECSタスクとBEのECSタスクがどちらもプライベートサブネットに配置されている例&lt;/li&gt;&#xA;&lt;li&gt;BEのECSタスクのセキュリティグループのインバウンドルールとして、FEのECSタスクのセキュリティグループを設定すると、到達できる送信元を制御できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;VPC→パブリックネットワークの通信&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パブリックサブネットにNATゲートウェイを配置して、ECSはプライベートサブネットに配置する&lt;/li&gt;&#xA;&lt;li&gt;AWSリソースへの通信はVPCエンドポイントにする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPCエンドポイントのインターフェース型は時間料金と処理データ量に応じた課金が発生する&lt;/li&gt;&#xA;&lt;li&gt;仮にCloudWatch LogsのVPCエンドポイントをマルチAZに配置した場合は2,700円ほど&lt;/li&gt;&#xA;&lt;li&gt;NATゲートウェイをマルチAZに配置した場合は12,000円&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPCエンドポイントはサービスごとに配置する必要があるので、コスト圧縮の観点でNATゲートウェイに軍配が上がることもある点は注意&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ECRをVPCエンドポイント接続する場合は、ECRに加えてS3のVPCエンドポイントも必要になる(ECRの実態はS3であるため)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;アプリケーションの脆弱性への対策&#xA;&lt;ul&gt;&#xA;&lt;li&gt;タスク定義でルートファイルシステムアクセスを読み取り専用にする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ファイル改竄に関する脅威を小さくできる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;3信頼性&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#3%e4%bf%a1%e9%a0%bc%e6%80%a7&#34;&gt;3.信頼性&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;障害復旧やスケールなど&lt;/li&gt;&#xA;&lt;li&gt;マルチAZ構成による可用性向上&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Fargateを使用すると、ECSサービス内部のスケジューラがベストエフォートでAZ間の負荷バランスを調整しながらタスク配置してくれる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CloudWatchメトリクスを使用してタスクの障害を検知&lt;/li&gt;&#xA;&lt;li&gt;ECSサービスを利用してタスクを自動復旧&lt;/li&gt;&#xA;&lt;li&gt;ALBを利用して、ターゲットECSタスクが障害した時に切り離す&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;メンテナンスによるecsタスク停止への対処&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#%e3%83%a1%e3%83%b3%e3%83%86%e3%83%8a%e3%83%b3%e3%82%b9%e3%81%ab%e3%82%88%e3%82%8becs%e3%82%bf%e3%82%b9%e3%82%af%e5%81%9c%e6%ad%a2%e3%81%b8%e3%81%ae%e5%af%be%e5%87%a6&#34;&gt;メンテナンスによるECSタスク停止への対処&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コントロールプレーンからECSタスクに対して停止状態を指示された際のハンドリングに関しても考慮が必要&lt;/li&gt;&#xA;&lt;li&gt;ECSは、AWS内部におけるハードウェア障害やセキュリティ脆弱性が存在するプラットフォームであると判断された場合、新しいECSタスクに置き換えるイベントを発生させる&lt;/li&gt;&#xA;&lt;li&gt;Fargate上で稼働しているECSタスクについては、必要なパッチ運用や内部のインフラストラクチャ更新に伴いメンテナンスイベントが発生する&lt;/li&gt;&#xA;&lt;li&gt;処理の整合性を求められるビジネスでは、停止指示がなされた場合に、適切にアプリケーションをハンドリングする必要がある&lt;/li&gt;&#xA;&lt;li&gt;ECSではタスク停止を指示する際、ECSクラスターがタスクに対してSIGTERMシグナルを送信する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;このシグナルに応答がない場合、デフォルト30秒でタイムアウトし、その後SIGKILLシグナルが発行される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ただし、タイムアウトするまでの時間はタスク定義パラメータで変更可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ECSで動かすアプリケーションにおいては、SIGTERMシグナルを受信したら、アプリケーションが安全に終了するように実装しましょう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;システムメンテナンス時におけるサービス停止&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e3%83%a1%e3%83%b3%e3%83%86%e3%83%8a%e3%83%b3%e3%82%b9%e6%99%82%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8b%e3%82%b5%e3%83%bc%e3%83%93%e3%82%b9%e5%81%9c%e6%ad%a2&#34;&gt;システムメンテナンス時におけるサービス停止&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ALBのリスナールールで、ESCタスクが登録されているターゲットグループへの転送ルールと固定レスポンス(503とか)を返却する転送ルールを用意する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;パフォーマンス設計&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#%e3%83%91%e3%83%95%e3%82%a9%e3%83%bc%e3%83%9e%e3%83%b3%e3%82%b9%e8%a8%ad%e8%a8%88&#34;&gt;パフォーマンス設計&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FargateではOSレイヤの管理は不要となるが、コンピューティングリソースのサイジング等の設定は必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;適切なリソース設計の流れ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#%e9%81%a9%e5%88%87%e3%81%aa%e3%83%aa%e3%82%bd%e3%83%bc%e3%82%b9%e8%a8%ad%e8%a8%88%e3%81%ae%e6%b5%81%e3%82%8c&#34;&gt;適切なリソース設計の流れ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;まずはビジネス上のパフォーマンス要件（性能要件）を把握する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ただし、AWSを利用する場合は、必要に応じてリソースを容易にスケールできるので、厳密に見積もる必要はない&lt;/li&gt;&#xA;&lt;li&gt;とは言いつつ、ある程度は利用者数やワークロードの特性を見極めつつ、性能目標から必要なリソースを仮決めするのは重要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;AutoScalingを活用する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;step1-ビジネス上のパフォーマンス要件&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#step1-%e3%83%93%e3%82%b8%e3%83%8d%e3%82%b9%e4%b8%8a%e3%81%ae%e3%83%91%e3%83%95%e3%82%a9%e3%83%bc%e3%83%9e%e3%83%b3%e3%82%b9%e8%a6%81%e4%bb%b6&#34;&gt;STEP1: ビジネス上のパフォーマンス要件&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;具体的な数値の要件(10リクエスト/秒)から、必要なタスクのリソースやタスク数を検討する&lt;/li&gt;&#xA;&lt;li&gt;ピーク時のアクセスを考慮し、スパイクを擬似的に発生するテストや挙動(エラーが発生せず処理継続が可能)を確認するよう計画する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;step2-1-リソースの割り当て&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#step2-1-%e3%83%aa%e3%82%bd%e3%83%bc%e3%82%b9%e3%81%ae%e5%89%b2%e3%82%8a%e5%bd%93%e3%81%a6&#34;&gt;STEP2-1: リソースの割り当て&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;初期のタイミングである程度余裕を持つのが良い&lt;/li&gt;&#xA;&lt;li&gt;ただし、タスク定義に割り当てたCPU・メモリサイズ分の料金が発生するので、余剰なリソースは避けた方が良いのは言うまでもない&lt;/li&gt;&#xA;&lt;li&gt;まずは単体でアプリケーションを稼働させてみて、その後のステップでテスト結果などをふまえ、コストとのバランスを見極めて設定を行う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;step2-2-スケール戦略の検討&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#step2-2-%e3%82%b9%e3%82%b1%e3%83%bc%e3%83%ab%e6%88%a6%e7%95%a5%e3%81%ae%e6%a4%9c%e8%a8%8e&#34;&gt;STEP2-2: スケール戦略の検討&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;スケールアップとスケールアウトでスケールアウトが良い理由&#xA;&lt;ul&gt;&#xA;&lt;li&gt;停止が不要&lt;/li&gt;&#xA;&lt;li&gt;スケールアップには上限がある&lt;/li&gt;&#xA;&lt;li&gt;AutoScalingでスケール判断の自動化が簡単&lt;/li&gt;&#xA;&lt;li&gt;パフォーマンス効率だけでなく、可用性と耐障害性が向上する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;AutoScalingを活用する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CloudWatchアラームで定めたメトリクスの閾値にしたがってスケールアウトやスケールインが実行される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;スケーリングポリシー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ステップスケーリングポリシー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;スケールアウト/インする条件にステップを設けることで段階的にスケールアクションを設定できるポリシー&lt;/li&gt;&#xA;&lt;li&gt;例えば、タスクの平均CPU使用率が60%でタスクを数を10%追加するみたいな&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ターゲット追跡スケーリングポリシー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指定したメトリクスのターゲット値を維持するようにスケールアウト/インが制御されるポリシー&lt;/li&gt;&#xA;&lt;li&gt;AWS側が自動でタスク量を調整してくれるので、よりマネージドな戦略であり、管理も楽になる&lt;/li&gt;&#xA;&lt;li&gt;スケールアウトは高速に動作するが、スケールインは緩やかな実行される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;どちらが良いのか？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;筆者の推奨は「ターゲット追跡スケーリングポリシー」&lt;/li&gt;&#xA;&lt;li&gt;理由：チューニング不要である点・コスパのバランスが良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;step3-テストの実施&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#step3-%e3%83%86%e3%82%b9%e3%83%88%e3%81%ae%e5%ae%9f%e6%96%bd&#34;&gt;STEP3: テストの実施&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ツールを活用し、実際に想定されるリクエスト量を流して以下の観点でテストする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;メトリクスが取得できているか&lt;/li&gt;&#xA;&lt;li&gt;エラーログ出ていないか&lt;/li&gt;&#xA;&lt;li&gt;ログ内容は適切か(欠損等やログレベルの妥当性)&lt;/li&gt;&#xA;&lt;li&gt;スケールイン/アウトができているか&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;step4-メトリクスの確認&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#step4-%e3%83%a1%e3%83%88%e3%83%aa%e3%82%af%e3%82%b9%e3%81%ae%e7%a2%ba%e8%aa%8d&#34;&gt;STEP4: メトリクスの確認&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;STEP3のテストを実行しつつ、CloudWatchメトリクスを活用して以下を確認する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パフォーマンス要件で定義したリクエスト量が満たされているか&lt;/li&gt;&#xA;&lt;li&gt;ECSタスクおよびコンテナに割り当てたCPU/メモリに余剰や逼迫が生じていないか&lt;/li&gt;&#xA;&lt;li&gt;AutoScalingのスケールアウト・インは正しく発動するか&lt;/li&gt;&#xA;&lt;li&gt;スケールアウト・イン時にエラーログが吐かれていないか&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;step5-リソース割り当てやスケール戦略の見直し&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#step5-%e3%83%aa%e3%82%bd%e3%83%bc%e3%82%b9%e5%89%b2%e3%82%8a%e5%bd%93%e3%81%a6%e3%82%84%e3%82%b9%e3%82%b1%e3%83%bc%e3%83%ab%e6%88%a6%e7%95%a5%e3%81%ae%e8%a6%8b%e7%9b%b4%e3%81%97&#34;&gt;STEP5: リソース割り当てやスケール戦略の見直し&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;STEP4の結果から、ECSタスク定義のリソース割り当てやスケール戦略の閾値を調整する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;パフォーマンス設計に必要なマインドセット&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#%e3%83%91%e3%83%95%e3%82%a9%e3%83%bc%e3%83%9e%e3%83%b3%e3%82%b9%e8%a8%ad%e8%a8%88%e3%81%ab%e5%bf%85%e8%a6%81%e3%81%aa%e3%83%9e%e3%82%a4%e3%83%b3%e3%83%89%e3%82%bb%e3%83%83%e3%83%88&#34;&gt;パフォーマンス設計に必要なマインドセット&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;必要なメトリクスを収集し、適切なサイジングを行うことは重要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;コスト最適化設計&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#%e3%82%b3%e3%82%b9%e3%83%88%e6%9c%80%e9%81%a9%e5%8c%96%e8%a8%ad%e8%a8%88&#34;&gt;コスト最適化設計&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;まずは必要十分なリソース量を定めることが基本動作&lt;/li&gt;&#xA;&lt;li&gt;Compute Saving Plansの活用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1年or3年のいずれかの期間を指定リソースの利用をコミットすることで割引される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;コンテナイメージのメンテナンス&#xA;&lt;ul&gt;&#xA;&lt;li&gt;イメージサイズに比例して料金が発生するため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;非商用環境のタスク稼働時間帯の調整&#xA;&lt;ul&gt;&#xA;&lt;li&gt;必要な時間帯を整理し、EventBridge Schedulerで定期的に起動・停止を行う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Fargate Spotの活用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;停止を許容できる場合に有効な選択肢となる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;停止する2分前にSIGTERMシグナルが送信されるので、アプリケーション側でハンドリングロジックを組み込んでおく&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;60-70%削減&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;コンテナイメージの削減&#xA;&lt;ul&gt;&#xA;&lt;li&gt;イメージサイズの分だけECRからのデータ処理料金が発生する&lt;/li&gt;&#xA;&lt;li&gt;コストメリットだけでなく、イメージのダウンロード時間が短くなり、起動時間が短縮できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;chapter04-コンテナを構築する基礎編&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#chapter04-%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e3%82%92%e6%a7%8b%e7%af%89%e3%81%99%e3%82%8b%e5%9f%ba%e7%a4%8e%e7%b7%a8&#34;&gt;Chapter04 コンテナを構築する(基礎編)&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ハンズオンのメモ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#%e3%83%8f%e3%83%b3%e3%82%ba%e3%82%aa%e3%83%b3%e3%81%ae%e3%83%a1%e3%83%a2&#34;&gt;ハンズオンのメモ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;各サブネットに割り当てるIPv4 CIDR設計&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将来の拡張性を意識して、最初の段階でCIDR割り当ての全体方針決めを心がけることが大切&lt;/li&gt;&#xA;&lt;li&gt;とはいえ、最初からサブネットでどの程度のアドレスが必要かは予測しづらい..&lt;/li&gt;&#xA;&lt;li&gt;特にFargate上で稼働するコンテナは、コンテナごとにENIと呼ばれる仮想NICがアタッチされ、その仮想NICごとにIPアドレスが割り当てられるので、スケールアウト時のIPアドレス消費を考慮しておく必要がある&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;コンテナ割り当て可能な全体数とのバランスを意識しながら、IPv4 CIDRごとに余力を持たせておく&lt;/strong&gt;のが望ましい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;実際の設計&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPC: &lt;code&gt;10.0.0.0/16&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;/16&lt;/code&gt;は、前半16ビットがネットワーク部・後半16ビットがホスト部という意味&lt;/li&gt;&#xA;&lt;li&gt;つまり、実際のコンテナのENIなどに65,536(16ビット)分のIPアドレスを割り当てられるという意味&lt;/li&gt;&#xA;&lt;li&gt;この範囲でサブネットのCIDRブロックを決める必要がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サブネット: &lt;code&gt;10.0.0.0/24&lt;/code&gt;, &lt;code&gt;10.0.1.0/24&lt;/code&gt;&amp;hellip;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;/24&lt;/code&gt;は、後半8ビット分がホスト部&lt;/li&gt;&#xA;&lt;li&gt;つまり、サブネットごとに、第3オクテッドの値がインクリメントする形となる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ECR構築&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プライベートサブネットにあるECSサービスからECRへプライベート接続させるためにVPCエンドポイントを作成する&lt;/li&gt;&#xA;&lt;li&gt;VPCエンドポイントにはいくつかの種類があり、ECRへコンテナイメージを登録・取得するためには以下の3つの種類が必要&#xA;&lt;ul&gt;&#xA;&lt;li&gt;インターフェイス型&#xA;&lt;ol&gt;&#xA;&lt;li&gt;com.amazonaws.[region].ecr.api&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ECR API呼び出しに必要(例: docker login時に必要なログインパスワード取得時など)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;com.amazonaws.[region].ecr.dkr&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;docker image pushコマンド実行時などに必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ゲートウェイ型&#xA;&lt;ol&gt;&#xA;&lt;li&gt;com.amazonaws.[region].s3&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dockerイメージ取得に必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;DockerビルドしたイメージをECSクラスタ上でタスク起動&#xA;&lt;ul&gt;&#xA;&lt;li&gt;タスク起動するとコンテナが起動継続しない事象が発生&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ログを見ると&lt;code&gt;exec /usr/local/bin/docker-entrypoint.sh: exec format error&lt;/code&gt;が発生していた&lt;/li&gt;&#xA;&lt;li&gt;どうやら手元のM2 Mac(arm64)でビルドしたイメージをECS(x86_64 amd64)で動かそうとしたことが原因ぽい&lt;/li&gt;&#xA;&lt;li&gt;docker buildコマンドに&lt;code&gt;--platform=linux/amd64&lt;/code&gt;を指定することで解決&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Aurora構築&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サブネットグループの必要性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AuroraのマルチAZ構成は、VPC内の複数AZにまたがるサブネットに配置される&lt;/li&gt;&#xA;&lt;li&gt;どのサブネットに配置するかを指定するために必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;DBスキーマ反映 from CloudShell&#xA;&lt;ul&gt;&#xA;&lt;li&gt;書籍ではCloud9からやっているけどもうないのでCloudShellから&lt;/li&gt;&#xA;&lt;li&gt;マイグレーションファイルがあるfrontendディレクトリが手元にない問題&#xA;&lt;ul&gt;&#xA;&lt;li&gt;手元からaws s3 cpコマンドでS3バケットにソースコード配置&lt;/li&gt;&#xA;&lt;li&gt;CloudShellでaws s3 cpコマンドで手元に持ってくる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ここで穴が空いておらずS3にアクセスできない問題が発生&lt;/li&gt;&#xA;&lt;li&gt;S3はパブリック設定ではないのでVPCエンドポイント経由でアクセスする必要があった&lt;/li&gt;&#xA;&lt;li&gt;VPCエンドポイントが向き先のルートテーブルが、CloudShellを起動しているサブネットに関連付けされていなかったことが原因&lt;/li&gt;&#xA;&lt;li&gt;関連づけたことでS3にアクセスできるようになった&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;chapter05-コンテナを構築する実践編&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/005_aws%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E8%A8%AD%E8%A8%88%E6%A7%8B%E7%AF%89%E6%9C%AC%E6%A0%BC%E5%85%A5%E9%96%80/#chapter05-%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e3%82%92%e6%a7%8b%e7%af%89%e3%81%99%e3%82%8b%e5%ae%9f%e8%b7%b5%e7%b7%a8&#34;&gt;Chapter05 コンテナを構築する(実践編)&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;実務で使わない or 既に使っていて知見ありのものなので割愛&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>GitHub CICD実践ガイド</title>
      <link>http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/</link>
      <pubDate>Tue, 27 May 2025 21:25:40 +0900</pubDate>
      <guid>http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;1章-ソフトウェア開発とgithub&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#1%e7%ab%a0-%e3%82%bd%e3%83%95%e3%83%88%e3%82%a6%e3%82%a7%e3%82%a2%e9%96%8b%e7%99%ba%e3%81%a8github&#34;&gt;1章 ソフトウェア開発とGitHub&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;継続的インテグレーションとは？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コードの変更を頻繁にコードベースに統合し、正しく動作するかを繰り返し検証する&lt;/li&gt;&#xA;&lt;li&gt;統合頻度が上がるとコンフリクトが減る&lt;/li&gt;&#xA;&lt;li&gt;繰り返して検証を行うとバグを発見すれば素早く修正できる&lt;/li&gt;&#xA;&lt;li&gt;ソフトウェアが安定して動けば、ユーザーの満足度も向上する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;継続的デリバリーとは？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リリースしないとユーザーには価値を提供できない&lt;/li&gt;&#xA;&lt;li&gt;いつでも安全にリリースできる状態を保ち、ソフトウェアを繰り返し改善する&lt;/li&gt;&#xA;&lt;li&gt;CIとCDは同列の概念に見えるが、CIはCDに包含される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;2章-githubactionsの基礎概念&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#2%e7%ab%a0-githubactions%e3%81%ae%e5%9f%ba%e7%a4%8e%e6%a6%82%e5%bf%b5&#34;&gt;2章 GitHubActionsの基礎概念&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;実行時エラー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コマンドの終了ステータスが0ならば成功、0以外ならば失敗見なされる&lt;/li&gt;&#xA;&lt;li&gt;なので、ワークフローでは終了ステータスを適切に返すことが大事&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;手動実行&#xA;&lt;ul&gt;&#xA;&lt;li&gt;on: workflow_dispatchで手動実行できる&lt;/li&gt;&#xA;&lt;li&gt;inputとして、列挙型となるchoice型の指定が可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;定期実行&#xA;&lt;ul&gt;&#xA;&lt;li&gt;on: schedule: cron()で定期実行できる&lt;/li&gt;&#xA;&lt;li&gt;時刻はUTCなので注意&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;実行環境&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GitHub-Hosted Runners&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GitHubが提供するマネージドな実行環境&lt;/li&gt;&#xA;&lt;li&gt;LargerRunnersというマシンスペック向上したものも利用可能（有料）&lt;/li&gt;&#xA;&lt;li&gt;サポートOSとしては、Linux(Ubuntu)/Windows/macOSがある&lt;/li&gt;&#xA;&lt;li&gt;よく使用するDocker,Node.js,npmなどは既にインストールされている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ただし、バージョン固定はできないので、バージョン固定で使用したい場合は、ワークフローの中で自分でインストールする必要ある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;エフェメラルという特性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ジョブ終了時に破棄されるので、毎回クリーンな環境でジョブを実行できる&lt;/li&gt;&#xA;&lt;li&gt;この特性は一貫性向上に貢献している&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Self-Hosted Runners&#xA;&lt;ul&gt;&#xA;&lt;li&gt;利用者が実行環境を用意する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;MarketPlace&#xA;&lt;ul&gt;&#xA;&lt;li&gt;再利用できるワークフローが公開されている&lt;/li&gt;&#xA;&lt;li&gt;著名な組織にはVerifiedCreatorsマークがついているので、そういうのを利用するとセキュリティ不安が低減する（100%安全とは言い切れないが）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;料金&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パブリックリポジトリなら無料&lt;/li&gt;&#xA;&lt;li&gt;プライベートは使用時間とストレージ使用量で計算される&lt;/li&gt;&#xA;&lt;li&gt;月毎に無料枠があり、それを超えると課金が発生するが、支払い設定をしていない場合は実行できなくなるだけ（なので安心できる）&lt;/li&gt;&#xA;&lt;li&gt;使用時間は、実行時間×ランナーごとの料率で計算される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;料率はubuntuが1,Windowsが2,macOSが10なので、なるべくUbuntuを利用するのがオススメ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;3章-ワークフロー構文の基礎&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#3%e7%ab%a0-%e3%83%af%e3%83%bc%e3%82%af%e3%83%95%e3%83%ad%e3%83%bc%e6%a7%8b%e6%96%87%e3%81%ae%e5%9f%ba%e7%a4%8e&#34;&gt;3章 ワークフロー構文の基礎&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;環境変数&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e7%92%b0%e5%a2%83%e5%a4%89%e6%95%b0&#34;&gt;環境変数&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;単一のワークフローで使用できる&lt;/li&gt;&#xA;&lt;li&gt;envで定義する&lt;/li&gt;&#xA;&lt;li&gt;ワークフロー・ジョブ・ステップで定義可能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定義した場所で、環境変数のスコープが異なる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;中間環境変数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテキスト(github.base_refのように参照できるもの)は、各ジョブ(ステップ)の中で直接スクリプトに埋め込むのはNG&#xA;&lt;ul&gt;&#xA;&lt;li&gt;理由: スクリプトインジェクションにリスクがあるため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;env&lt;/code&gt;の中で一度変数展開し、スクリプト内ではダブルクオテーションで囲むことが推奨される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;変数展開することでメモリ上で保存されるので、スクリプト生成プロセスには生成プロセスには相互作用しないため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;GHAに限らず、シェルスクリプト全体で言えること&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;variables&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#variables&#34;&gt;Variables&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;複数のワークフローで使用できる&lt;/li&gt;&#xA;&lt;li&gt;varsコンテキストでアクセスする&lt;/li&gt;&#xA;&lt;li&gt;こちらも参照時は中間環境変数経由(envの中で環境変数に展開してから)が推奨&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;secrets&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#secrets&#34;&gt;Secrets&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以下の特徴がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;登録した値は暗号化され、GitHub内で安全に管理される&lt;/li&gt;&#xA;&lt;li&gt;ログ出力時はマスクされる&lt;/li&gt;&#xA;&lt;li&gt;登録後の値確認は不可となる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ログマスクのアルゴリズムは完全一致のみ、1文字スペースを加えたりするだけで出力されてしまうので、ログマスクは当てにしないようにする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;そもそもsecretsの値はログ出力しないようにしましょう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;expressions式&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#expressions%e5%bc%8f&#34;&gt;expressions(式)&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;${ example }&lt;/code&gt;のような形で定義&lt;/li&gt;&#xA;&lt;li&gt;リテラルや演算子などが使用可能&lt;/li&gt;&#xA;&lt;li&gt;比較演算の際、GHAでは異なる型の値を比較すると、勝手に値が変換されるので注意&lt;/li&gt;&#xA;&lt;li&gt;オブジェクトフィルター&#xA;&lt;ul&gt;&#xA;&lt;li&gt;配列やオブジェクトから指定したプロパティを抜き出し、配列を生成する&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;${{ github.event.*.html_url }}&lt;/code&gt;のような形で&lt;code&gt;*&lt;/code&gt;を使用する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;条件分岐if&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e6%9d%a1%e4%bb%b6%e5%88%86%e5%b2%90if&#34;&gt;条件分岐(if)&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ifの少し面白い使い方として、最初のジョブへ条件分岐を定義し、特定の条件でスキップするようにすると、ワークフロー自体の実行がスキップできる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用時間もゼロになり、コスト削減につながる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ネーミング&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%83%8d%e3%83%bc%e3%83%9f%e3%83%b3%e3%82%b0&#34;&gt;ネーミング&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;実行ログが見やすくなるのでジョブ名やステップ名はきちんと書く&lt;/li&gt;&#xA;&lt;li&gt;run-nameは、nameとは異なり、コンテキストが利用できる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;run-name: Run by ${{ github.actor }}&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ステップ間のデータ共有&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%b9%e3%83%86%e3%83%83%e3%83%97%e9%96%93%e3%81%ae%e3%83%87%e3%83%bc%e3%82%bf%e5%85%b1%e6%9c%89&#34;&gt;ステップ間のデータ共有&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2つのやり方がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GITHUB_OUTPUT環境変数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定義: echo &amp;ldquo;&lt;!-- raw HTML omitted --&gt;=&lt;!-- raw HTML omitted --&gt;&amp;rdquo; &amp;raquo; &amp;ldquo;${GITHUB_OUTPUT}&amp;rdquo;&lt;/li&gt;&#xA;&lt;li&gt;参照: ${{ steps.&lt;!-- raw HTML omitted --&gt;.outputs.&lt;!-- raw HTML omitted --&gt; }}&lt;/li&gt;&#xA;&lt;li&gt;参照方法を見ると分かる通り、ステップ間の依存関係が明白&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;GITHUB_ENV環境変数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定義: echo &amp;ldquo;&lt;!-- raw HTML omitted --&gt;=&lt;!-- raw HTML omitted --&gt;&amp;rdquo; &amp;raquo; &amp;ldquo;${GITHUB_ENV}&amp;rdquo;&lt;/li&gt;&#xA;&lt;li&gt;参照: ${GITHUB_ENV}&lt;/li&gt;&#xA;&lt;li&gt;ステップIDの指定が不要なので、どのステップで環境変数を設定したかを意識する必要ない&lt;/li&gt;&#xA;&lt;li&gt;異なる複数のステップで、同じ値を参照する場合に使える（ただしステップ間の依存がわかりづらくなる）&lt;/li&gt;&#xA;&lt;li&gt;これで定義したものは、事実上グローバル変数なので、ワークフローが大きくなるとバグの原因になるので注意が必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;特にこだわりなければ、GITHUB_OUTPUTを使用する&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;github-apiの実行&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#github-api%e3%81%ae%e5%ae%9f%e8%a1%8c&#34;&gt;GitHub APIの実行&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GitHubHostedRunnerの場合は、GitHub CLIがインストールされているのでそれを使うと良い&lt;/li&gt;&#xA;&lt;li&gt;API(CLI)の実行にはトークンが必要&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GHAには簡単に使えるクレデンシャルが利用できる&lt;/li&gt;&#xA;&lt;li&gt;ワークフロー開始時に自動生成、終了すると自動的に破棄&lt;/li&gt;&#xA;&lt;li&gt;有効期限は、ワークフロー実行中のみなので、万が一漏れても影響範囲は限定的&lt;/li&gt;&#xA;&lt;li&gt;取得方法は、&lt;code&gt;${{ secrets.GITHUB_TOKEN }}&lt;/code&gt; もしくは &lt;code&gt;${{ github.token }}&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;どちらでも良いので、どちらかに統一するのが良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;トークンの指定は、&lt;code&gt;GITHUB_TOKEN&lt;/code&gt;もしくは&lt;code&gt;GH_TOKEN&lt;/code&gt;という名前の環境変数をセットするだけで、自動で読み込んでくれる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;パーミッション&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ジョブレベルとワークフローレベルで指定可能&lt;/li&gt;&#xA;&lt;li&gt;スコープ(contents, pull-requests等)とそれに対するアクション(read, write, none)を設定する&lt;/li&gt;&#xA;&lt;li&gt;ただしワークフローを実行しているリポジトリ以外のアクセスは許可されない&lt;/li&gt;&#xA;&lt;li&gt;パーミッションを明示的に定義していない場合、自動でソースコードの読み込み許可はされる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一方、明示的な定義をする場合は、この暗黙的な挙動は無視されるので注意&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;パーミッション周りのトラブルシューティング&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ワークフロー実行ログのSet up jobの中に、GITHUB_TOKEN Permissionsがあるので、そこで実行時のパーミッションを確認できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;スターターワークフロー&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%b9%e3%82%bf%e3%83%bc%e3%82%bf%e3%83%bc%e3%83%af%e3%83%bc%e3%82%af%e3%83%95%e3%83%ad%e3%83%bc&#34;&gt;スターターワークフロー&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GitHubリポジトリのActionsからNew Workflowを選択すると、ワークフローのコレクションが並んでいるので、参考にできそう&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/actions/starter-workflows?tab=readme-ov-file&#34;&gt;https://github.com/actions/starter-workflows?tab=readme-ov-file&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;4章-継続的インテグレーションの実践&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#4%e7%ab%a0-%e7%b6%99%e7%b6%9a%e7%9a%84%e3%82%a4%e3%83%b3%e3%83%86%e3%82%b0%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%ae%e5%ae%9f%e8%b7%b5&#34;&gt;4章 継続的インテグレーションの実践&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;大体以下の流れでワークフローを構成する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;checkout&lt;/li&gt;&#xA;&lt;li&gt;setup(ex: actions/setup-go)&lt;/li&gt;&#xA;&lt;li&gt;リントやテストの実行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;フィルター&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pathsと他の条件を指定するとAND条件になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;静的解析&#xA;&lt;ul&gt;&#xA;&lt;li&gt;actionlintは、GHAワークフローの静的解析を行ってくれるので便利&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;使用時間の削減（どのワークフローでも有用な設定）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ジョブ・ステップレベルのタイムアウト設定&#xA;&lt;ul&gt;&#xA;&lt;li&gt;どのワークフローにも設定するようにする（GHAのデフォルト値は360分と大変長いため）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;自動キャンセル（新しいコミットが追加されたら、古いコミットで動作しているワークフローを自動でキャンセルする）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;シェル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ステップごとに起動シェルをshellキーで設定可能&lt;/li&gt;&#xA;&lt;li&gt;Ubuntuの場合、省略時はbashだが、shellキーの指定有無で起動オプションが変更される&lt;/li&gt;&#xA;&lt;li&gt;全ステップに書くのは面倒なので、ワークフローのトップレベルにデフォルト設定(defaults句)するのが良い&lt;/li&gt;&#xA;&lt;li&gt;デフォルトシェルにはデメリットは存在しないので、全てのワークフローに機械的に入れるのがオススメ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;concurrency&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#concurrency&#34;&gt;Concurrency&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ワークフローはイベント駆動なので、イベントが発生すると起動、さらにまたイベントが発生すると起動することになる&lt;/li&gt;&#xA;&lt;li&gt;起動制御できる仕組みとして、Concurrencyがある&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;concurrency: &amp;lt;group-name&amp;gt;&lt;/code&gt;とすることで、同一グループの多重制御が設定できる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;さらに&lt;code&gt;cancel-in-progress: true&lt;/code&gt;で自動キャンセルの設定も可能（プルリクエストで最新ではないコミットのCIとかに有効）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ciの黄金律&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#ci%e3%81%ae%e9%bb%84%e9%87%91%e5%be%8b&#34;&gt;CIの黄金律&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;「クリーンに保つ」&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全てのステータスチェックが成功した時だけマージできるようにする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;「高速に実行する」&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CIの実行が遅いと、待ち時間に他の作業→CIで失敗したらその対応する時にコンテキストスイッチが必要になる&lt;/li&gt;&#xA;&lt;li&gt;時間の無駄だし、開発効率の低下につながる&lt;/li&gt;&#xA;&lt;li&gt;CIのスピードは大切で、理想は5分以内、遅くとも10分以内に終わらせるように&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;「ノイズを減らす」&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CIからのフィードバックで価値ある情報の「シグナル」とそうではない「ノイズ」&lt;/li&gt;&#xA;&lt;li&gt;判断基準としては、その情報を受け取り、これは気にしなくて良いやと流したならそれがノイズ&lt;/li&gt;&#xA;&lt;li&gt;ノイズがあると、シグナルもスルーされてしまうので、ノイズは意識的に減らす&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;テスト&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%83%86%e3%82%b9%e3%83%88&#34;&gt;テスト&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;単体テストの割合を増やす&lt;/li&gt;&#xA;&lt;li&gt;フレーキーテストを放置しない（閾値を超えるとテスト全体が信頼されなくなる）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Googleソフトウェアエンジニアリングでは閾値は1％とされている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;遅いテストは実行タイミングをPRマージの時に限定するなど工夫する&lt;/li&gt;&#xA;&lt;li&gt;使用しているテストツールで以下のような機能を利用する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;部分実行&lt;/li&gt;&#xA;&lt;li&gt;並列実行&lt;/li&gt;&#xA;&lt;li&gt;シャッフル実行（テスト間の隠れた依存関係も洗い出せる）&lt;/li&gt;&#xA;&lt;li&gt;カテゴリ実行（スローテスト用のカテゴリを作ってそれだけ実行しないみたいな）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;静的解析&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e9%9d%99%e7%9a%84%e8%a7%a3%e6%9e%90&#34;&gt;静的解析&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不要な警告は無視するのではなく抑止する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ignoreやsuppressのキーワードで検索する&lt;/li&gt;&#xA;&lt;li&gt;抑止理由はコメントやコミットメッセージに残しておく&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;第5章-運用しやすいワークフロー設計&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e7%ac%ac5%e7%ab%a0-%e9%81%8b%e7%94%a8%e3%81%97%e3%82%84%e3%81%99%e3%81%84%e3%83%af%e3%83%bc%e3%82%af%e3%83%95%e3%83%ad%e3%83%bc%e8%a8%ad%e8%a8%88&#34;&gt;第5章 運用しやすいワークフロー設計&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;長期運用で役立つプラクティスの紹介&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ロギング&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%83%ad%e3%82%ae%e3%83%b3%e3%82%b0&#34;&gt;ロギング&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ワークフローの再実行時の「Enable debug logging」を有効にすると、デバッグログが確認できる&lt;/li&gt;&#xA;&lt;li&gt;デバッグログには以下がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ステップデバッグログ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ステップのログの詳細（ステップステータスや各種コンテキスト）をトレースできる&lt;/li&gt;&#xA;&lt;li&gt;SecretsまたはVariablesに「&lt;code&gt;ACTIONS_STEP_DEBUG&lt;/code&gt;」をtrueで登録しておくことで、これらの値も確認できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;他は内部実装者向けだったりするので、割愛&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Bashのトレーシングオプション&#xA;&lt;ul&gt;&#xA;&lt;li&gt;デバッグログよりシンプルで、どんなコマンドが実行され、結果はなんだったのかを知りたいケースで使用する&lt;/li&gt;&#xA;&lt;li&gt;Bashのトレーシングオプションは、&lt;code&gt;set -x&lt;/code&gt;を実行するだけなので、手軽だが強力&lt;/li&gt;&#xA;&lt;li&gt;全てのコマンドが実行前に表示されるようになり、どのコマンドがどのような引数で実行されているかを確認できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ログのグルーピング、手動マスク等もある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;レポーティング&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%83%ac%e3%83%9d%e3%83%bc%e3%83%86%e3%82%a3%e3%83%b3%e3%82%b0&#34;&gt;レポーティング&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アノテーション&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;echo &amp;quot;::error::This is error&amp;quot;&lt;/code&gt;みたいな形で書くとジョブページにみやすい形で表示&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ジョブサマリー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;シンプルなテキストならアノテーションで十分だが、複数行表示したい場合等はマークダウン形式で出力される&lt;code&gt;${GITHUB_STEP_SUMMARY}&lt;/code&gt;が便利&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;複数ジョブの実行制御&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e8%a4%87%e6%95%b0%e3%82%b8%e3%83%a7%e3%83%96%e3%81%ae%e5%ae%9f%e8%a1%8c%e5%88%b6%e5%be%a1&#34;&gt;複数ジョブの実行制御&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;デフォルトでは複数のジョブを実行すると並列実行される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;並列実行は、全体の実行時間を短縮できる&lt;/li&gt;&#xA;&lt;li&gt;もしジョブの実行時間の長さに問題がある場合は、ジョブを細かく分割し、並列実行させるというアプローチもある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;逐次実行させたい場合は、&lt;code&gt;needs&lt;/code&gt;を使用する&lt;/li&gt;&#xA;&lt;li&gt;ジョブ間のデータ共有&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$GITHUB_OUTPUT環境変数に出力し、stepsコンテキスト経由で受け渡す&lt;/li&gt;&#xA;&lt;li&gt;受け取る側は、needsコンテキストを経由で受け取る&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;environments&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#environments&#34;&gt;Environments&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;環境差分をパラメータ化でき、VariablesとSecretsがある&lt;/li&gt;&#xA;&lt;li&gt;参照方法は、通常のVariablesとSecretsと同一(vars.xxx, secrets.xxx)&lt;/li&gt;&#xA;&lt;li&gt;よくあるのはワークフローの入力値で環境名をもらい、それをenvironmentsにセットし、同じ変数名(環境ごとに値が異なる)を参照&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;キャッシュ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%ad%e3%83%a3%e3%83%83%e3%82%b7%e3%83%a5&#34;&gt;キャッシュ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;actions/cachedでGHA上にキャッシュとその利用が可能&lt;/li&gt;&#xA;&lt;li&gt;実行時のパラメータとして&#xA;&lt;ul&gt;&#xA;&lt;li&gt;key: キャッシュキー。生成と保存に利用する。&lt;/li&gt;&#xA;&lt;li&gt;path: キャッシュ対象となるディレクトリ/ファイルパス。&lt;/li&gt;&#xA;&lt;li&gt;restore-keys: キャッシュミス時のリストアキーを複数指定する。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;キャッシュ復元時に挙動&#xA;&lt;ul&gt;&#xA;&lt;li&gt;①keyキーに定義したキャッシュキーと厳密に一致するキャッシュを探す&lt;/li&gt;&#xA;&lt;li&gt;②リストアキーの定義順に、プレフィックスが一致するキャッシュを探す&lt;/li&gt;&#xA;&lt;li&gt;リストアキーは省力可能であり、これはパッケージマネージャーと併用するときに威力を発揮する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;大半のパッケージマネージャーはキャッシュにないファイルだけダウンロードするように振る舞う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;キャッシュは、7日以上アクセスされないと自動削除される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ブラウザからリポジトリ画面で手動削除も可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;合計サイズは、リポジトリで10GBまで&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;キャッシュキーの設計&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%ad%e3%83%a3%e3%83%83%e3%82%b7%e3%83%a5%e3%82%ad%e3%83%bc%e3%81%ae%e8%a8%ad%e8%a8%88&#34;&gt;キャッシュキーの設計&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プラットフォームごとに異なるキャッシュを利用するようにする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;キャッシュは最低でもOSごとに分離する&lt;/li&gt;&#xA;&lt;li&gt;他にもCPUアーキテクチャや言語バージョン、パッケージマネージャーもキャッシュキーの候補&lt;/li&gt;&#xA;&lt;li&gt;例えば、OSとCPUアーキテクチャでキャッシュを分離するなら: &lt;code&gt;key: example-${{ runner.os }}-${{ runner.arch }}&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;依存関係を更新した時だけキャッシュを変更するようにする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;package-lock.jsonのようなロックファイルがある場合、そのファイルハッシュをハッシュキーに指定する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;hashfiles(&#39;**/package-lock.json)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ロックファイルが更新されない限り、キャッシュが利用されるようになる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;アーティファクト&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%a2%e3%83%bc%e3%83%86%e3%82%a3%e3%83%95%e3%82%a1%e3%82%af%e3%83%88&#34;&gt;アーティファクト&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ワークフロー内で生成したファイルをアーティファクトと呼ぶ&lt;/li&gt;&#xA;&lt;li&gt;アーティファクトはGitHubストレージへ一時的に保存ができる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ビルドしたバイナリやメトリクスデータの保存に利用できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;アーティファクトの保存はデフォルト90日で、保存時にパラメータ(retention-days)で指定可能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プライベートリポジトリだとストレージ容量は課金対象のため、保存期間を短くすると節約できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;6章-アクションによるモジュール化&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#6%e7%ab%a0-%e3%82%a2%e3%82%af%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%ab%e3%82%88%e3%82%8b%e3%83%a2%e3%82%b8%e3%83%a5%e3%83%bc%e3%83%ab%e5%8c%96&#34;&gt;6章 アクションによるモジュール化&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ここでいう「アクションによるモジュール化」とは、ワークフローにおける小さな部品（ステップやコマンドの小さな単位）をモジュール化すること&lt;/li&gt;&#xA;&lt;li&gt;ランナーは、呼び出し元ワークフローに依存する&lt;/li&gt;&#xA;&lt;li&gt;アクションの実装方式は以下の3つがある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Composite: YAMLで定義&lt;/li&gt;&#xA;&lt;li&gt;JavaScript: JSで定義&lt;/li&gt;&#xA;&lt;li&gt;Docker Container: Dockerで動かす(ビルド・起動するDockerfileを指定)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これらはrunsのusingキーで指定する(ex: &lt;code&gt;using: composite&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;アクションのロケーションは「ローカル」と「リモート」がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リモート: &lt;code&gt;uses: actions/checkout@v4&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;URLと連動する&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;@v4&lt;/code&gt;の部分はGitのタグ（ブランチやコミットハッシュも指定可能）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ローカル: &lt;code&gt;uses: ./.github/actions/hello/&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;先頭部分が.であることが目印&lt;/li&gt;&#xA;&lt;li&gt;ルートディレクトリを起点にパスを記述する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;compositeaction&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#compositeaction&#34;&gt;CompositeAction&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;メタデータファイル(action.yml)が必要&lt;/li&gt;&#xA;&lt;li&gt;メタデータ構文のワークフロー構文との違いや注意点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;シェル指定が必須&lt;/li&gt;&#xA;&lt;li&gt;githubコンテキストのeventプロパティの使用は避ける&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アクションはトリガー指定ができないので、呼び出し元のワークフローによりeventの中身がガラリと変わるため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;variablesとsecretsは直接参照できない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;inputとして渡す必要あり&#xA;&lt;ul&gt;&#xA;&lt;li&gt;secretsを渡したらログ出力時のマスクはしてくれる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;環境変数のスコープはワークフローに準拠する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ワークフロー側で定義した環境変数は参照できるし、アクション側で書き出した環境変数はワークフロー側からも参照可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;パーミッション定義できない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ワークフロー側で制御するようにする&lt;/li&gt;&#xA;&lt;li&gt;つまり呼び出し側ワークフローでパーミッション定義を忘れると実行エラーが発生するので、どのようなパーミッションが必要かはREADMEなどに残しておくのがオススメ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;アクション設計プラクティス&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%a2%e3%82%af%e3%82%b7%e3%83%a7%e3%83%b3%e8%a8%ad%e8%a8%88%e3%83%97%e3%83%a9%e3%82%af%e3%83%86%e3%82%a3%e3%82%b9&#34;&gt;アクション設計プラクティス&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;認知負荷の低減&#xA;&lt;ul&gt;&#xA;&lt;li&gt;利用者はコードが読みたいのではなく、アクションを使いたいだけ&lt;/li&gt;&#xA;&lt;li&gt;なのでアクションの名前と概要はきちんとわかりやすいように書く（input/outputも）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;secrets.GITHUB_TOKEN&lt;/code&gt;の取り方&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アクションからsecretsは参照できないので&lt;code&gt;secrets.GITHUB_TOKEN&lt;/code&gt;は参照できないが、&lt;code&gt;github.token&lt;/code&gt;で同じ値を参照できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;スクリプトの切り出し&#xA;&lt;ul&gt;&#xA;&lt;li&gt;内部ロジックが大きくなってきたらshファイルとして別で切り出すと良い&lt;/li&gt;&#xA;&lt;li&gt;切り出したshファイルは、&lt;code&gt;GITHUB_ACTION_PATH&lt;/code&gt;環境変数で実行する必要がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;run句に単純なshファイルへの相対パスを指定するだけでは実行できない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;環境変数による暗黙的な依存の回避&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ワークフローとアクションで相互に環境変数は参照できるが、必要な値はinputs/outputsで明示的に受け渡すようにするのが良い&lt;/li&gt;&#xA;&lt;li&gt;コードが追いづらくなるのと、意図せず壊れてしまうリスクがある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ロググループ化の活用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;まず大前提としてきちんとログを出力する（デバッグ効率が圧倒的に良くなるため）&lt;/li&gt;&#xA;&lt;li&gt;CompositeActionのログはステップごとに分割されないのでログを追うのが難しくなる&lt;/li&gt;&#xA;&lt;li&gt;なのでロググループ化を活用する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;アクションとnodeバージョン&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%a2%e3%82%af%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%a8node%e3%83%90%e3%83%bc%e3%82%b8%e3%83%a7%e3%83%b3&#34;&gt;アクションとNodeバージョン&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GitHubが提供する多くのアクションはJSで実装されている&lt;/li&gt;&#xA;&lt;li&gt;Nodeバージョンが上がるとアクションのメジャーバージョンが上がることが多い&lt;/li&gt;&#xA;&lt;li&gt;このバージョンアップ作業が地味に大変な作業&amp;hellip;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;7章-クリーンなリポジトリの維持&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#7%e7%ab%a0-%e3%82%af%e3%83%aa%e3%83%bc%e3%83%b3%e3%81%aa%e3%83%aa%e3%83%9d%e3%82%b8%e3%83%88%e3%83%aa%e3%81%ae%e7%b6%ad%e6%8c%81&#34;&gt;7章 クリーンなリポジトリの維持&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;リポジトリルール&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%83%aa%e3%83%9d%e3%82%b8%e3%83%88%e3%83%aa%e3%83%ab%e3%83%bc%e3%83%ab&#34;&gt;リポジトリルール&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ブランチプロテクションルールを設定しよう&lt;/li&gt;&#xA;&lt;li&gt;コードオーナーを設定して全てのコードにオーナーシップを維持しよう&#xA;&lt;ul&gt;&#xA;&lt;li&gt;自動でコードオーナーにレビュー依頼が飛ぶ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;シークレットスキャンを導入して、秘匿情報混入を検出しよう&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コードやIssueの本文やコメントなどもチェックしてくれる&lt;/li&gt;&#xA;&lt;li&gt;GitHubが定期的にチェックする（つまり事後）&lt;/li&gt;&#xA;&lt;li&gt;プッシュプロテクションをEnableにすると、プッシュするタイミングでチェックが走る&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ドキュメント&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%83%89%e3%82%ad%e3%83%a5%e3%83%a1%e3%83%b3%e3%83%88&#34;&gt;ドキュメント&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;READMEは読み手のことを考える&lt;/li&gt;&#xA;&lt;li&gt;LICENSEは確認するようにする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;MITは、責任とらないけど自由に使ってねくらいのニュアンス&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;コミュニティヘルスファイル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CONTRIBUTING.md: コントリビューション方法のガイド（PRやIssueの出し方、コーディング規約）&lt;/li&gt;&#xA;&lt;li&gt;CODE_OF_CONDUCT.md: 行動規範&lt;/li&gt;&#xA;&lt;li&gt;SECURITY.md: 脆弱性報告方法など&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;8章-dependabotによる依存関係バージョンアップ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#8%e7%ab%a0-dependabot%e3%81%ab%e3%82%88%e3%82%8b%e4%be%9d%e5%ad%98%e9%96%a2%e4%bf%82%e3%83%90%e3%83%bc%e3%82%b8%e3%83%a7%e3%83%b3%e3%82%a2%e3%83%83%e3%83%97&#34;&gt;8章 Dependabotによる依存関係バージョンアップ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ソフトウェアは何もしないと壊れるので、変更し続ける必要がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;依存関係の管理には、検知・把握・実装・テストという活動が必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Dependabotには以下3つの依存関係の管理をサポートする機能がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dependabot version updates: 最新バージョンへの自動アップデート&lt;/li&gt;&#xA;&lt;li&gt;Dependabot security updates: 脆弱性を含むバージョンの自動アップデート&lt;/li&gt;&#xA;&lt;li&gt;Dependabot alerts: 脆弱性が含まれるバージョンのアラート通知&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ワークフローで実践&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ブランチプロテクションルールを設定し、全てのステータスチェックを行ってからマージしたい場合&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GitHub CLIのmergeコマンドに&lt;code&gt;--auto&lt;/code&gt;をつけることで、全ワークフローの成功状態になった後に、自動でマージしてくれる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Dependabotが起動したワークフローは通常のsecretsへのアクセスができないので、Dependabot用のsecretsを登録する必要があるので注意&#xA;&lt;ul&gt;&#xA;&lt;li&gt;厄介なのが何もエラーが出ず、空文字で処理が進むので、頭の片隅に入れておくと良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;dependabot/fetch-metadataアクションを活用する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dependabotが起動するワークフローで使用可能で、バージョンアップ・依存関係の種類、パッケージエコシステムを取得できる&lt;/li&gt;&#xA;&lt;li&gt;有効活用の例&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パッチバージョンの場合は自動マージ&lt;/li&gt;&#xA;&lt;li&gt;開発環境向けの変更は自動マージ&lt;/li&gt;&#xA;&lt;li&gt;GHA向けの変更は自動マージ&lt;/li&gt;&#xA;&lt;li&gt;このように少しでも手動対応量を減らすことで、少しでも楽をする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;9章-github-releasesによるリリース自動化&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#9%e7%ab%a0-github-releases%e3%81%ab%e3%82%88%e3%82%8b%e3%83%aa%e3%83%aa%e3%83%bc%e3%82%b9%e8%87%aa%e5%8b%95%e5%8c%96&#34;&gt;9章 GitHub Releasesによるリリース自動化&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;バージョニング&#xA;&lt;ul&gt;&#xA;&lt;li&gt;いつどんな変更が行われたのかをバージョンを併記してユーザーに知らせることができる&lt;/li&gt;&#xA;&lt;li&gt;トラブル時はバージョン情報をやり取りすることで関係者間の意思疎通が楽になる&lt;/li&gt;&#xA;&lt;li&gt;開発者としてもどのバージョンで不具合が発生したかがわかれば、修正が楽になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;セマンティックバージョニング&#xA;&lt;ul&gt;&#xA;&lt;li&gt;メジャー.マイナー.パッチという構成のバージョニング方式&lt;/li&gt;&#xA;&lt;li&gt;順序性だけでなく、後方互換性に関心を寄せているのが特徴&lt;/li&gt;&#xA;&lt;li&gt;完璧ではない（後方互換性が個人の考え方やスキルに依存する点）が、有名であること視認性が高いことで、選択としては無難である&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Gitタグの保護はやっておこう（ブランチ保護と同じような感じ）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ReleasesがGitタグに依存しており、そのGitタグが削除された場合、リリースノートは下書き状態となってしまうため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;10章-github-packagesによるパッケージ管理&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#10%e7%ab%a0-github-packages%e3%81%ab%e3%82%88%e3%82%8b%e3%83%91%e3%83%83%e3%82%b1%e3%83%bc%e3%82%b8%e7%ae%a1%e7%90%86&#34;&gt;10章 GitHub Packagesによるパッケージ管理&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パッケージエコシステム&#xA;&lt;ul&gt;&#xA;&lt;li&gt;npmやMavenなどの言語パッケージ、HomebrewなどのOSパッケージ、Dockerなどのコンテナイメージもパッケージの一種&lt;/li&gt;&#xA;&lt;li&gt;ソフトウェアのインストール・管理（依存関係の把握、ライブラリが足りなければ自動でダウンロード、新しいバージョンの検知、最新版へのアップデート等）を容易にする&lt;/li&gt;&#xA;&lt;li&gt;提供者はパッケージマネージャークライアントを通じてパッケージを作成・登録＆メタデータを提供し、利用者はパッケージマネージャークライアントを通じてパッケージを検索・取得・更新＆依存関係を解決する（そしてこの両者をつなぐのがパッケージレジストリ）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ContainerRegistryの話がメインで、使いそうもないのでスキップ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;11章-openid-connectによるセキュアなクラウド連携&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#11%e7%ab%a0-openid-connect%e3%81%ab%e3%82%88%e3%82%8b%e3%82%bb%e3%82%ad%e3%83%a5%e3%82%a2%e3%81%aa%e3%82%af%e3%83%a9%e3%82%a6%e3%83%89%e9%80%a3%e6%90%ba&#34;&gt;11章 OpenID Connectによるセキュアなクラウド連携&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;クラウドプロバイダのクレデンシャル&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%af%e3%83%a9%e3%82%a6%e3%83%89%e3%83%97%e3%83%ad%e3%83%90%e3%82%a4%e3%83%80%e3%81%ae%e3%82%af%e3%83%ac%e3%83%87%e3%83%b3%e3%82%b7%e3%83%a3%e3%83%ab&#34;&gt;クラウドプロバイダのクレデンシャル&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クラウドプロバイダは誰がアクセスしようとしているかを「認証」によって判断する&lt;/li&gt;&#xA;&lt;li&gt;クレデンシャルは、その認証に利用するもので、ユーザーIDとパスワードもその一種&lt;/li&gt;&#xA;&lt;li&gt;認証する側が、アクセスキーやAPIキーといった呼び名のランダム文字列を発行し、それをクレデンシャルとして利用する&lt;/li&gt;&#xA;&lt;li&gt;プログラムがリクエスト時にそのクレデンシャルを一緒に送信することで、認証と認証情報が正しければ正常レスポンスを受け取れるという仕組み&lt;/li&gt;&#xA;&lt;li&gt;静的クレデンシャル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;長期にわたって変更しないパスワードのようなクレデンシャルを静的クレデンシャルという&lt;/li&gt;&#xA;&lt;li&gt;静的クレデンシャルは長命という欠点があり、漏洩した場合の被害が拡大しやすい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;一時クレデンシャル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;こちらは必要なタイミングで都度払い出すので短命&lt;/li&gt;&#xA;&lt;li&gt;ローテーション作業もないので運用も楽&lt;/li&gt;&#xA;&lt;li&gt;OpenID Connectというプロトコルによって実現する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;クラウド連携のアンチパターン&#xA;&lt;ul&gt;&#xA;&lt;li&gt;静的クレデンシャルは使用してはいけない&lt;/li&gt;&#xA;&lt;li&gt;かつてはそれしか選択肢がなかったので、記事を探すときは要注意&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;openid-connectoidc&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#openid-connectoidc&#34;&gt;OpenID Connect(OIDC)&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これは複数の異なるドメインで認証結果を共有し、協調してサービスを提供するオープンなプロトコル（アイデンティ連携を実現する）&lt;/li&gt;&#xA;&lt;li&gt;OAuth2.0を拡張する形で設計されている&lt;/li&gt;&#xA;&lt;li&gt;利点として、GitHub上で静的クレデンシャルの管理が不要になる(一時クレデンシャルを取得するため)＋認証時にアクセス元を細かく制限できる（GHAの場合特定リポジトリのみに許可できる）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;一時クレデンシャルの取得フロー&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e4%b8%80%e6%99%82%e3%82%af%e3%83%ac%e3%83%87%e3%83%b3%e3%82%b7%e3%83%a3%e3%83%ab%e3%81%ae%e5%8f%96%e5%be%97%e3%83%95%e3%83%ad%e3%83%bc&#34;&gt;一時クレデンシャルの取得フロー&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ワークフローで以下の流れで、クラウドプロバイダから最終的に一時クレデンシャルを取得する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;GitHub OIDC ProviderからOIDCトークンを取得(ワークフロー→GitHub OIDC Provider)&lt;/li&gt;&#xA;&lt;li&gt;OIDCトークンと一時クレデンシャルを交換(GitHub OIDC Provider→クラウドプロバイダ)&lt;/li&gt;&#xA;&lt;li&gt;一時クレデンシャルで操作&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;大抵の処理は隠蔽されており、私たちは行う作業は以下の2つのみ（準備に若干手間はかかるがメリットが大きい）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クラウドプロバイダ側でOIDCに必要なコンポーネントを作成する&lt;/li&gt;&#xA;&lt;li&gt;ワークフローへクラウドプロバイダの認証アクションを組み込む&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;oidc-trustとcloud-roles&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#oidc-trust%e3%81%a8cloud-roles&#34;&gt;OIDC TrustとCloud Roles&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クラウドプロバイダで準備するコンポーネントは以下の2つ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;OIDC Trust&lt;/strong&gt;: クラウドプロバイダが信頼するOIDC Providerを設定(GitHub OIDC Provider)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OIDCトークンで一時クレデンシャルを取得できる理由は、クラウドプロバイダがOIDC Providerを信頼しているため（OIDC Trust）&lt;/li&gt;&#xA;&lt;li&gt;OIDCトークンはJWT形式で、GitHub OIDC Providerの公開鍵を使って署名等の検証が行われる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Cloud Roles&lt;/strong&gt;: 一時クレデンシャルのアクセス先とアクセス元を制御&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一時クレデンシャルの「アクセス先」を管理する&lt;/li&gt;&#xA;&lt;li&gt;AWSでいうIAMロールのこと&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;認証アクション&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e8%aa%8d%e8%a8%bc%e3%82%a2%e3%82%af%e3%82%b7%e3%83%a7%e3%83%b3&#34;&gt;認証アクション&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;各クラウドプロバイダは公式で認証アクションを提供しているので、ワークフローからはそのアクションを呼び出すだけで、OIDCが扱える&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;検証作業のリスクヘッジ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e6%a4%9c%e8%a8%bc%e4%bd%9c%e6%a5%ad%e3%81%ae%e3%83%aa%e3%82%b9%e3%82%af%e3%83%98%e3%83%83%e3%82%b8&#34;&gt;検証作業のリスクヘッジ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プライベートリポジトリで試す&lt;/li&gt;&#xA;&lt;li&gt;認証パラメータ(AWSアカウントIDやIAMロール名)はSecretsで管理する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これらクレデンシャルではないものの、ログ出力時にマスクされるので、謝ってパブリックリポジトリでワークフローを実行しても、第三者へ余計な情報が漏れない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;awsにおけるoidc利用準備と連携&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#aws%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8boidc%e5%88%a9%e7%94%a8%e6%ba%96%e5%82%99%e3%81%a8%e9%80%a3%e6%90%ba&#34;&gt;AWSにおけるOIDC利用準備と連携&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以下の2つを作成する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OIDC Provider&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWSがGitHub OIDC Providerを信頼するように設定&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;IAMロール&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一時クレデンシャルのアクセス先とアクセス元を制御する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;GHAワークフロー側での設定作業&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Secrets登録&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWSアカウントID&lt;/li&gt;&#xA;&lt;li&gt;IAMロール名&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ワークフロー実装&#xA;&lt;ul&gt;&#xA;&lt;li&gt;permissions&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;id-token: write&lt;/code&gt;の設定が必要&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GitHub OIDC ProviderからOIDCトークン取得に必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;aws-actions/configure-aws-credentialsを利用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ロールARNとセッション名、デフォルトリージョンをパラメータとして指定する&lt;/li&gt;&#xA;&lt;li&gt;セッション名は、トレーザビリティを目的に、AssumeRole APIに渡すパラメータ名であり、CloudTrailのセッション名として記録される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;「誰が・いつ・どのジョブでこのセッションを作ったか分かる」ような情報を含めると便利&lt;/li&gt;&#xA;&lt;li&gt;例：&lt;code&gt;&amp;quot;${{ github.workflow }}-${{ github.run_id }}-${{ github.actor }}&amp;quot;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CloudRolesのセキュアな運用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;他のリポジトリからアクセスできないことを確認しておく&lt;/li&gt;&#xA;&lt;li&gt;CloudRolesは目的ごとに分離する（必要最小限の権限だけ）&lt;/li&gt;&#xA;&lt;li&gt;クラウドプロバイダの設定作業にIaCを導入する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;12章-コンテナオーケストレーションのデプロイメント&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#12%e7%ab%a0-%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e3%82%aa%e3%83%bc%e3%82%b1%e3%82%b9%e3%83%88%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%ae%e3%83%87%e3%83%97%e3%83%ad%e3%82%a4%e3%83%a1%e3%83%b3%e3%83%88&#34;&gt;12章 コンテナオーケストレーションのデプロイメント&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;デプロイ自動化の流れ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテナビルドアクション：コンテナイメージのビルド＆プッシュ&lt;/li&gt;&#xA;&lt;li&gt;コンテナデプロイアクション：タスク定義の書き換えとサービスの更新&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;本番環境へのデプロイはルールを制限したい&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Deployment branches and tagsを設定する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Environmentsからブランチ名パターンを登録することでパターン外のブランチでワークフローを起動できなくなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Required Reviewers&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ワークフローの起動に承認を必須とする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;デプロイメント設計&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%83%87%e3%83%97%e3%83%ad%e3%82%a4%e3%83%a1%e3%83%b3%e3%83%88%e8%a8%ad%e8%a8%88&#34;&gt;デプロイメント設計&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;デプロイの設計では「ユーザー影響」と「ロールバック」の観点に着目する&lt;/li&gt;&#xA;&lt;li&gt;ローリングアップデート&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ECSのデプロイ方式&lt;/li&gt;&#xA;&lt;li&gt;新しいバージョンへ少しずつ置き換える&lt;/li&gt;&#xA;&lt;li&gt;無停止&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ロールバック&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ローリングアップデートの場合は特別な仕組みはないので、リバートコミットを追加し、再デプロイする（あまり速くない）&lt;/li&gt;&#xA;&lt;li&gt;人間が切り戻しを検知・判断するので、別途監視の仕組みが必要となる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;第14章-github-actionsの高度な使い方&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e7%ac%ac14%e7%ab%a0-github-actions%e3%81%ae%e9%ab%98%e5%ba%a6%e3%81%aa%e4%bd%bf%e3%81%84%e6%96%b9&#34;&gt;第14章 GitHub Actionsの高度な使い方&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;reusable-workflows&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#reusable-workflows&#34;&gt;Reusable Workflows&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アクションは比較的小さな処理をカプセル化するのに対し、Reusable Workflowsはワークフロー全体を丸ごとカプセル化する&lt;/li&gt;&#xA;&lt;li&gt;パーミッション&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パーミッション定義を省略した場合は呼び出し側ワークフローのパーミッションを暗黙的に継承する&lt;/li&gt;&#xA;&lt;li&gt;呼び出し側より厳しくできるが、緩めることはできない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;なので、呼び出し側ではジョブレベルでパーミッションを定義すると良い（Reusable Workflowsの権限が最小限になるため＋ドキュメンテーションとなり可読性が向上する）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;コンテキスト&#xA;&lt;ul&gt;&#xA;&lt;li&gt;呼び出し側ワークフローのコンテキストを直接参照できる&lt;/li&gt;&#xA;&lt;li&gt;ただしReusable Workflowsが制御できないgithub.eventプロパティを参照すると再利用性は低下するので注意が必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Secrets&#xA;&lt;ul&gt;&#xA;&lt;li&gt;呼び出し側ワークフローのコンテキストを直接参照できない&lt;/li&gt;&#xA;&lt;li&gt;入力パラメータ経由で渡す or 呼び出し側で&lt;code&gt;secrets: inherit&lt;/code&gt;を指定するとまとめて継承可能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;暗黙的な継承となりコードが追いづらくなるので個別で入力パラメータとして渡すのが良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;環境変数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;こちらも参照できないので入力パラメータ経由で渡す&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;fromjson関数&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#fromjson%e9%96%a2%e6%95%b0&#34;&gt;fromJSON関数&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;動的なワークフロー定義&#xA;&lt;ul&gt;&#xA;&lt;li&gt;事前にマトリクスを生成できない場合、fromJSON()をmatrixに指定することで動的にマトリクスを生成できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;文字列の型変換&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ワークフロー構文の環境変数はstring型として扱われてしまう&lt;/li&gt;&#xA;&lt;li&gt;その際string型の文字列をnumber型やboolean型に変換できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;エラーハンドリング&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%a8%e3%83%a9%e3%83%bc%e3%83%8f%e3%83%b3%e3%83%89%e3%83%aa%e3%83%b3%e3%82%b0&#34;&gt;エラーハンドリング&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Continue on Error&#xA;&lt;ul&gt;&#xA;&lt;li&gt;デフォルトではエラーが発生するとその時点でワークフローが停止する&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;continue-on-error: true&lt;/code&gt;を指定すると、エラーを握りつぶし、次の処理に進む&lt;/li&gt;&#xA;&lt;li&gt;これを指定すると、途中でエラーが発生しても、ワークフロー自体は正常終了扱いされる&lt;/li&gt;&#xA;&lt;li&gt;ログを見ない限りエラーには気づけないので、リカバリー不要な場合のみ使用する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;マトリックスのフェイルファスト&#xA;&lt;ul&gt;&#xA;&lt;li&gt;マトリックスを使うと複数のジョブが並列に起動する&lt;/li&gt;&#xA;&lt;li&gt;途中でエラーが発生した場合、他のジョブが止まる&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;fail-fast: false&lt;/code&gt;を指定することで他のジョブを継続可能とできる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;コンテキストによるフロー制御&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%b3%e3%83%b3%e3%83%86%e3%82%ad%e3%82%b9%e3%83%88%e3%81%ab%e3%82%88%e3%82%8b%e3%83%95%e3%83%ad%e3%83%bc%e5%88%b6%e5%be%a1&#34;&gt;コンテキストによるフロー制御&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;終了状態を取得できるコンテキスト&#xA;&lt;ul&gt;&#xA;&lt;li&gt;stepsコンテキスト：ステップの終了状態を保持&#xA;&lt;ul&gt;&#xA;&lt;li&gt;outcomeプロパティはContinue on Error適用前の終了状態（つまり生情報）&lt;/li&gt;&#xA;&lt;li&gt;conclusionプロパティはContinue on Error適用後の終了状態&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;needsコンテキスト：（依存している）ジョブの終了状態を保持&#xA;&lt;ul&gt;&#xA;&lt;li&gt;resultプロパティのみ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;コンテキストとステータスチェック関数の併用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;「前のステップが失敗したら」という条件式を書きたい場合&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;if: ${{ failure() &amp;amp;&amp;amp; steps.stepName.outcome == &#39;failure&#39; }}&lt;/code&gt;とする必要がある&lt;/li&gt;&#xA;&lt;li&gt;このようにステータスチェック関数とコンテキスト参照を併用する必要がある理由として、&lt;code&gt;failure()&lt;/code&gt;が記述されていない場合、暗黙的に&lt;code&gt;success()&lt;/code&gt;関数が存在すると解釈されるため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;15章-github-actionsのセキュリティ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#15%e7%ab%a0-github-actions%e3%81%ae%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3&#34;&gt;15章 GitHub Actionsのセキュリティ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;この章では「ソフトウェアサプライチェーン」に着目する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ソフトウェアサプライチェーンとは、コード書いてから実行環境へリリースまでに含まれる一連のアクティビティを意味する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;GHAはさまざまなシステムと連携するため、強力な権限が集中するため、悪意ある人にとってはとても魅力な攻撃対象になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;セキュリティのcia&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3%e3%81%aecia&#34;&gt;セキュリティのCIA&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CIAとは、機密性・完全性・可用性のこと&lt;/li&gt;&#xA;&lt;li&gt;CIAの観点から、守るべき資産はコード・クレデンシャル・アーティファクトとなる&lt;/li&gt;&#xA;&lt;li&gt;闇雲に対策するのではなく、利便性とのトレードオフとなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;セキュリティの設計原則&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3%e3%81%ae%e8%a8%ad%e8%a8%88%e5%8e%9f%e5%89%87&#34;&gt;セキュリティの設計原則&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;脅威を完全に排除することは難しいので、脅威の軽減を目標とする&lt;/li&gt;&#xA;&lt;li&gt;アタックサーフェス＝攻撃される恐れのある場所を小さくする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;シンプルな設計を意識する（複雑な設計では意図しないこれ↑を生みやすいので）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;複数のセキュリティレイヤを用意して、多層防御にする&lt;/li&gt;&#xA;&lt;li&gt;最小権限&#xA;&lt;ul&gt;&#xA;&lt;li&gt;攻撃されても被害を小さくできる&lt;/li&gt;&#xA;&lt;li&gt;一時クレデンシャルのような権限の行使に時間の制約があるようなものも有効だと思われる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;githubのサービス特性&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#github%e3%81%ae%e3%82%b5%e3%83%bc%e3%83%93%e3%82%b9%e7%89%b9%e6%80%a7&#34;&gt;Githubのサービス特性&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;上記の設計原則を踏まえて考えていく&lt;/li&gt;&#xA;&lt;li&gt;GitHubはデフォルトの設定は利便性重視なので注意する&lt;/li&gt;&#xA;&lt;li&gt;コードをプッシュできる人はワークフローの実行ができるという仕様を理解する&lt;/li&gt;&#xA;&lt;li&gt;悪意ある人もコントリビューション可能であることを認識する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;サードパーティアクション&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%b5%e3%83%bc%e3%83%89%e3%83%91%e3%83%bc%e3%83%86%e3%82%a3%e3%82%a2%e3%82%af%e3%82%b7%e3%83%a7%e3%83%b3&#34;&gt;サードパーティアクション&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サードパーティのアクションがリポジトリのコードを参照できるかはパーミションによるが、ほとんどのワークフローではコードにチェックアウトするので、大半のアクションはコードを参照できる&lt;/li&gt;&#xA;&lt;li&gt;サードパーティアクション導入時は、そのサードパーティを信頼するかを意識的に決断するようにする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;本当に信頼して良いかを考えるクセをつけるのが重要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;リポジトリ設定で利用制限も可能&lt;/li&gt;&#xA;&lt;li&gt;呼び出し時にコミットハッシュによる固定を行えば、アクションを不変リソースとして扱える&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ハッシュ指定だけでは分かりづらいので、コメントでバージョン情報を併記しておくと分かりやすい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;筆者の考えとしては「ある程度の車輪の再発明は仕方ない」それくらいサードパーティアクションの使用は慎重になるべき&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;スクリプトインジェクション&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%b9%e3%82%af%e3%83%aa%e3%83%97%e3%83%88%e3%82%a4%e3%83%b3%e3%82%b8%e3%82%a7%e3%82%af%e3%82%b7%e3%83%a7%e3%83%b3&#34;&gt;スクリプトインジェクション&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;外からやってくるデータ（例：PRのタイトル）に悪意あるスクリプトが仕込まれていた場合、それがワークフローの中で読み込まれてスクリプトとして実行されてしまうリスクがある&lt;/li&gt;&#xA;&lt;li&gt;対策として、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;中間環境変数による無害化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;env: PR_TITLE: ${{ github.event.pull_request.title }}&lt;/code&gt;というような形でスクリプトインジェクションを防げる&lt;/li&gt;&#xA;&lt;li&gt;どのプロパティが危険かを正確に判断するのは困難なので、コンテキストは常に中間環境変数で参照するようにするのが確実で楽&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ShellCheckによる静的解析&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Github-Hosted Runnerには最初からインストールされている&lt;/li&gt;&#xA;&lt;li&gt;actionlintは内部的にShellCheckを実行していて、yamlに直接書いたスクリプトもチェックしてくれる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;最小権限のパーミッション&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e6%9c%80%e5%b0%8f%e6%a8%a9%e9%99%90%e3%81%ae%e3%83%91%e3%83%bc%e3%83%9f%e3%83%83%e3%82%b7%e3%83%a7%e3%83%b3&#34;&gt;最小権限のパーミッション&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パーミッションはpermissionキーで設定可能&lt;/li&gt;&#xA;&lt;li&gt;省略可能で、省略した場合はコード参照が許可される&lt;/li&gt;&#xA;&lt;li&gt;明示的な記述を習慣化することで、自然とパーミッションを意識するようになる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;具体的には、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ワークフローレベルでのパーミッション無効化(&lt;code&gt;permissions: {}&lt;/code&gt;)の設定を入れることで、コード参照すら明示的な許可が必要になる&lt;/li&gt;&#xA;&lt;li&gt;各ジョブへ都度、必要なパーミッションを定義する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;面倒に見えるが、やってみると慣れるのは早い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ジョブ分割によるパーミッションの分離&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%b8%e3%83%a7%e3%83%96%e5%88%86%e5%89%b2%e3%81%ab%e3%82%88%e3%82%8b%e3%83%91%e3%83%bc%e3%83%9f%e3%83%83%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%ae%e5%88%86%e9%9b%a2&#34;&gt;ジョブ分割によるパーミッションの分離&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パーミッションのスコープはいくつかあるが、特に注意すべきなのが以下の4つ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;contents: 改竄されたコードをプッシュされるリスク&lt;/li&gt;&#xA;&lt;li&gt;packages: 悪意あるパッケージをパブリッシュされるリスク&lt;/li&gt;&#xA;&lt;li&gt;actions: 別のワークフローを意図せず起動されるリスク&lt;/li&gt;&#xA;&lt;li&gt;id-token: OIDCでクラウドプロバイダにアクセスされるリスク&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;これらのパーミッションを複数扱う場合はジョブの分割を検討すると良い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パーミッションをジョブ単位で記述すれば、ジョブがセキュリティ境界となる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;シークレットマネジメント&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%b7%e3%83%bc%e3%82%af%e3%83%ac%e3%83%83%e3%83%88%e3%83%9e%e3%83%8d%e3%82%b8%e3%83%a1%e3%83%b3%e3%83%88&#34;&gt;シークレットマネジメント&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;まずはクレデンシャルの把握をすべき&lt;/li&gt;&#xA;&lt;li&gt;最小権限・一時クレデンシャルを優先・定期的なローテーション&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;openid-connectハードニング&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#openid-connect%e3%83%8f%e3%83%bc%e3%83%89%e3%83%8b%e3%83%b3%e3%82%b0&#34;&gt;OpenID Connectハードニング&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OpenID Connectを深掘りするパート&lt;/li&gt;&#xA;&lt;li&gt;(再掲)一時クレデンシャルの取得フロー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ワークフローで以下の流れで、クラウドプロバイダから最終的に一時クレデンシャルを取得する&#xA;&lt;ol&gt;&#xA;&lt;li&gt;GitHub OIDC ProviderからOIDCトークンを取得(ワークフロー→GitHub OIDC Provider)&lt;/li&gt;&#xA;&lt;li&gt;OIDCトークンと一時クレデンシャルを交換(GitHub OIDC Provider→クラウドプロバイダ)&lt;/li&gt;&#xA;&lt;li&gt;一時クレデンシャルで操作&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;IDトークン&#xA;&lt;ul&gt;&#xA;&lt;li&gt;上記の1のOIDCトークンと呼んでいるものはOIDCの世界ではIDトークンと呼ぶ&lt;/li&gt;&#xA;&lt;li&gt;これには主体に認証情報を含んでおり、リポジトリやワークフローの情報が含まれている&lt;/li&gt;&#xA;&lt;li&gt;これらの属性情報を受け取ったクラウドプロバイダ側で検証し、アクセス可否を判断している&lt;/li&gt;&#xA;&lt;li&gt;IDトークンの実体は、JWTである&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ヘッダ・ペイロード・署名をピリオド区切りでBase64URLエンコードしたもの&lt;/li&gt;&#xA;&lt;li&gt;ペイロードのデータ構造は決まっており、JSONの各フィールドはクレームと呼ぶ&lt;/li&gt;&#xA;&lt;li&gt;IDトークンにはいくつかの必須クレームがあり、この必須クレームがセキュリティ上重要となる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;IDトークンの検証フロー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ワークフローはGitHub OIDC Providerから取得したIDトークンをクラウドプロバイダに渡す&lt;/li&gt;&#xA;&lt;li&gt;クラウドプロバイダはIDトークンの署名を検証し、JWTクレームを検証する&lt;/li&gt;&#xA;&lt;li&gt;この検証に成功したら、一時クレデンシャルをワークフローに返送する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;IDトークンの署名検証&#xA;&lt;ul&gt;&#xA;&lt;li&gt;本当にGitHub OIDC Providerが発行したIDトークンなのか確認する&lt;/li&gt;&#xA;&lt;li&gt;署名の検証には、GitHub OIDC Providerの公開鍵を探し出す必要がある&lt;/li&gt;&#xA;&lt;li&gt;どこを探すかというと、OIDC Trust(AWSの場合はOpenID Connect Provider)にGitHub OIDC ProviderのURLを設定していて、このURLが公開鍵の検索に使用される（https://token.actions.githubusercontent.com）&lt;/li&gt;&#xA;&lt;li&gt;注意点として、上記のURLは全アカウントで共通のため、アカウントやリポジトリの識別ができない（GitHubが生成したという内容しか検証できない）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;そこでJWTクレーム検証でその部分を補う形で検証する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;IDトークンのJWTクレーム検証&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IDトークンの署名だけではGitHub利用者が誰でもアクセスできてしまうため、JWTクレームでも検証を行う&lt;/li&gt;&#xA;&lt;li&gt;JWTクレーム検証はクラウドプロバイダによって異なるが、AWSではAssumeRoleポリシーのCondition定義に基づいて検証を行う&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;subクレーム&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;もっとも重要な検証対象となる&lt;/li&gt;&#xA;&lt;li&gt;認証された主体の識別子が格納される（一般的にはユーザーIDなど）&lt;/li&gt;&#xA;&lt;li&gt;GitHub Actionsでは少し毛色が異なり、ワークフローの属性情報を連結した値が入る（アカウント名やリポジトリ名など）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ワークフローの実行方法によって値が異なるが、repo:&lt;!-- raw HTML omitted --&gt;/&lt;!-- raw HTML omitted --&gt;:のような文字列はどの方法でも含まれる&lt;/li&gt;&#xA;&lt;li&gt;なのでアカウント名やリポジトリ名が正しいかの判断は可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;GitHubのカスタムクレーム&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IDトークンは拡張が認めらていて、任意のカスタムクレームを追加可能&lt;/li&gt;&#xA;&lt;li&gt;クラウドプロバイダによってサポート状況が異なっているので注意（AWSはサポートしていない）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;クラウドプロバイダのJWTクレーム検証設定&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AssumeRoleポリシーのConditionに以下のように記述する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;&amp;quot;token.actions.githubusercontent.com:sub&amp;quot;: &amp;quot;repo:&amp;lt;OWNER&amp;gt;/&amp;lt;REPO&amp;gt;:*&amp;quot;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;左辺のキーはsubクレームを指している&lt;/li&gt;&#xA;&lt;li&gt;他の値もsubクレームで検証するとセキュリティがより強固になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Environmentsの検証&#xA;&lt;ul&gt;&#xA;&lt;li&gt;subクレームに含まれるEnvironmentsの値を検証することで、商用環境にアクセスできるのはレビュー済みのワークフローのみとしたいといった制御が可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;JWTクレームの検証はOpenID Connectのキモであり、特にsubクレームは重要となる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;16章-セキュリティのシフトレフト&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#16%e7%ab%a0-%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3%e3%81%ae%e3%82%b7%e3%83%95%e3%83%88%e3%83%ac%e3%83%95%e3%83%88&#34;&gt;16章 セキュリティのシフトレフト&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;セキュリティは後回しにしがちだが早めに取り組むのが良い戦略&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これがシフトレフトという考え方（痛い目に遭うくらいなら早めに対処しよう）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;依存関係の脆弱性スキャン&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最新に保ち続けられるならそれで十分だけど現実はそうもいかない&lt;/li&gt;&#xA;&lt;li&gt;そこで活用したいのが依存関係の脆弱性を検出するサービス&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dependabot Alerts&#xA;&lt;ul&gt;&#xA;&lt;li&gt;依存関係の脆弱性を発見するとアラートを送信する&lt;/li&gt;&#xA;&lt;li&gt;「新たなコードのプッシュでDependency Graphが更新された時（例えばpackage.jsonなどのファイルが更新された時と同意かな？）」と「脆弱性データベースであるGitHub Advisory Databaseに脆弱性が登録された時」のタイミングでリポジトリをチェックしてくれる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Dependabot security updates&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Alertsは情報提供で、これはプルリクエスト作成まで行ってくれるサービス&lt;/li&gt;&#xA;&lt;li&gt;「security updates」は脆弱性のパッチを当てたバージョンへあげるもの（「version updates」の方は常に最新バージョンにあげるという違いがある）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;設定ファイルについて&#xA;&lt;ul&gt;&#xA;&lt;li&gt;.github/dependabot.ymlは、security updatesとversion updatesで共有される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;共有されるということは除外ルールを書いたらどちらでも検知されない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;なので防御策として、Alertsを合わせて有効化しておくと良い（Alertsは設定ファイルに依存しない）そうすれば検出漏れを最小限にできる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;シークレットスキャン&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GitHubのシークレットスキャン機能は経済的理由で導入が困難な場合もある&lt;/li&gt;&#xA;&lt;li&gt;SecretlintというDockerで動かせるAWSやGitHubなどの主要サービスのクレデンシャルを検出できる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これをGitHubActionsで動かすと尚良い&lt;/li&gt;&#xA;&lt;li&gt;その際、検出された情報がログ出力されないように注意（&lt;code&gt;--maskSecrets&lt;/code&gt;オプションで設定可能）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;途中からシークレットスキャンを導入する場合は全ヒストリーをスキャンするGitleaksというツールがある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これもDockerで動かせる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;git push前にスキャンするのがベター&#xA;&lt;ul&gt;&#xA;&lt;li&gt;.git/hooks/pre-commitファイルへシークレットスキャンコマンドを組み込むとコミット時にスキャンが実行あsれる&lt;/li&gt;&#xA;&lt;li&gt;個々人で設定可能が必要であり、ストレスに感じる人もいるため、実際にやるかどうかは個人の判断に委ねると良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;アプリケーションスキャン&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Static Application Security Testing(SAST)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コードスキャンしてセキュリティ問題を検出する（静的解析）&lt;/li&gt;&#xA;&lt;li&gt;Goだと&lt;a href=&#34;https://github.com/securego/gosec&#34;&gt;securego/gosec: Go security checker&lt;/a&gt;がそれみたい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;コンテナイメージの脆弱性スキャン&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Trivyというツール&lt;/li&gt;&#xA;&lt;li&gt;他にはコンテナレジストリでスキャン実施できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Infrastructure as Codeセキュリティ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IaCで作業ミスは抑制できるが、セキュリティミスは防げない&lt;/li&gt;&#xA;&lt;li&gt;そしてパッと見で正しく動作しているように見えるので意外と発見が難しい&lt;/li&gt;&#xA;&lt;li&gt;セキュリティ設定ミスの防止&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ここでもTrivyが活躍する&lt;/li&gt;&#xA;&lt;li&gt;万事解決とまでいかないが、優れた出発点となる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Policy as Code&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Conftestというツールが使える&lt;/li&gt;&#xA;&lt;li&gt;ポリシールールを設定ファイルに記述し、それを検証してくれる&lt;/li&gt;&#xA;&lt;li&gt;これもDockerで動かせるのでワークフローに簡単に実行できる&lt;/li&gt;&#xA;&lt;li&gt;選択肢の1つとして持っておくと良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;継続的なセキュリティの改善&#xA;&lt;ul&gt;&#xA;&lt;li&gt;誤検出と検出漏れはどうしても発生する（バランス・トレードオフ）&lt;/li&gt;&#xA;&lt;li&gt;誤検出は想像異常にストレスが大きい&lt;/li&gt;&#xA;&lt;li&gt;またツールを導入しすぎるたりして検出される問題が多すぎるとアラート疲れも発生する&lt;/li&gt;&#xA;&lt;li&gt;時々立ち返って運用を見返すのが良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;18章-継続的デリバリーの実践&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#18%e7%ab%a0-%e7%b6%99%e7%b6%9a%e7%9a%84%e3%83%87%e3%83%aa%e3%83%90%e3%83%aa%e3%83%bc%e3%81%ae%e5%ae%9f%e8%b7%b5&#34;&gt;18章 継続的デリバリーの実践&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;組織パフォーマンスを研究しているGoogleのDORAというチーム曰く「ソフトウェアデリバリーパフォーマンスは組織パフォーマンスと高い相関がある」と学術的な方法で示したこと&lt;/li&gt;&#xA;&lt;li&gt;DORAの研究では「スピードが速い組織ほど品質も高い」を提唱している&lt;/li&gt;&#xA;&lt;li&gt;加えて、個人の幸福や組織文化にも寄与すると考えられている&lt;/li&gt;&#xA;&lt;li&gt;この章では「継続的デリバリー」うまく実践するために、何ができるかを紹介していく&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;バージョン管理戦略&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%83%90%e3%83%bc%e3%82%b8%e3%83%a7%e3%83%b3%e7%ae%a1%e7%90%86%e6%88%a6%e7%95%a5&#34;&gt;バージョン管理戦略&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;継続的デリバリーは適切なバージョン管理から始まる&lt;/li&gt;&#xA;&lt;li&gt;大原則は「ソフトウェアの実行に必要なあらゆるものをバージョン管理する」&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ソースコードだけではなく、テスト・ビルド・デプロイ・データベースマイグレーション・運用などのスクリプト・インフラ設定もバージョン管理の対象（つまりクレデンシャル以外）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;1日に1回はデフォルトブランチにマージする短命なブランチ運用＝トランクベース開発をすることで、コード変更量が小さいのでレビューしやすかったりコンフリクトが発生しづらかったりする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;実装途中の機能を一時的に無効化したい場合は「フィーチャートグル」を使えば良い&lt;/li&gt;&#xA;&lt;li&gt;詳細: &lt;a href=&#34;https://martinfowler.com/articles/feature-toggles.html&#34;&gt;機能トグル（別名機能フラグ）&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;テスト戦略&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%83%86%e3%82%b9%e3%83%88%e6%88%a6%e7%95%a5&#34;&gt;テスト戦略&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CDの品質改善では、4章で説明した自動テストが重要な役割を担う&lt;/li&gt;&#xA;&lt;li&gt;それ以外の異なる観点を提供するものとして、以下の2つがある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;探索的テスト&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e6%8e%a2%e7%b4%a2%e7%9a%84%e3%83%86%e3%82%b9%e3%83%88&#34;&gt;探索的テスト&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;自動化できないテストのこと&lt;/li&gt;&#xA;&lt;li&gt;テストの目的は「調査」と「検証」がある&lt;/li&gt;&#xA;&lt;li&gt;自動テストは記事の問題を「検証「することで、探索的テストは人間が手動で未知の問題を「調査」すること（目的が異なる）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;testing-in-production&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#testing-in-production&#34;&gt;Testing in Production&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リリース後も本番環境でテストする&lt;/li&gt;&#xA;&lt;li&gt;A/Bテストやシンセティックテストなど&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;リリース戦略&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%83%aa%e3%83%aa%e3%83%bc%e3%82%b9%e6%88%a6%e7%95%a5&#34;&gt;リリース戦略&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;恐怖の克服&#xA;&lt;ul&gt;&#xA;&lt;li&gt;いくら自動化しても経験しないと恐怖は薄れない&lt;/li&gt;&#xA;&lt;li&gt;自分の手でリリースすることが大切&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ロールバック&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ロールバックも全員が慣れておく&lt;/li&gt;&#xA;&lt;li&gt;頻度が少ないためにやり方を知らない人がいるので手順を周知し、平時にロールバックの練習をしておく&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;デプロイとリリースの分離&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分離していない場合にデプロイに問題があった時は全ユーザーに影響がある&lt;/li&gt;&#xA;&lt;li&gt;分離する方法として、デプロイ後にユーザートラフィックを少しずつ新しい環境に流す「カナリアリリース」がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;データベースの変更管理&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e3%83%87%e3%83%bc%e3%82%bf%e3%83%99%e3%83%bc%e3%82%b9%e3%81%ae%e5%a4%89%e6%9b%b4%e7%ae%a1%e7%90%86&#34;&gt;データベースの変更管理&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;手作業でデータベースコマンドを実行してはダメ&lt;/li&gt;&#xA;&lt;li&gt;マイグレーションスクリプト経由で実行すると、ヒューマンエラーも発生しない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ロールバック用のスクリプトも用意するようにする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;iacの変更管理&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#iac%e3%81%ae%e5%a4%89%e6%9b%b4%e7%ae%a1%e7%90%86&#34;&gt;IaCの変更管理&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IaCはソフトウェアとライフサイクルが異なるため、固有の考慮点が存在する&lt;/li&gt;&#xA;&lt;li&gt;ツールにドライ欄があるならそれを使用する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;毎回手動実行は大変なので、プルリクエスト作成時に自動で実行し、それをコメントに貼り付ける&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;「本番環境への適用はデフォルトブランチにマージした時のみ」という規律を設けるべき&lt;/li&gt;&#xA;&lt;li&gt;IaCはローカルからの変更は事故が起きやすいので止める&lt;/li&gt;&#xA;&lt;li&gt;実行環境は強力な権限が必要なので、絶対消されてはいけないDB等のリソース削除を禁止したり、権限昇格なIAM操作を禁止すべき&lt;/li&gt;&#xA;&lt;li&gt;構成ドリフト（実態とコードの差分がある状態）は定期的にドライランを実行して通知させよう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;疎結合なアーキテクチャ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/010_github_cicd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/#%e7%96%8e%e7%b5%90%e5%90%88%e3%81%aa%e3%82%a2%e3%83%bc%e3%82%ad%e3%83%86%e3%82%af%e3%83%81%e3%83%a3&#34;&gt;疎結合なアーキテクチャ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;疎結合はCDがとても実践しやすい&lt;/li&gt;&#xA;&lt;li&gt;テストやデプロイの容易性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>AWSクラウドネイティブデザインパターン</title>
      <link>http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/</link>
      <pubDate>Thu, 22 May 2025 22:02:47 +0900</pubDate>
      <guid>http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://direct.gihyo.jp/view/item/000000003465&#34;&gt;AWSクラウドネイティブデザインパターン&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アプリケーション変更頻度と品質は正の相関にある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;変更頻度が低いと品質が低下する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;クラウドネイティブの定義&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クラウドの機能を活用して運用を効率化し、高度な回復力と可観測性を実現する&lt;/li&gt;&#xA;&lt;li&gt;結果として、障害やメンテ・アクセス急増などの日々の運用に工数をかける必要がなく、頻繁に自信を持ってアプリケーションを変更できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;これを実現するためのプラクティスと設計パターンを「運用を効率化」「回復力」「可観測性」の2つの観点から紹介するのが本書である&lt;/li&gt;&#xA;&lt;li&gt;クラウドネイティブを実現するには「疎結合」が重要な概念&#xA;&lt;ul&gt;&#xA;&lt;li&gt;疎結合なアーキテクチャとは「コントロール可能な部品を明確に定義されたインターフェイスで組み合わせるアーキテクチャ」のこと&lt;/li&gt;&#xA;&lt;li&gt;インターフェイスのみ知っておけば、コンポーネント間を繋いでシステムを構築できる&lt;/li&gt;&#xA;&lt;li&gt;これに役立つ技術がコンテナやサーバーレスになる&lt;/li&gt;&#xA;&lt;li&gt;「コントロール可能」とは、望む動作を得られたりするように、管理できているということ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;第1部-運用を効率化する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e7%ac%ac1%e9%83%a8-%e9%81%8b%e7%94%a8%e3%82%92%e5%8a%b9%e7%8e%87%e5%8c%96%e3%81%99%e3%82%8b&#34;&gt;第1部 運用を効率化する&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;1章-責任共有モデルを意識してアーキテクチャを選択する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#1%e7%ab%a0-%e8%b2%ac%e4%bb%bb%e5%85%b1%e6%9c%89%e3%83%a2%e3%83%87%e3%83%ab%e3%82%92%e6%84%8f%e8%ad%98%e3%81%97%e3%81%a6%e3%82%a2%e3%83%bc%e3%82%ad%e3%83%86%e3%82%af%e3%83%81%e3%83%a3%e3%82%92%e9%81%b8%e6%8a%9e%e3%81%99%e3%82%8b&#34;&gt;1章 責任共有モデルを意識してアーキテクチャを選択する&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;責任範囲の最小化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;責任共有モデルを意識して、なるべく多くの運用をクラウドに移譲する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;責任範囲のサポート&#xA;&lt;ul&gt;&#xA;&lt;li&gt;利用者が担う責任をサポートする機能やサービスを使い倒す&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/vpc/latest/reachability/what-is-reachability-analyzer.html&#34;&gt;VPC Reachability Analyzer&lt;/a&gt;でネットワークが目的通り設定されているかの確認が可能&lt;/li&gt;&#xA;&lt;li&gt;AmazonInspectorで不要なネットワークパスが公開されていないかをスキャン&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;一言でまとめると..&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;なるべくできるだけクラウド側に運用を任せられるアーキテクチャを選定しようぜ&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;2章-テスト容易性を高める&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#2%e7%ab%a0-%e3%83%86%e3%82%b9%e3%83%88%e5%ae%b9%e6%98%93%e6%80%a7%e3%82%92%e9%ab%98%e3%82%81%e3%82%8b&#34;&gt;2章 テスト容易性を高める&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;テスト容易性とは、アプリケーションに対してどれだけ簡単に、かつ効果的にテストができるかという性質&lt;/li&gt;&#xA;&lt;li&gt;クラウドネイティブアプリケーションでは、ユニットテストを充実させることが有用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ユニットテストは、自動化が容易で実行が高速だから&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;テストがないコード＝レガシーコードであり、レガシーコードは簡潔にいうと「密結合」なコード&lt;/li&gt;&#xA;&lt;li&gt;とは言っても、テストがあれば良いのかというとそうでもなく、「高い信頼性」と「開発者主体で作成されていること」が効果的である&#xA;&lt;ul&gt;&#xA;&lt;li&gt;テストの信頼性とは？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通ればリリースできるし、通らなければリリースできない&lt;/li&gt;&#xA;&lt;li&gt;同じテストなのに実行するたびに変わるのは、偽陽性が多くなり、開発デリバリーに悪影響&lt;/li&gt;&#xA;&lt;li&gt;こうした問題には、依存関係を整理してユニットテストの比重を増やすのももちろん、そもそもそう言ったテストを削除してしまうのも良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;開発者主体で作成された自動テストとは？&lt;/li&gt;&#xA;&lt;li&gt;外部に発注したテストもデリバリーに良い効果を齎せない&lt;/li&gt;&#xA;&lt;li&gt;開発者主体で行うからこそ、疎結合に作り、パフォーマンス向上が見込める&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;テストピラミッドとcicd&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%83%86%e3%82%b9%e3%83%88%e3%83%94%e3%83%a9%e3%83%9f%e3%83%83%e3%83%89%e3%81%a8cicd&#34;&gt;テストピラミッドとCI/CD&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;「開発者に素早くフィードバックを返す環境が重要」という観点から有名な考え方がテストピラミッド&#xA;&lt;ul&gt;&#xA;&lt;li&gt;テスト戦略全体において、大部分（70％くらい）をユニットテストが占めるべきというもの&lt;/li&gt;&#xA;&lt;li&gt;ユニットテストは低コストで自動化が容易と定義されている&lt;/li&gt;&#xA;&lt;li&gt;詳細：&lt;a href=&#34;https://gihyo.jp/dev/serial/01/savanna-letter/0005&#34;&gt;第5回 テストピラミッド～自動テストの信頼性を中長期的に保つ最適なバランス～&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CI/CDの原則は、各ステージで失敗したらすぐに開発を止めて、原因を突き止め、修正すべきとされている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;テストピラミッドが崩れている（ユニットテストが少ないとか）とこの原則が形骸しがちなので注意&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;一言でまとめると..&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;とりあえずユニットテストを書いて自動化して、CI/CDパイプラインで検知しようぜ&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;テスト容易性を高めるアーキテクチャパターン&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%83%86%e3%82%b9%e3%83%88%e5%ae%b9%e6%98%93%e6%80%a7%e3%82%92%e9%ab%98%e3%82%81%e3%82%8b%e3%82%a2%e3%83%bc%e3%82%ad%e3%83%86%e3%82%af%e3%83%81%e3%83%a3%e3%83%91%e3%82%bf%e3%83%bc%e3%83%b3&#34;&gt;テスト容易性を高めるアーキテクチャパターン&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;依存関係の逆転&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e4%be%9d%e5%ad%98%e9%96%a2%e4%bf%82%e3%81%ae%e9%80%86%e8%bb%a2&#34;&gt;依存関係の逆転&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えば、イベント作成メソッドの内部に「メールで通知する」という実装が含まれている例&#xA;&lt;ul&gt;&#xA;&lt;li&gt;このメソッドのユニットテストを書こうとすると、メールで通知するという外部に依存する処理を書く必要がある&lt;/li&gt;&#xA;&lt;li&gt;そこで、通知を送るというインターフェイスを用意して、インターフェイスという抽象に依存させることで、ユニットテストではこの部分をモック化するだけで良くなるので、テストがしやすくなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;このように依存の向きを呼び出しの向きを逆にする＝イベント作成サービス側がインターフェイスを定義して、そのインターフェイスにメール送信処理が依存すること&lt;/li&gt;&#xA;&lt;li&gt;この原則は、上位と下位のレイヤ構造になっている依存関係全般に適用できる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;特に、メールや外部API、SaaSなど、アプリケーションで直接制御していない外部との連携部分で利用すると有用である&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;コンテナによる依存関係の注入&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e3%81%ab%e3%82%88%e3%82%8b%e4%be%9d%e5%ad%98%e9%96%a2%e4%bf%82%e3%81%ae%e6%b3%a8%e5%85%a5&#34;&gt;コンテナによる依存関係の注入&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dockerを使用してデータベース等の環境を立ち上げてそこでテストする&lt;/li&gt;&#xA;&lt;li&gt;Testcontainersでテストコードから、コンテナを起動可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;コマンドとクエリの分離cqs&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%82%b3%e3%83%9e%e3%83%b3%e3%83%89%e3%81%a8%e3%82%af%e3%82%a8%e3%83%aa%e3%81%ae%e5%88%86%e9%9b%a2cqs&#34;&gt;コマンドとクエリの分離(CQS)&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コードのメソッドをコマンドとクエリのどちらかに分離すべきという原則&lt;/li&gt;&#xA;&lt;li&gt;副作用が発生するコードを局所化し、テストの容易性を向上できる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ユニットテストで何をテストすべきか明確になるため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;コマンドとクエリの責任分離cqrs&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%82%b3%e3%83%9e%e3%83%b3%e3%83%89%e3%81%a8%e3%82%af%e3%82%a8%e3%83%aa%e3%81%ae%e8%b2%ac%e4%bb%bb%e5%88%86%e9%9b%a2cqrs&#34;&gt;コマンドとクエリの責任分離(CQRS)&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;CQSを発展させたもので、コマンドの責務を持つクラスとクエリの責務を持つクラスを分離するデザインパターン&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;例えば、ユーザーがどのチケットを買い、どのイベントに参加したか等のアクティビティをレポートする機能があるとする&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;シンプルに実装した場合、レポート機能メソッドで様々なクラスを呼び出して情報を集めることになる&lt;/li&gt;&#xA;&lt;li&gt;こうなると多くのクラスに依存し、テストが容易ではない&lt;/li&gt;&#xA;&lt;li&gt;ここでアクティビティを取得するクラスにクエリの責務を分離する(CQRS)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;その中で実際のクエリを直接書くようにする&lt;/li&gt;&#xA;&lt;li&gt;UserActivityRepositoryみたいなイメージ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;結果として、アクティビティの依存関係がシンプルになり、テストが容易になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;この章を一言にまとめると..&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;とりあえず疎結合に作って、ユニットテストしやすいようにDIとCQR(S)を意識し、CI/CDパイプラインをきちんと整備しよう&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;3章-小規模かつ可逆的な変更を頻繁に行う&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#3%e7%ab%a0-%e5%b0%8f%e8%a6%8f%e6%a8%a1%e3%81%8b%e3%81%a4%e5%8f%af%e9%80%86%e7%9a%84%e3%81%aa%e5%a4%89%e6%9b%b4%e3%82%92%e9%a0%bb%e7%b9%81%e3%81%ab%e8%a1%8c%e3%81%86&#34;&gt;3章 小規模かつ可逆的な変更を頻繁に行う&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クラウドネイティブなアプリケーションでは、様々な変更を、頻繁に、自信を持って行うことができる&lt;/li&gt;&#xA;&lt;li&gt;そのため小規模かつ可逆的な変更を積み重ねることが重要&#xA;&lt;ul&gt;&#xA;&lt;li&gt;いつでもロールバックできる小さな変更であれば頻繁に、自信を持って行うことができるだろう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;継続的インテグレーション&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e7%b6%99%e7%b6%9a%e7%9a%84%e3%82%a4%e3%83%b3%e3%83%86%e3%82%b0%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3&#34;&gt;継続的インテグレーション&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CI/CDの目的は、&lt;strong&gt;開発に集中できる状況を作る&lt;/strong&gt;こと&lt;/li&gt;&#xA;&lt;li&gt;ブランチ戦略の話&#xA;&lt;ul&gt;&#xA;&lt;li&gt;継続的にインテグレーションされた状態を維持するには、長命なブランチを最小限に抑える必要がある&lt;/li&gt;&#xA;&lt;li&gt;例えば、開発環境ブランチ・本番環境用ブランチのように、いくつも長命なブランチが増えると、リリースのプロセスは複雑になり、それぞれのコードベースのマージにかかる不具合や工数も増えてしまう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;トランクベース開発&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%83%88%e3%83%a9%e3%83%b3%e3%82%af%e3%83%99%e3%83%bc%e3%82%b9%e9%96%8b%e7%99%ba&#34;&gt;トランクベース開発&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;上記の考え方に沿って、長命なブランチ＝トランクを1つに限定する開発手法がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全ての開発をトランク上で行い、ブランチの利用は短命のものにする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;クラウドネイティブにおける「小規模かつ可逆的な変更を頻繁に行う」ためには、必須と言って良いほど重要(そもそも前提みたいなもの)&lt;/li&gt;&#xA;&lt;li&gt;長命なブランチを多く活用することで、継続的インテグレーションが難しくなる理由&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リリースの安全性が損なわれる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;長命ブランチが増えれば増えるほどマージにかかる工数やコンフリクトへの対処が発生する&lt;/li&gt;&#xA;&lt;li&gt;また、Aブランチで改修したHoge関数を、Bブランチが改修前の状態のHoge関数を実行する箇所を追加したみたいな例だと不整合も発生する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;リファクタリングが難しくなり、技術負債が積み上がる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リファクタリングすることにより、不整合が発生するということは、心理的にリファクタリングをしたくなる環境ではなくなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;継続的インテグレーションに必要なプラクティス&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e7%b6%99%e7%b6%9a%e7%9a%84%e3%82%a4%e3%83%b3%e3%83%86%e3%82%b0%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%ab%e5%bf%85%e8%a6%81%e3%81%aa%e3%83%97%e3%83%a9%e3%82%af%e3%83%86%e3%82%a3%e3%82%b9&#34;&gt;継続的インテグレーションに必要なプラクティス&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;トランクベース開発は非常に重要ではあるが、実際に導入するには以下のようなプラクティスが必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;1信頼できる高速な自動テスト&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#1%e4%bf%a1%e9%a0%bc%e3%81%a7%e3%81%8d%e3%82%8b%e9%ab%98%e9%80%9f%e3%81%aa%e8%87%aa%e5%8b%95%e3%83%86%e3%82%b9%e3%83%88&#34;&gt;1.信頼できる高速な自動テスト&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;継続的インテグレーションの重要なプラクティスに「検証が失敗したら即開発を止めて修正する」というものがある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;「常に動く状態を保ち続ける」のが原則であるため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ただ、トランクベースの開発ではない場合、デプロイされる直前までビルドエラーとかが放置されがち&lt;/li&gt;&#xA;&lt;li&gt;一方、トランクベースの開発の場合は、ある程度これが強制される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;チェックインしたコードがすぐにデプロイされたり、他の開発者に共有されたりするので、壊れたビルドの影響範囲が大きいため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;また、毎度トランクにコードをマージする時に長いプロセスは実行できないので「高速」であることも大事&lt;/li&gt;&#xA;&lt;li&gt;テストの高速化と信頼性向上のための具体的なプラクティス&#xA;&lt;ul&gt;&#xA;&lt;li&gt;マニュアルテストや結合テストを減らし、ユニットテストの割合を増やす&lt;/li&gt;&#xA;&lt;li&gt;ユニットテストが外部に依存しているようならモックに置き換える&lt;/li&gt;&#xA;&lt;li&gt;開発者が手元の環境で気軽に検証できるようにする&lt;/li&gt;&#xA;&lt;li&gt;テスト実行する環境を、実行の度に新しい環境(コンテナ)を利用する（並列実行を可能にする）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;2小さいチャンクでの機能開発&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#2%e5%b0%8f%e3%81%95%e3%81%84%e3%83%81%e3%83%a3%e3%83%b3%e3%82%af%e3%81%a7%e3%81%ae%e6%a9%9f%e8%83%bd%e9%96%8b%e7%99%ba&#34;&gt;2.小さいチャンクでの機能開発&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;トランクベースの開発では、個々の変更の独立性も重要&#xA;&lt;ul&gt;&#xA;&lt;li&gt;別のブランチでの改修が依存関係にあると、トランクの頻繁な更新ができなくなってしまう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;この観点で参考にできるのが「INVEST」という考え方&#xA;&lt;ul&gt;&#xA;&lt;li&gt;良いプロダクトバックログアイテム(PBI)を作るための基準になるもの&lt;/li&gt;&#xA;&lt;li&gt;小さく、独立性があり、テスト可能であることが大事&lt;/li&gt;&#xA;&lt;li&gt;小さな単位でコード変更を行い、リリースできる状態を保ちながらマージを続ける&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;3デプロイとリリースの分離&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#3%e3%83%87%e3%83%97%e3%83%ad%e3%82%a4%e3%81%a8%e3%83%aa%e3%83%aa%e3%83%bc%e3%82%b9%e3%81%ae%e5%88%86%e9%9b%a2&#34;&gt;3.デプロイとリリースの分離&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;いつ、どのようにリリースするかというのは複雑な要件が入り乱れていることがある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プレスリリースやベータ版とか&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;この時にコードがマージされたらすぐにリリースされるのを避けるため、featureブランチにコードを退避したりする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;この状態は健全ではない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;複雑なリリース要件を満たしながら、継続的インテグレーションを実施するには、デプロイとリリースを分離する必要がある&lt;/li&gt;&#xA;&lt;li&gt;そこで利用される技術が「Continuous Configuration(CC)」になる&lt;/li&gt;&#xA;&lt;li&gt;Continuous Configuration(CC)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;機能フラグを用いて、リリースしたいコードを制御する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;リリースブランチ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;メインのブランチが高品質に保たれていても、実際のリリースプロセスに時間を要することがある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例：専任チームによる検証が必須とか&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;リリースブランチを導入することで、継続的インテグレーションを導入しつつ、リリースの安定化のための時間を確保できる&lt;/li&gt;&#xA;&lt;li&gt;開発チームはトランクベースで開発しつつ、リリースプロセスはリリースブランチで運用するイメージ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;継続的デリバリー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;そもそも継続的デリバリーとは？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コード変更が発生すると、自動的に実稼働環境へのリリース準備が実行されるもの&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;これを実現するためには、トランクベース開発と継続的インテグレーションを前提にコードベースを信頼できる状態に保ち、デプロイを安全に行えるようにする必要がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;ここまで一言でまとめると&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%81%93%e3%81%93%e3%81%be%e3%81%a7%e4%b8%80%e8%a8%80%e3%81%a7%e3%81%be%e3%81%a8%e3%82%81%e3%82%8b%e3%81%a8&#34;&gt;ここまで一言でまとめると..&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;トランクベースで小さく開発を進め、ユニットテストを充実＆高速化＆自動化し、CI/CDパイプラインを構築(活用)して、分離されたデプロイ＆リリースプロセスを高速に回していこう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;小規模かつ可逆的な変更を頻繁に行うためのアーキテクチャパターン&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e5%b0%8f%e8%a6%8f%e6%a8%a1%e3%81%8b%e3%81%a4%e5%8f%af%e9%80%86%e7%9a%84%e3%81%aa%e5%a4%89%e6%9b%b4%e3%82%92%e9%a0%bb%e7%b9%81%e3%81%ab%e8%a1%8c%e3%81%86%e3%81%9f%e3%82%81%e3%81%ae%e3%82%a2%e3%83%bc%e3%82%ad%e3%83%86%e3%82%af%e3%83%81%e3%83%a3%e3%83%91%e3%82%bf%e3%83%bc%e3%83%b3&#34;&gt;小規模かつ可逆的な変更を頻繁に行うためのアーキテクチャパターン&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;continuous-configurationccによるリリース管理&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#continuous-configurationcc%e3%81%ab%e3%82%88%e3%82%8b%e3%83%aa%e3%83%aa%e3%83%bc%e3%82%b9%e7%ae%a1%e7%90%86&#34;&gt;Continuous Configuration(CC)によるリリース管理&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Amazonのプライムデーでは、開催と同時にコードを変更しているわけではなく、AppConfigを用いて動的にアプリケーションの挙動を変更している&lt;/li&gt;&#xA;&lt;li&gt;AppConfigを利用すると、機能フラグの動的な設定を実現できる&lt;/li&gt;&#xA;&lt;li&gt;AppConfigの仕組み&#xA;&lt;ul&gt;&#xA;&lt;li&gt;公式のエージェントが用意されている&lt;/li&gt;&#xA;&lt;li&gt;それをアプリケーションサーバーに導入する&lt;/li&gt;&#xA;&lt;li&gt;キャッシュやポーリング間隔を設定する&lt;/li&gt;&#xA;&lt;li&gt;アプリケーションからは、ローカルで動いているエージェントから値を取得するだけ(なのでパフォーマンスにも影響なさそう)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;少しずつデプロイするクライアントを増やしていくなどのデプロイ戦略も可能&lt;/li&gt;&#xA;&lt;li&gt;ただし、機能フラグはロジックに余計なif文が混ざり可読性を落としてしまうのと、フラグの誤操作により障害発生などのリスクもある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;なので、短期的なフラグとしてマーク（コードコメント等）して、定期的にクリーンアップするのが大事&lt;/li&gt;&#xA;&lt;li&gt;機能フラグを追加した時点で、削除するというバックログも追加するなどの工夫をする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;抽象化によるブランチ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e6%8a%bd%e8%b1%a1%e5%8c%96%e3%81%ab%e3%82%88%e3%82%8b%e3%83%96%e3%83%a9%e3%83%b3%e3%83%81&#34;&gt;抽象化によるブランチ&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;機能フラグと同様に、時間のかかる変更を小さなチャンクで実施する技法の1つ&lt;/li&gt;&#xA;&lt;li&gt;機能フラグは新規機能等では有用であるが、例えばORマッパを変更したいなどの既存機能に大きく影響する箇所はどうすれば良いか&lt;/li&gt;&#xA;&lt;li&gt;そこで活躍するのが「抽象化によるブランチ」にある&lt;/li&gt;&#xA;&lt;li&gt;例えば、メール送信機能を同期処理からSQS*Lambdaの非同期処理にしたいケース&#xA;&lt;ul&gt;&#xA;&lt;li&gt;実装を特定し、&lt;/li&gt;&#xA;&lt;li&gt;その実装を含む抽象化レイヤを作成する&lt;/li&gt;&#xA;&lt;li&gt;既存実装を抽象化レイヤの呼び出しに変更する&lt;/li&gt;&#xA;&lt;li&gt;抽象化レイヤで機能フラグを用いて、一部を新しい実装に切り替える&lt;/li&gt;&#xA;&lt;li&gt;これを完全に置き換えるまで少しづつ続ける&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;つまり、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;呼び出し側は抽象化されたインターフェイスを呼び出すだけ&lt;/li&gt;&#xA;&lt;li&gt;そのインターフェイスの実装側で機能フラグにより新旧処理を呼び分ける&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;このパターンはステップが多く開発オーバーヘッドがかかるので、呼び出し箇所が多いPRマッパの変更や基盤技術の変更等で有用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;4章-セキュリティを作り込む&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#4%e7%ab%a0-%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3%e3%82%92%e4%bd%9c%e3%82%8a%e8%be%bc%e3%82%80&#34;&gt;4章 セキュリティを作り込む&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;責任共有モデルとセキュリティ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e8%b2%ac%e4%bb%bb%e5%85%b1%e6%9c%89%e3%83%a2%e3%83%87%e3%83%ab%e3%81%a8%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3&#34;&gt;責任共有モデルとセキュリティ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;セキュリティにおいても、最も重要なことは責任共有モデルを意識すること&lt;/li&gt;&#xA;&lt;li&gt;なるべくクラウド提供者の責任範囲を大きくするようにアーキテクチャを選択することで、セキュリティ対策にかける時間とコストを抑えることが重要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;疎結合なアプリケーションのセキュリティ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e7%96%8e%e7%b5%90%e5%90%88%e3%81%aa%e3%82%a2%e3%83%97%e3%83%aa%e3%82%b1%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%ae%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3&#34;&gt;疎結合なアプリケーションのセキュリティ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンポーネントの中のセキュリティを考え、そしてコンポーネント間のセキュリティ（どのようなデータが送受信され、どのような権限が設定されているか）を考える&lt;/li&gt;&#xA;&lt;li&gt;LambdaとSQSを用いたイベント駆動アプリケーションの例&#xA;&lt;ul&gt;&#xA;&lt;li&gt;それぞれのリソースにアクセスできるリソースを権限で絞る&lt;/li&gt;&#xA;&lt;li&gt;Lambda関数のコードをセキュリティを考える&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Amazon Inspectorで脆弱性がないかスキャンしたり、コードに署名することで改竄されていないことを保証したりできる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;全体を俯瞰しながら、どの部分にどのようなセキュリティ対策が必要かを体系的に実施できるのが「脅威モデリング」と呼ばれる手法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;脅威モデリング&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e8%84%85%e5%a8%81%e3%83%a2%e3%83%87%e3%83%aa%e3%83%b3%e3%82%b0&#34;&gt;脅威モデリング&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;対象のシステムにどのような悪いことが起き、どのように対処すべきを明確にするための構造化された手法&lt;/li&gt;&#xA;&lt;li&gt;AWSでは、脅威モデリングの実施を、セキュリティに関するベストプラクティスの1つとして紹介している&lt;/li&gt;&#xA;&lt;li&gt;実施頻度&#xA;&lt;ul&gt;&#xA;&lt;li&gt;新規の設計や既存の設計変更など定期的に&lt;/li&gt;&#xA;&lt;li&gt;設計段階から、セキュリティ上の課題を特定できるのが大きなメリット&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;5章-devopsとプラットフォームエンジニアリング&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#5%e7%ab%a0-devops%e3%81%a8%e3%83%97%e3%83%a9%e3%83%83%e3%83%88%e3%83%95%e3%82%a9%e3%83%bc%e3%83%a0%e3%82%a8%e3%83%b3%e3%82%b8%e3%83%8b%e3%82%a2%e3%83%aa%e3%83%b3%e3%82%b0&#34;&gt;5章 DevOpsとプラットフォームエンジニアリング&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DevOpsは、開発チームと運用チームが責任を共有しコラボレーションできる文化&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;クラウドネイティブなチームモデル&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%82%af%e3%83%a9%e3%82%a6%e3%83%89%e3%83%8d%e3%82%a4%e3%83%86%e3%82%a3%e3%83%96%e3%81%aa%e3%83%81%e3%83%bc%e3%83%a0%e3%83%a2%e3%83%87%e3%83%ab&#34;&gt;クラウドネイティブなチームモデル&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クラウドネイティブな開発で求められるチーム&#xA;&lt;ul&gt;&#xA;&lt;li&gt;価値のあるサービスの設計〜開発〜デプロイ〜運用まで関わるビジネスのドメインに関わるチーム&lt;/li&gt;&#xA;&lt;li&gt;そのチームの負荷を軽減するためのチーム&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;(個人メモ)よくプロダクト開発チームとプラットフォーム/イネイブルチームみたいな構成があるが、これがそれを体現しているもの&#xA;&lt;ul&gt;&#xA;&lt;li&gt;このチーム構成で運用している開発組織はDevOpsを意識している（できているかはともかく）と理解できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;第2部-回復力を高める&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e7%ac%ac2%e9%83%a8-%e5%9b%9e%e5%be%a9%e5%8a%9b%e3%82%92%e9%ab%98%e3%82%81%e3%82%8b&#34;&gt;第2部 回復力を高める&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;6章-スケーラブルなアーキテクチャを実装する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#6%e7%ab%a0-%e3%82%b9%e3%82%b1%e3%83%bc%e3%83%a9%e3%83%96%e3%83%ab%e3%81%aa%e3%82%a2%e3%83%bc%e3%82%ad%e3%83%86%e3%82%af%e3%83%81%e3%83%a3%e3%82%92%e5%ae%9f%e8%a3%85%e3%81%99%e3%82%8b&#34;&gt;6章 スケーラブルなアーキテクチャを実装する&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;オートスケーリングを前提としたアプリケーション構造&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%82%aa%e3%83%bc%e3%83%88%e3%82%b9%e3%82%b1%e3%83%bc%e3%83%aa%e3%83%b3%e3%82%b0%e3%82%92%e5%89%8d%e6%8f%90%e3%81%a8%e3%81%97%e3%81%9f%e3%82%a2%e3%83%97%e3%83%aa%e3%82%b1%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%e6%a7%8b%e9%80%a0&#34;&gt;オートスケーリングを前提としたアプリケーション構造&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバーに依存しないセッション管理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;スティッキーセッションという解決法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ユーザーは常に同じサーバーにルーティングされるので、負荷分散できず微妙&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ここで出るのがデータストアでのセッション管理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;データベースの負荷をコントロールする&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%83%87%e3%83%bc%e3%82%bf%e3%83%99%e3%83%bc%e3%82%b9%e3%81%ae%e8%b2%a0%e8%8d%b7%e3%82%92%e3%82%b3%e3%83%b3%e3%83%88%e3%83%ad%e3%83%bc%e3%83%ab%e3%81%99%e3%82%8b&#34;&gt;データベースの負荷をコントロールする&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;オートスケーリングを行う場合に気をつけるべきなのがデータベースへの負荷のコントロール&lt;/li&gt;&#xA;&lt;li&gt;RDBMSを利用する場合は、リソースを有効活用するためにコネクションプーリングを使用する&lt;/li&gt;&#xA;&lt;li&gt;コネクションプーリングには、大きく分けて以下の2種類がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JDBCのようなローカル変数を使ったドライバ形式&lt;/li&gt;&#xA;&lt;li&gt;Pgpoolのようなプロキシ形式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;多くのアプリケーションでは言語フレームワークとセットでドライバ形式を利用することが多いと思われる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;使い分けとしては、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;EC2のようなオートスケールを能動的に指定する場合：ドライバ型（コネクション数を計算がしやすく、管理の見落としが少ない）&lt;/li&gt;&#xA;&lt;li&gt;Lambdaのような負荷に応じて自動でリソースがスケールする場合：プロキシ形式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ドライバ型は環境変数を使用するため、意図せずRDBMS側の消費してしまうリスクが発生する&lt;/li&gt;&#xA;&lt;li&gt;このようなリスクを低減するため、Lambdaとデータベースの間にプロキシ形式のコネクションプール層を設けると良い(RDS Proxyとか)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;他にオートスケーリングするアプリケーションでデータベース側の負荷を低減する方法としては、リードレプリカの活用がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;読み取り処理をリードレプリカに向けることで、プライマリへの負荷を低減できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;アプリケーションを適切に分解する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%82%a2%e3%83%97%e3%83%aa%e3%82%b1%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%e3%82%92%e9%81%a9%e5%88%87%e3%81%ab%e5%88%86%e8%a7%a3%e3%81%99%e3%82%8b&#34;&gt;アプリケーションを適切に分解する&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;モノリス構造だと、1つのアプリケーションとして複数の機能が提供されており、負荷が上がりスケールアウトした時に、全体では通常通りの性能に見えても、特定の機能の性能が劣化しているということがある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;このような事態になったときに、アプリケーションの分割を検討する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;アプリケーションを分割すると、オートスケールによる性能向上もピンポイントで行える&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一方、分割することで管理コストが上がったり、整合性担保が難しくなるケースもあるので、むやみやたらに分割することは推奨しない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;スケールインにおいて考慮すること&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%82%b9%e3%82%b1%e3%83%bc%e3%83%ab%e3%82%a4%e3%83%b3%e3%81%ab%e3%81%8a%e3%81%84%e3%81%a6%e8%80%83%e6%85%ae%e3%81%99%e3%82%8b%e3%81%93%e3%81%a8&#34;&gt;スケールインにおいて考慮すること&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;増やした台数を減らすスケールインも重要&lt;/li&gt;&#xA;&lt;li&gt;アプリケーションがステートレスで作られていれば、スケールインは容易&lt;/li&gt;&#xA;&lt;li&gt;ただし、処理の途中経過やセッションをサーバー内で保持していると、処理の中断を防ぐため以下のような仕組みを用いて、データ待避や保存が必要になる&#xA;&lt;ol&gt;&#xA;&lt;li&gt;終了ポリシー&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;スケールイン時に終了するインスタンスをどのような基準で選ぶかを定義する&lt;/li&gt;&#xA;&lt;li&gt;最も古い/新しい/低負荷なインスタンスを終了するというようなルールを設定する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWS Auto Scalingでは、OldestInstanceポリシー等が用意されている&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/autoscaling/ec2/userguide/ec2-auto-scaling-termination-policies.html&#34;&gt;Amazon EC2 Auto Scaling の終了ポリシーを設定する - Amazon EC2 Auto Scaling&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;スケールイン保護&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;処理が動いているサーバーを停止しない仕組み&lt;/li&gt;&#xA;&lt;li&gt;何らかのメトリクス(例:CPU使用率やカスタムメトリクス（例: 処理中ジョブ数）)をもとにスケールインイベントを設定した際、閾値を下回ると自動的にリソースを停止する&lt;/li&gt;&#xA;&lt;li&gt;ECSにもそのような仕組みがあるみたい&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/jp/blogs/news/announcing-amazon-ecs-task-scale-in-protection/&#34;&gt;Amazon ECS タスクのスケールイン保護の発表 | Amazon Web Services ブログ&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;終了ライフサイクルフック&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;インスタンス開始・終了時にプログラムなどを起動する仕組み&lt;/li&gt;&#xA;&lt;li&gt;これをトリガーにして、稼働中のプログラムに終了処理を行わせることが可能&lt;/li&gt;&#xA;&lt;li&gt;例えば、セッションデータやログをS3などの外部に保存するようにしたり、メッセージキューに通知したり、ロードバランサーからの登録を解除したり..&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;非同期アーキテクチャによるスケーラビリティ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e9%9d%9e%e5%90%8c%e6%9c%9f%e3%82%a2%e3%83%bc%e3%82%ad%e3%83%86%e3%82%af%e3%83%81%e3%83%a3%e3%81%ab%e3%82%88%e3%82%8b%e3%82%b9%e3%82%b1%e3%83%bc%e3%83%a9%e3%83%93%e3%83%aa%e3%83%86%e3%82%a3&#34;&gt;非同期アーキテクチャによるスケーラビリティ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;スケーリングの仕組みを活かすのに非同期処理を前提にするというのも選択肢になる&lt;/li&gt;&#xA;&lt;li&gt;同期処理だと、負荷上昇時に滞留が増えてしまう&lt;/li&gt;&#xA;&lt;li&gt;同期処理が必須ではない部分は、非同期処理の活用がおすすめ&lt;/li&gt;&#xA;&lt;li&gt;受付と処理を分離できるので、ユーザーに対する応答性及び処理能力の改善が見込まれる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;非同期処理の実装方法を4つ紹介する&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;非同期処理実装パターン1-キューsqs&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e9%9d%9e%e5%90%8c%e6%9c%9f%e5%87%a6%e7%90%86%e5%ae%9f%e8%a3%85%e3%83%91%e3%82%bf%e3%83%bc%e3%83%b31-%e3%82%ad%e3%83%a5%e3%83%bcsqs&#34;&gt;非同期処理実装パターン1: キュー(SQS)&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一時的にメッセージを格納する軽量バッファと接続エンドポイントを提供することで、メッセージの送信側(プロデューサー)と受信側(コンシューマ)を分離する&lt;/li&gt;&#xA;&lt;li&gt;受信側のタイミングでキューを取りに行き処理する「Pull型」のアプローチとなる&lt;/li&gt;&#xA;&lt;li&gt;1対1&lt;/li&gt;&#xA;&lt;li&gt;メッセージは1回処理される&lt;/li&gt;&#xA;&lt;li&gt;ユースケース&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ジョブキュー: バッチ処理や画像変換タスク&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例:ジョブをキューに貯めて、x分間に1度バッチ処理を行う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;支払い処理システムのトランザクション処理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;非同期処理実装パターン2-トピックsns&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e9%9d%9e%e5%90%8c%e6%9c%9f%e5%87%a6%e7%90%86%e5%ae%9f%e8%a3%85%e3%83%91%e3%82%bf%e3%83%bc%e3%83%b32-%e3%83%88%e3%83%94%e3%83%83%e3%82%afsns&#34;&gt;非同期処理実装パターン2: トピック(SNS)&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通信チャネルとして機能する論理アクセスポイントを提供することで、送信側(Publisher)からのメッセージを登録(Subscribe)する複数の受信者に発行する「pub/subメッセージング」を主体とした考え方&lt;/li&gt;&#xA;&lt;li&gt;キューと違い、発行されたメッセージが受信側に届く「Push型」のアプローチ&lt;/li&gt;&#xA;&lt;li&gt;1対多&lt;/li&gt;&#xA;&lt;li&gt;Subscriberごとにメッセージが複製される&lt;/li&gt;&#xA;&lt;li&gt;ユースケース&#xA;&lt;ul&gt;&#xA;&lt;li&gt;マイクロサービス間の通知配信&lt;/li&gt;&#xA;&lt;li&gt;システム監視アラート&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;非同期処理実装パターン3-ストリームamazon-kinesis-data-stream&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e9%9d%9e%e5%90%8c%e6%9c%9f%e5%87%a6%e7%90%86%e5%ae%9f%e8%a3%85%e3%83%91%e3%82%bf%e3%83%bc%e3%83%b33-%e3%82%b9%e3%83%88%e3%83%aa%e3%83%bc%e3%83%a0amazon-kinesis-data-stream&#34;&gt;非同期処理実装パターン3: ストリーム(Amazon Kinesis Data Stream)&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ストリームは、データソースによって継続的に生成されるデータを低レイテンシーに取り扱うための考え方&lt;/li&gt;&#xA;&lt;li&gt;以下の2つのレイヤで構成される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;レコードの並び替えや高速な読み書き、整合性をサポートするストレージレイヤ&lt;/li&gt;&#xA;&lt;li&gt;そのデータを計算し不要になったデータを削除する処理レイヤ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;1対多&lt;/li&gt;&#xA;&lt;li&gt;ユースケース&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リアルタイムログ処理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アクセスログ分析&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;データパイプライン構築&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ETL処理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;非同期処理実装パターン4-イベントバスeventbridge&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e9%9d%9e%e5%90%8c%e6%9c%9f%e5%87%a6%e7%90%86%e5%ae%9f%e8%a3%85%e3%83%91%e3%82%bf%e3%83%bc%e3%83%b34-%e3%82%a4%e3%83%99%e3%83%b3%e3%83%88%e3%83%90%e3%82%b9eventbridge&#34;&gt;非同期処理実装パターン4: イベントバス(EventBridge)&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;イベントバスは、キューやトピックを使った応用的な手法。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;送信側からのイベントやメッセージを受信するパイプラインにより、事前に定義されたルール条件に一致するかチェックし、該当する受信者にルーティングする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;イベント駆動型アーキテクチャの中核となる&lt;/li&gt;&#xA;&lt;li&gt;フィルタリングやルーティングの柔軟性が高い&lt;/li&gt;&#xA;&lt;li&gt;ユースケース&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバレスアプリケーションでのイベント連携&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Lambdaのトリガー&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CloudWatchからEventBridgeでイベントを受信し、ルールに基づいてLambda等に転送する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;非同期処理のポイント&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e9%9d%9e%e5%90%8c%e6%9c%9f%e5%87%a6%e7%90%86%e3%81%ae%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88&#34;&gt;非同期処理のポイント&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;チケット購入手続き処理における、完了後のメール送信などを非同期にする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;メール配信に処理や障害が発生しても、購入自体は影響受けずに業務を続けられる&lt;/li&gt;&#xA;&lt;li&gt;加えて、非同期処理にキューを使うことで、後続の処理をスケールアウトしやすくなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;非同期処理での整合性担保&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e9%9d%9e%e5%90%8c%e6%9c%9f%e5%87%a6%e7%90%86%e3%81%a7%e3%81%ae%e6%95%b4%e5%90%88%e6%80%a7%e6%8b%85%e4%bf%9d&#34;&gt;非同期処理での整合性担保&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;非同期処理には、障害や遅延の極小化やスケーリングの観点でメリットがある一方、しばしば整合性における課題が挙げられる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;上で書いた例だと、購入はできたけど、購入完了メールが配信されないみたいなケース&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;非同期処理システムでは「結果整合性」という考え方が重要になる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一時的には不整合が発生しても、最終的には一貫性のある状態になるということ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;制限をコントロールする&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e5%88%b6%e9%99%90%e3%82%92%e3%82%b3%e3%83%b3%e3%83%88%e3%83%ad%e3%83%bc%e3%83%ab%e3%81%99%e3%82%8b&#34;&gt;制限をコントロールする&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;いくらリソースをスケーリングできるといっても予算は有限だし、意図しないリソース消費も避けなければいけない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;クォータ管理を自動化する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%82%af%e3%82%a9%e3%83%bc%e3%82%bf%e7%ae%a1%e7%90%86%e3%82%92%e8%87%aa%e5%8b%95%e5%8c%96%e3%81%99%e3%82%8b&#34;&gt;クォータ管理を自動化する&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWSアカウントには、AWSのサービスごとにデフォルトの「クォータ」というリソース作成上限がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;特定の利用者が大量にリソースを使うことを防いで全体の可用性を保証することと、利用者が意図せず大量リソースを使うことを防止する意図がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;一部のクォータに関してはAWS Service Quotasというサービスで管理可能&lt;/li&gt;&#xA;&lt;li&gt;クォータの上限に近づいているかは、AWS Trusted Advisorでも確認可能&lt;/li&gt;&#xA;&lt;li&gt;設計や定期的に確認することも大事だが、↑のサービスを利用し、自動化の仕組みを取り入れることもできる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;アプリケーションの流量制限&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%82%a2%e3%83%97%e3%83%aa%e3%82%b1%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%ae%e6%b5%81%e9%87%8f%e5%88%b6%e9%99%90&#34;&gt;アプリケーションの流量制限&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;私たちが管理するアプリケーションでもスケーラビリティにも限界があるので同じことが言える&lt;/li&gt;&#xA;&lt;li&gt;流量制限、つまりレートリミットやスロットリングを設計上意識することが重要&lt;/li&gt;&#xA;&lt;li&gt;チケットストアを例にすると、予約開始時間に過負荷が予想される&lt;/li&gt;&#xA;&lt;li&gt;静的資材はCDNを使って配信する&lt;/li&gt;&#xA;&lt;li&gt;動的コンテンツを配信するAPIは、スロットリングやレートリミットを導入し、429(Too Many Requests)を返し、フロントエンド側で適切にハンドリングする等の対策を行う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;アーキテクチャパターン&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%82%a2%e3%83%bc%e3%82%ad%e3%83%86%e3%82%af%e3%83%81%e3%83%a3%e3%83%91%e3%82%bf%e3%83%bc%e3%83%b3&#34;&gt;アーキテクチャパターン&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;EC2でのオートスケーリング&lt;/li&gt;&#xA;&lt;li&gt;ECSでのオートスケーリング&#xA;&lt;ul&gt;&#xA;&lt;li&gt;EC2 on ECSだとホスト側のスケーリングも意識する必要がある&lt;/li&gt;&#xA;&lt;li&gt;Fargateだとサーバーレスのようにホスト側を意識する必要はない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Lambdaでのオートスケーリング&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Lambdaは負荷に応じて自動でスケーリングする&lt;/li&gt;&#xA;&lt;li&gt;CloudWatch Logsともネイティブに統合されているので、EC2のように設計上意識する必要はない&lt;/li&gt;&#xA;&lt;li&gt;Lambdaは単なるサーバーの置き換えでの利用は推奨されない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;モノリシックな構造では、パッケージサイズが大きくなり、起動時間が伸びてしまう&lt;/li&gt;&#xA;&lt;li&gt;そもそも既存のミドルウェアやソースコードが流用できないこともままあるので、その対応も必要になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;なので、サーバーレスの恩恵を受けるには小さなコード単位で移行することが重要&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ただ整合性担保のケアが必要になる等のデメリットもあるので、アプリケーション観点においても分割の是非等を検討することが必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;有効な選択肢&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Lambda Web Adapter&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWS Lambda を利用して従来のウェブアプリケーションをサーバーレス環境にデプロイするためのツール&lt;/li&gt;&#xA;&lt;li&gt;Lambda Web Adapter は、HTTPリクエストをLambda関数に渡し、レスポンスを戻すプロキシとして機能する&lt;/li&gt;&#xA;&lt;li&gt;ExpressやSpring Bootで実装されたアプリケーションをそのまま動作させることができる&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/jp/builders-flash/202301/lambda-web-adapter/&#34;&gt;Lambda Web Adapter でウェブアプリを (ほぼ) そのままサーバーレス化する Lambda Web Adapter&lt;/a&gt;を少し読んでみる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dockerfileに1行を追加するだけで、ECSでもLambdaでも動作するコンテナイメージを作ることができる&lt;/li&gt;&#xA;&lt;li&gt;内部的な仕組みとしては、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Lambdaランタイムは/opt/extensions/ディレクトリを確認し、ファイルがあればLambda Extensionとして実行される&lt;/li&gt;&#xA;&lt;li&gt;Lambda ExtensionとしてWeb Adapterが機能し、受信したイベントをパースしてHTTPリクエストに変換し、ウェブアプリのプロセスにHTTPとして転送する(レスポンスも同じ考え方で実行される)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Stranglerパターン&#xA;&lt;ul&gt;&#xA;&lt;li&gt;既存のシステムやモノリシックアプリケーションを徐々に新しいアーキテクチャやシステムに移行する際に利用されるソフトウェア移行手法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;結果整合性を担保する3つのパターン&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e7%b5%90%e6%9e%9c%e6%95%b4%e5%90%88%e6%80%a7%e3%82%92%e6%8b%85%e4%bf%9d%e3%81%99%e3%82%8b3%e3%81%a4%e3%81%ae%e3%83%91%e3%82%bf%e3%83%bc%e3%83%b3&#34;&gt;結果整合性を担保する3つのパターン&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;1サガオーケストレーション&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#1%e3%82%b5%e3%82%ac%e3%82%aa%e3%83%bc%e3%82%b1%e3%82%b9%e3%83%88%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3&#34;&gt;1.サガオーケストレーション&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;非同期処理のアプリケーション障害に対して、前の状態に戻すための逆方向のロジックを実行する「補償トランザククション」を発行し、フォワードリカバリする&lt;/li&gt;&#xA;&lt;li&gt;サガパターンには以下の2つのバリエーションがある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コレオグラフィ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全体作業を制御する指揮者は存在しない&lt;/li&gt;&#xA;&lt;li&gt;それぞれのサービスがあらかじめ与えられた動作条件に従ってサービスを実行する&lt;/li&gt;&#xA;&lt;li&gt;後述のファンアウトがこれに該当する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;オーケストレーション&#xA;&lt;ul&gt;&#xA;&lt;li&gt;オーケストレーターが処理順序を管理する非同期処理の実装方法&lt;/li&gt;&#xA;&lt;li&gt;呼び出される側は、順番などを意識しなくて良いので疎結合になる一方、オーケストレーターが単一障害点になるリスクもある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;2トランザクションアウトボックス&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#2%e3%83%88%e3%83%a9%e3%83%b3%e3%82%b6%e3%82%af%e3%82%b7%e3%83%a7%e3%83%b3%e3%82%a2%e3%82%a6%e3%83%88%e3%83%9c%e3%83%83%e3%82%af%e3%82%b9&#34;&gt;2.トランザクション・アウトボックス&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えば、購入履歴テーブルへの書き込みの他に同じトランザクション内でアウトボックステーブルに書き込みを行う&#xA;&lt;ul&gt;&#xA;&lt;li&gt;書き込み後にSQSキューへの送信に失敗した場合、書き込みを取り消す処理を実行する必要がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;トランザクション・アウトボックスでは、イベント処理のロジックがアウトボックステーブルを読み込み、SQSに格納する&lt;/li&gt;&#xA;&lt;li&gt;Change Data Captureを活用することもできる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DynamoDBアイテムレベルの変更をストリームとして配信する機能があるのでそれを活用する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;3snsを利用した非同期処理のファンアウト&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#3sns%e3%82%92%e5%88%a9%e7%94%a8%e3%81%97%e3%81%9f%e9%9d%9e%e5%90%8c%e6%9c%9f%e5%87%a6%e7%90%86%e3%81%ae%e3%83%95%e3%82%a1%e3%83%b3%e3%82%a2%e3%82%a6%e3%83%88&#34;&gt;3.SNSを利用した非同期処理のファンアウト&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;トピックを使った非同期処理パターン&lt;/li&gt;&#xA;&lt;li&gt;非同期の並行処理をしていて、そこに新たな処理を追加する場合、プロデューサー側のロジックを変更し、新たにSQSへの書き込み処理などを追加する必要がある&lt;/li&gt;&#xA;&lt;li&gt;「ファンアウト」では、プロデューサーとコンシューマーの間にSNSトピックをかますことで、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プロデューサーは、メッセージを発行するだけ&lt;/li&gt;&#xA;&lt;li&gt;コンシューマーは、トピックをサブスクライブするだけ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;という構造にできるので、コンシューマー側はサブスクライブだけで並列処理を追加することができる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;制限をコントロールするためのパターン&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e5%88%b6%e9%99%90%e3%82%92%e3%82%b3%e3%83%b3%e3%83%88%e3%83%ad%e3%83%bc%e3%83%ab%e3%81%99%e3%82%8b%e3%81%9f%e3%82%81%e3%81%ae%e3%83%91%e3%82%bf%e3%83%bc%e3%83%b3&#34;&gt;制限をコントロールするためのパターン&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;1cloudfrontfunctionsを活用したvirtualwaitingroomの実装&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#1cloudfrontfunctions%e3%82%92%e6%b4%bb%e7%94%a8%e3%81%97%e3%81%9fvirtualwaitingroom%e3%81%ae%e5%ae%9f%e8%a3%85&#34;&gt;1.CloudFrontFunctionsを活用したVirtualWaitingRoomの実装&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;高負荷時に有料ユーザーのみ優先的にアクセスさせたいみたいなケース&lt;/li&gt;&#xA;&lt;li&gt;CloudFront FunctionsでCookieの値に応じて、無料ユーザーのみパスを書き換えて静的なリソースへ誘導することで実現できる&lt;/li&gt;&#xA;&lt;li&gt;この方法では、ランダムや先着順で振り分けにも応用できる&lt;/li&gt;&#xA;&lt;li&gt;また、障害発生時など一時的にトラフィックを逃がしたい時、ドメインを書き換えるみたいなこともできる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;2amazoncloudwatchによるクォータ監視と自動化&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#2amazoncloudwatch%e3%81%ab%e3%82%88%e3%82%8b%e3%82%af%e3%82%a9%e3%83%bc%e3%82%bf%e7%9b%a3%e8%a6%96%e3%81%a8%e8%87%aa%e5%8b%95%e5%8c%96&#34;&gt;2.AmazonCloudWatchによるクォータ監視と自動化&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/AmazonCloudWatch/latest/monitoring/CloudWatch-Quotas-Visualize-Alarms.html&#34;&gt;CloudWatchにクォータが統合されたAWSサービス&lt;/a&gt;では、CloudWatchのグラフやダッシュボードを作成しての可視化や、アラーム経由での通知や自動化が可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;3servicequotasapiを介したクォータ監視&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#3servicequotasapi%e3%82%92%e4%bb%8b%e3%81%97%e3%81%9f%e3%82%af%e3%82%a9%e3%83%bc%e3%82%bf%e7%9b%a3%e8%a6%96&#34;&gt;3.ServiceQuotasAPIを介したクォータ監視&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ServiceQuotasのListServices APIで一覧を取得し、DynamoDBと連携する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;7章-障害からの自動的な復旧を実現する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#7%e7%ab%a0-%e9%9a%9c%e5%ae%b3%e3%81%8b%e3%82%89%e3%81%ae%e8%87%aa%e5%8b%95%e7%9a%84%e3%81%aa%e5%be%a9%e6%97%a7%e3%82%92%e5%ae%9f%e7%8f%be%e3%81%99%e3%82%8b&#34;&gt;7章 障害からの自動的な復旧を実現する&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;利用者が設計・担保する責任範囲を狭べることは、障害の可能性を減らすためのアプローチの1つ&lt;/li&gt;&#xA;&lt;li&gt;ただ障害が発生しないシステムを構築することは不可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;リカバリ目標を定義する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%83%aa%e3%82%ab%e3%83%90%e3%83%aa%e7%9b%ae%e6%a8%99%e3%82%92%e5%ae%9a%e7%be%a9%e3%81%99%e3%82%8b&#34;&gt;リカバリ目標を定義する&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;闇雲に目標を設定するのではなく、目標復旧時間（RTO）と目標復旧時間（RPO）を定めた上で、具体的な実装に落とし込む&lt;/li&gt;&#xA;&lt;li&gt;目標復旧時間（RTO）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サービスの中断から復旧までの最大許容遅延&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;目標復旧時間（RPO）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最後のデータ復旧ポイントからの最大許容時間&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;無闇に目標値を高くしてしまうと、コストや難易度という代償がある&lt;/li&gt;&#xA;&lt;li&gt;アプリケーション全体ではなく、対象を特定の機能にしたり、目標復旧レベル（RLO）を定めて、どの業務をどの水準までという考え方を併せ持つと良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;フェイルオーバーを実装する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%83%95%e3%82%a7%e3%82%a4%e3%83%ab%e3%82%aa%e3%83%bc%e3%83%90%e3%83%bc%e3%82%92%e5%ae%9f%e8%a3%85%e3%81%99%e3%82%8b&#34;&gt;フェイルオーバーを実装する&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;待機系に自動で切り替えを行うフェイルオーバーと言っても、想定する障害やRTO・RPO・RLOに応じて、さまざまな方法から選択する必要がある&lt;/li&gt;&#xA;&lt;li&gt;Route53フェイルオーバー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ドメイン名を変えずに、リクエストの受け先を変更する&lt;/li&gt;&#xA;&lt;li&gt;リージョン間フェイルオーバーなど、アプリケーション全体の切り替えに使われる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ELBフェイルオーバー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;後続のサーバー等の障害を検知した際に、むき先を変更したり、対象リソースを切り離したりする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;マネージド型サービス機能によるフェイルオーバー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWSの責任範疇の機能としてフェイルオーバーの仕組みが設けたサービスが多い&lt;/li&gt;&#xA;&lt;li&gt;AuroraでマルチAZ構成の場合、障害時はリーダーインスタンスがプライマリインスタンスに昇格する設定が可能&lt;/li&gt;&#xA;&lt;li&gt;Lambdaのようなリージョンに紐づくマネージドサービスの場合は、ユーザーが意識されることなくフェイルオーバーが実施される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;この辺りの設計で意識すべきことは、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;採用するサービスがそれぞれどの地理的範囲に紐づくのか&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リージョンサービスなら、多くはフェイルオーバーしなくて良いという意味&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;マネージドサービスとして、フェイルオーバーの仕組みを設けられているか&lt;/li&gt;&#xA;&lt;li&gt;自身が管理するアプリケーションのRTOやRPOはどのような値か&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;タイムアウトリトライを実装する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%82%bf%e3%82%a4%e3%83%a0%e3%82%a2%e3%82%a6%e3%83%88%e3%83%aa%e3%83%88%e3%83%a9%e3%82%a4%e3%82%92%e5%ae%9f%e8%a3%85%e3%81%99%e3%82%8b&#34;&gt;タイムアウト・リトライを実装する&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;インフラ側に適切な設定がされていても、アプリケーション側が適切にハンドリングし、利用者に影響がないようにする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これを怠ると、一部の問題が全体に広がってしまう「カスケード障害」を引き起こす&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;タイムアウト&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%82%bf%e3%82%a4%e3%83%a0%e3%82%a2%e3%82%a6%e3%83%88&#34;&gt;タイムアウト&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;タイムアウト時間は、許容できる失敗率を元にパーセンタイルを設定し、実際のトランザクションのレイテンシーメトリクスに照らし合わせて設定する&lt;/li&gt;&#xA;&lt;li&gt;注意するポイントとしては、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;インターネット経由で通信する処理があると、処理時間が安定しないことが多い&lt;/li&gt;&#xA;&lt;li&gt;安定的にレイテンシが短い処理（例：50パーセンタイルと95パーセンタイルでほぼ差がない）だと、通常時のレイテンシを元に設定すると、少しの遅延でもタイムアウトが頻発してしまう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;このようなケースを踏まえて、実測値から随時設定を見直していくのが良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;リトライとバックオフ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%83%aa%e3%83%88%e3%83%a9%e3%82%a4%e3%81%a8%e3%83%90%e3%83%83%e3%82%af%e3%82%aa%e3%83%95&#34;&gt;リトライとバックオフ&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;エラー後の挙動としてリトライの仕組みを設けると、リトライは各クライアントが利己的（他を気にしないでという意味）に行うので、障害や遅延の長期化になる可能性がある&lt;/li&gt;&#xA;&lt;li&gt;なので、リトライの際には、バックオフ（待機時間）を設けることが大事&lt;/li&gt;&#xA;&lt;li&gt;バックオフには、以下の方法がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;固定の秒数を加算する&lt;/li&gt;&#xA;&lt;li&gt;指数関数的に秒数を増やすエクスポネンシャルバックオフ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://qiita.com/po3rin/items/c80dea298f16a2625dbe&#34;&gt;リトライ処理の効率的アプローチ「Exponential Backoff」の概要とGoによる実装 #Go - Qiita&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;ジッター&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%82%b8%e3%83%83%e3%82%bf%e3%83%bc&#34;&gt;ジッター&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;バックオフにランダム性を追加するのがジッターという考え方&#xA;&lt;ul&gt;&#xA;&lt;li&gt;バックオフは規則性があり、多くの場合は上限値を設ける&lt;/li&gt;&#xA;&lt;li&gt;障害が長期化した時に、多くのトランザクションが上限値の秒数でリトライを行うことになってしまい、障害の原因が過負荷であった場合に機能しなくなってしまう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;stepfunctionsによるリトライ機能&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#stepfunctions%e3%81%ab%e3%82%88%e3%82%8b%e3%83%aa%e3%83%88%e3%83%a9%e3%82%a4%e6%a9%9f%e8%83%bd&#34;&gt;StepFunctionsによるリトライ機能&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;StepFunctionsには、リトライ時のバックオフやジッターが機能として設けられている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;サーキットブレーカー&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%82%b5%e3%83%bc%e3%82%ad%e3%83%83%e3%83%88%e3%83%96%e3%83%ac%e3%83%bc%e3%82%ab%e3%83%bc&#34;&gt;サーキットブレーカー&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーキットブレーカーは、エラーの閾値を設けて、それを超えたら呼び出しを一時的に遮断する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;特に外部に公開しているAPIだと、クライアントからリトライを制御できない&lt;/li&gt;&#xA;&lt;li&gt;リトライ増加によるトラフィック増に繋がり、過負荷によるカスケード障害を引き起こすことがある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;言語フレームワーク機能を使って実装したり、サービスメッシュを使ってアーキテクチャとして組み込む方法がある&lt;/li&gt;&#xA;&lt;li&gt;サービスメッシュは、マイクロサービスのような互いに呼び出しあう構造にアーキテクチャにおいて有効な手法で、サービス間のすべての通信を処理するソフトウェアレイヤのこと&#xA;&lt;ul&gt;&#xA;&lt;li&gt;マイクロサービスの前段に、通信のモニタリング・ログ記録・トレース・トラフィックコントロールなどの機能を持つコンテナを配置し、サービス間の通信を管理する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/matope/mercari-dot-go-number-12-go-circuitbreakerfalsegoshao-jie?slide=22&#34;&gt;mercari.go #12 go-circuitbreakerのご紹介 - Speaker Deck&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;安全なデプロイメント&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e5%ae%89%e5%85%a8%e3%81%aa%e3%83%87%e3%83%97%e3%83%ad%e3%82%a4%e3%83%a1%e3%83%b3%e3%83%88&#34;&gt;安全なデプロイメント&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;障害は、デプロイのようなシステム変更作業時に混入してしまうことも多い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;ワンボックスデプロイとローリングアップデート&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%83%af%e3%83%b3%e3%83%9c%e3%83%83%e3%82%af%e3%82%b9%e3%83%87%e3%83%97%e3%83%ad%e3%82%a4%e3%81%a8%e3%83%ad%e3%83%bc%e3%83%aa%e3%83%b3%e3%82%b0%e3%82%a2%e3%83%83%e3%83%97%e3%83%87%e3%83%bc%e3%83%88&#34;&gt;ワンボックスデプロイとローリングアップデート&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主に下位互換の確認のために取られる手法&lt;/li&gt;&#xA;&lt;li&gt;最新のコードを1つのボックス(コンテナなVM)にデプロイして他のバージョンと共存させ問題がでないかを確認する&lt;/li&gt;&#xA;&lt;li&gt;問題が出なかった場合は、段階的にローリングデプロイを行う&#xA;&lt;ul&gt;&#xA;&lt;li&gt;段階的: 25％ずつなど割合を決めるのが一般的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;時差デプロイ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e6%99%82%e5%b7%ae%e3%83%87%e3%83%97%e3%83%ad%e3%82%a4&#34;&gt;時差デプロイ&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;複数のリージョンで展開している場合、いくつかのウェーブに分けて段階的にデプロイを行う&lt;/li&gt;&#xA;&lt;li&gt;応用として、AZやテナントごとにデプロイを徐々に行う方法もある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;ブルーグリーンデプロイメント&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%83%96%e3%83%ab%e3%83%bc%e3%82%b0%e3%83%aa%e3%83%bc%e3%83%b3%e3%83%87%e3%83%97%e3%83%ad%e3%82%a4%e3%83%a1%e3%83%b3%e3%83%88&#34;&gt;ブルーグリーンデプロイメント&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2つの同一環境を構築し、トラフィックを切り替える手法&lt;/li&gt;&#xA;&lt;li&gt;ロールバックが必要になったら、ブルー環境を再昇格すれば良いので時間短縮のメリットがある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;フェーズデプロイ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%83%95%e3%82%a7%e3%83%bc%e3%82%ba%e3%83%87%e3%83%97%e3%83%ad%e3%82%a4&#34;&gt;フェーズデプロイ&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ここまではインフラメインだったが、アプリケーションの中身の話&lt;/li&gt;&#xA;&lt;li&gt;例えば、あるAPIでのリクエストレスポンスをXML形式からJSON形式に変更する例&#xA;&lt;ul&gt;&#xA;&lt;li&gt;仮に、リクエストレスポンスを同時にJSONに変えたバージョンをリリースすると、呼び出し側も変更する必要があり、リスクが高まる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ロールバックの際、呼び出し側の考慮も必要になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;ロールバックとベイクタイム&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%83%ad%e3%83%bc%e3%83%ab%e3%83%90%e3%83%83%e3%82%af%e3%81%a8%e3%83%99%e3%82%a4%e3%82%af%e3%82%bf%e3%82%a4%e3%83%a0&#34;&gt;ロールバックとベイクタイム&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;システム停止だけでなく、性能劣化もロールバックの対象になる&lt;/li&gt;&#xA;&lt;li&gt;そのためにはメトリクスを取得し、閾値を超えた場合に自動で切り戻せる仕組みが重要&lt;/li&gt;&#xA;&lt;li&gt;上記の判断を行うために重要なのがベイクタイムという考え方&lt;/li&gt;&#xA;&lt;li&gt;ベイクタイムというのは、リリース後に一定時間監視し続ける時間&lt;/li&gt;&#xA;&lt;li&gt;ECSローリングアップデート機能や、AppConfigのようなデプロイ支援サービスにも、このベイクタイムを設定し、ロールバックする仕組みが設けられている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;アーキテクチャパターン-1&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%82%a2%e3%83%bc%e3%82%ad%e3%83%86%e3%82%af%e3%83%81%e3%83%a3%e3%83%91%e3%82%bf%e3%83%bc%e3%83%b3-1&#34;&gt;アーキテクチャパターン&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;障害からの自動的な復旧を実現するためのアーキテクチャパターンを紹介する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;フェイルオーバーのためのパターン&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%83%95%e3%82%a7%e3%82%a4%e3%83%ab%e3%82%aa%e3%83%bc%e3%83%90%e3%83%bc%e3%81%ae%e3%81%9f%e3%82%81%e3%81%ae%e3%83%91%e3%82%bf%e3%83%bc%e3%83%b3&#34;&gt;フェイルオーバーのためのパターン&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Route53を使った静的安定なリージョンフェイルオーバー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ヘルスチェックに失敗したら、セカンダリにフェイルオーバーする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Standby Takes Over Primary(STOP)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;(実務で求められる可用性の域を超えている感じがするため省略)&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;8章-回復力をテストする&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#8%e7%ab%a0-%e5%9b%9e%e5%be%a9%e5%8a%9b%e3%82%92%e3%83%86%e3%82%b9%e3%83%88%e3%81%99%e3%82%8b&#34;&gt;8章 回復力をテストする&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;スケーラビリティをテストする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IaC化しておくことで柔軟にテスト用環境を作ることができる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;障害復旧のテストをする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FISを使うことでサーバーの強制停止やネットワーク疎通障害をシュミレートできる&lt;/li&gt;&#xA;&lt;li&gt;ターゲットに対し、どのような障害を起こすかを指定でき、結構使えそう&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/jp/fis/&#34;&gt;耐障害性テストツール – AWS フォールトインジェクション Service – AWS&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;第3部-可観測性を高める&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e7%ac%ac3%e9%83%a8-%e5%8f%af%e8%a6%b3%e6%b8%ac%e6%80%a7%e3%82%92%e9%ab%98%e3%82%81%e3%82%8b&#34;&gt;第3部 可観測性を高める&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可観測性とは「システムの内部で何が起きているかを説明できるシステムの状態」のこと&lt;/li&gt;&#xA;&lt;li&gt;なぜこのような新しい概念が必要になったか？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;システム面においては、クラウドネイティブにおける疎結合なアーキテクチャにおいても原因特定を容易できるようにするため&#xA;&lt;ul&gt;&#xA;&lt;li&gt;従来のリアクティブなモニタリングでは事足りなくなった&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ビジネス面においても、そもそもITサービスがビジネスにおいて重要な立ち位置になった＋アクセス数などがビジネス目標立てられるようになったことで、可観測性高く様々なデータを収集できることが重要になった&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;優れた可観測性が、事実に基づいたデータを元にデバッグやトラブルシューティングを可能にし、運用の手間や時間を削減する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;こうなることで、ビジネスの本質的な部分に時間を割くことを可能にする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;可観測性の真の目的は「ビジネスの成功」&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;9章-可観測性を実装し運用する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#9%e7%ab%a0-%e5%8f%af%e8%a6%b3%e6%b8%ac%e6%80%a7%e3%82%92%e5%ae%9f%e8%a3%85%e3%81%97%e9%81%8b%e7%94%a8%e3%81%99%e3%82%8b&#34;&gt;9章 可観測性を実装し運用する&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可観測性の3本柱&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ログ&lt;/li&gt;&#xA;&lt;li&gt;メトリクス&lt;/li&gt;&#xA;&lt;li&gt;トレース&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ある1つのリクエストからレスポンスまでを1つのサービスマップとして可視化できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;開発初期フェーズから実装すべき&#xA;&lt;ul&gt;&#xA;&lt;li&gt;途中からだと難易度が上がるのと、優先度が下がりやすい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;モニタリングの指標&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SLI(ServiceLevelIndicator)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;稼働状況を数値化した指標。エラー率や応答時間など。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SLO(ServiceLevelObjective)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サービスレベル目標。SLIの運用目標値。これを定めることでシステムのサービスレベルを定義する。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SLA(ServiceLevelAgreement)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サービスレベル合意。SLOを達成した場合、未達であった場合の規約。返金します、とか。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;パーセンタイルとは？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;APIの応答時間の健全性によく利用される統計量のこと&lt;/li&gt;&#xA;&lt;li&gt;指定した期間の小さい順から大きい順に並べた時に、指定した割合がある値を意味する&lt;/li&gt;&#xA;&lt;li&gt;平均値より外れ値の影響を受けづらく、中央値と比べて影響を受けるユーザーやリクエストが多い障害を検知しやすいというメリットがある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;エラーバジェット&#xA;&lt;ul&gt;&#xA;&lt;li&gt;新機能を早く出したいというビジネス観点と機能追加によってユーザーに悪影響を及ぼすことを避けたいというシステム観点（対立関係）&lt;/li&gt;&#xA;&lt;li&gt;仮に軽微なエラーなら許容するし、そうでないなら..みたいなもの衝突を、定量的なデータとして管理するための考え方が「エラーバジェット」&lt;/li&gt;&#xA;&lt;li&gt;小さいミスを許容する代わりに、リリースのアジリティを向上させる&lt;/li&gt;&#xA;&lt;li&gt;具体的には、定義したSLOの範囲に収まっている間は新機能をリリースし、下回ったりしたら品質改善に注力するみたいな&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;100%のSLOを目指すべきなのか？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;過剰品質は、ビジネスの加速を阻害する&lt;/li&gt;&#xA;&lt;li&gt;品質を求めることで、システムにかかる原価が上がり、利用者数減につながる場合もある&lt;/li&gt;&#xA;&lt;li&gt;SLOは、ビジネス部門を含めて定期的に見直すべき&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;トリアージ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;優先度付けの意味&lt;/li&gt;&#xA;&lt;li&gt;全てのアラートを通知し、オオカミ少年状態になってしまうみたいなことを避けるべし&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ビジネスKPIとモニタリング活用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;KPIを元にモニタリングを設計する&lt;/li&gt;&#xA;&lt;li&gt;ただし、会員数などのリアルタイムで収集しなくても良いデータに関しては、月次レポート・ダッシュボードなどで対応するとよい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;エンドユーザーの体験をモニタリングする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;システムのメトリクスを収集しても、それが実際どのようにユーザーに影響しているかはわからない&lt;/li&gt;&#xA;&lt;li&gt;ユーザーから見たパフォーマンスをモニタリングする手法として以下がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SyntheticsMonitoring&#xA;&lt;ul&gt;&#xA;&lt;li&gt;外形監視。擬似アクセスを発生させモニタリングする。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;RUM(RealUserMonitoring)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;実際のユーザーアクセスを用いてモニタリングする。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;FinOps&#xA;&lt;ul&gt;&#xA;&lt;li&gt;財務*DevOps&lt;/li&gt;&#xA;&lt;li&gt;目的は、クラウドコストの最適化ではなく、その先にあるビジネス価値の最大化である&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;アーキテクチャパターン-2&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e3%82%a2%e3%83%bc%e3%82%ad%e3%83%86%e3%82%af%e3%83%81%e3%83%a3%e3%83%91%e3%82%bf%e3%83%bc%e3%83%b3-2&#34;&gt;アーキテクチャパターン&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可観測性を実現するアーキテクチャパターンの紹介&lt;/li&gt;&#xA;&lt;li&gt;CloudWatch Application Signals&#xA;&lt;ul&gt;&#xA;&lt;li&gt;有効にすると、アプリケーションのテレメトリデータを自動収集し、アクセス数・可用性・レイテンシ・障害・エラーなどの主要メトリクスや、SLOの状況をダッシュボードで可視化できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CloudWatch Synthetics&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ヘッドレスブラウザが対象URLにアクセスする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CloudWatch RUM&#xA;&lt;ul&gt;&#xA;&lt;li&gt;実際のユーザーのセッションを利用して、読み込み時間やクライアントエラー、ユーザーのブラウザやデバイスを可視化できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;いかに収集したデータを運用するか&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DevOps Guruなど、AIを活用したサービスもいくつかある(省略)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;第10章-awsのサービスを活用してテレメトリを収集する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/004_aws%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3/#%e7%ac%ac10%e7%ab%a0-aws%e3%81%ae%e3%82%b5%e3%83%bc%e3%83%93%e3%82%b9%e3%82%92%e6%b4%bb%e7%94%a8%e3%81%97%e3%81%a6%e3%83%86%e3%83%ac%e3%83%a1%e3%83%88%e3%83%aa%e3%82%92%e5%8f%8e%e9%9b%86%e3%81%99%e3%82%8b&#34;&gt;第10章 AWSのサービスを活用してテレメトリを収集する&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;X-Rayによる分散トレーシング&lt;/li&gt;&#xA;&lt;li&gt;ログ出力先を抽象化する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;標準出力に集約し、その標準出力は仮想マシンや外部のログルーターに即時転送するようにする「ログルーター」という実装がある&lt;/li&gt;&#xA;&lt;li&gt;Lambdaのようなサーバーレスアーキテクチャであれば、標準出力するだけでCloudWatch Logsにログを連携できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>改訂新版プロになるためのWeb技術入門</title>
      <link>http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/</link>
      <pubDate>Mon, 19 May 2025 23:08:39 +0900</pubDate>
      <guid>http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考にしたもの&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#%e5%8f%82%e8%80%83%e3%81%ab%e3%81%97%e3%81%9f%e3%82%82%e3%81%ae&#34;&gt;参考にしたもの&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/live/5WZDiKol8k4?si=snrgHWB_KgGl3jTe&#34;&gt;https://www.youtube.com/live/5WZDiKol8k4?si=snrgHWB_KgGl3jTe&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;3章-wwwの基本要素とその発展&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#3%e7%ab%a0-www%e3%81%ae%e5%9f%ba%e6%9c%ac%e8%a6%81%e7%b4%a0%e3%81%a8%e3%81%9d%e3%81%ae%e7%99%ba%e5%b1%95&#34;&gt;3章 WWWの基本要素とその発展&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;データ交換にHTMLは適さない(プログラムで取り扱うのが困難)&lt;/li&gt;&#xA;&lt;li&gt;そんな背景があり登場したのがXML&lt;/li&gt;&#xA;&lt;li&gt;どういうデータ構造なのかの決まりをスキーマという&lt;/li&gt;&#xA;&lt;li&gt;XMLではDOCTYPE宣言でdtdファイルでスキーマを指定できる&lt;/li&gt;&#xA;&lt;li&gt;スキーマレスのJSONやYAMLが流行ったが、結局JSONスキーマが流行ったり、流行は繰り返される&lt;/li&gt;&#xA;&lt;li&gt;XMLは人が扱うには複雑ではあるが、今でもExcelやe-taxなどコンピュータが読み取るデータとしては&#xA;多く利用される&lt;/li&gt;&#xA;&lt;li&gt;そこからXHTMLも開発されたが、制約が多かったりあまり歓迎されなかった(流行らなかった)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;4章-httpクライアントとhttpサーバー&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#4%e7%ab%a0-http%e3%82%af%e3%83%a9%e3%82%a4%e3%82%a2%e3%83%b3%e3%83%88%e3%81%a8http%e3%82%b5%e3%83%bc%e3%83%90%e3%83%bc&#34;&gt;4章 HTTPクライアントとHTTPサーバー&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CGI: リクエストパスに応じてプログラムを起動する、今ではあまり見かけないが、このあとの発展に重要&lt;/li&gt;&#xA;&lt;li&gt;動的にHTMLを返す、テンプレートエンジンの登場&lt;/li&gt;&#xA;&lt;li&gt;上記を礎に、ブラウザなのでインストール不要であり、自由度の高いUIを実現できるWebアプリケーションが発展していくことになる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;5章-urlとhttp&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#5%e7%ab%a0-url%e3%81%a8http&#34;&gt;5章 URLとHTTP&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;URLからwww.が消えたのは、クラウドの台頭とサブドメインを気軽にはやせることができるようになり、昔のようにホストとWebサーバの結びつきが弱くなったため&lt;/li&gt;&#xA;&lt;li&gt;開発時にウェルナウンポートを使用すると起動のたびにsudo権限が必要なため、8080のようなポートを使うことが多い&lt;/li&gt;&#xA;&lt;li&gt;ブラウザはURLパスに含まれる拡張子ではなく、MIMEタイプ(Content-Type)を見てどのように扱うかを決めている&lt;/li&gt;&#xA;&lt;li&gt;GETリクエストでリソース状態を変更できるような実装すべきじゃない理由は、検索クローラによるアクセスでリソースが意図せず変化してしまうことを避けるということも理由にある&lt;/li&gt;&#xA;&lt;li&gt;よく見るフォーム再送信の確認ダイアログはPOSTリクエストが二重に行われることによる、不利益を避けるため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;6章-従来型のwebアプリケーション&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#6%e7%ab%a0-%e5%be%93%e6%9d%a5%e5%9e%8b%e3%81%aeweb%e3%82%a2%e3%83%97%e3%83%aa%e3%82%b1%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3&#34;&gt;6章 従来型のWebアプリケーション&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;従来型アプリケーションをSPAとの対比という意味で昨今はMPAと呼ぶことが多い（当時からMPAと呼んでいたわけではなかった）&lt;/li&gt;&#xA;&lt;li&gt;コンピュータの世界で、一連の処理の流れにある背景情報(ユーザ名とか)をコンテキストという&lt;/li&gt;&#xA;&lt;li&gt;HTTPはステートレスである&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一連の流れをセッションという&lt;/li&gt;&#xA;&lt;li&gt;ブラウザでそのセッション（状態）を管理するのがCookieである&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Cookie&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Cookieの送信条件は「同じサイトにアクセスした時にそのサイトのCookieを渡す」&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同じサイトかは、オリジン（ホスト/スキーム/ポート）で判断する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ただそれ以外にも、サーバーからSet-Cookieヘッダでレスポンスするときに以下のような属性(細かな送信条件)を設定することが可能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Expires/Max-Age&#xA;&lt;ul&gt;&#xA;&lt;li&gt;有効期限を表す&lt;/li&gt;&#xA;&lt;li&gt;どちらも設定されている場合はMax-Ageが優先される&lt;/li&gt;&#xA;&lt;li&gt;どちらも設定されていない場合はセッションクッキーと呼ばれ、ブラウザが終了するまで有効となる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;だが近年のいくつかのブラウザは起動時にタブを復元する機能があり、その際にクッキーも復元される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Domain&#xA;&lt;ul&gt;&#xA;&lt;li&gt;どのサーバに対してアクセスした時にクッキーを送信すべきかを設定する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;つまり、サーバからクライアントへの送信条件の制御&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;example.comと指定した場合は、sub.example.comのようなサブドメインも含まれる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;未指定の場合は、上記のようなサブドメインはCookieは送信されない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;例えば親ドメインで発行したクッキーを、サブドメインにあるサーバに送ってほしい時とかに使用する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;HttpOnly&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JSからのアクセスを禁止する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;外部への漏洩を防ぐために推奨される設定&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Domain: 未指定（発行したドメインだけに送信されるようにする）&lt;/li&gt;&#xA;&lt;li&gt;Secure: HTTPS通信時のみ&lt;/li&gt;&#xA;&lt;li&gt;HttpOnly: JSからアクセス禁止させる&lt;/li&gt;&#xA;&lt;li&gt;SameSite: Lax or Strict&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;DomainとSameSiteの違い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Domainは送信先の制限、SameSiteは送信元の制限&lt;/li&gt;&#xA;&lt;li&gt;Domain指定なし:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同一ドメインしかCookieを送信しない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Domainにexample.comを設定:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;sub.example.comにもCookieを送信する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SameSite指定なし(Lax):&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一部のクロスサイトリクエスト（GETメソッドのナビゲーションなど）でもCookieを送信する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SameSiteにStrictを設定:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同一サイトのみCookieを送信する&lt;/li&gt;&#xA;&lt;li&gt;malicious.comというサイトからexample.comへのアクセス時はCookieを送信しないといったイメージ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SameSiteにNoneを設定:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;いかなるクロスサイトのリクエストでもCookieを送信する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;まとめると、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Domainは、どこにCookieを送信するかの設定&lt;/li&gt;&#xA;&lt;li&gt;SameSiteは、どこからCookieを送信するかの設定&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;セッション&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Cookieを用いてセッションを管理する&lt;/li&gt;&#xA;&lt;li&gt;セッションの盗用(セッションハイジャック)を防ぐ方法として&#xA;&lt;ul&gt;&#xA;&lt;li&gt;固定や推測されやすい値を使用しない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サードパーティクッキーと個人情報保護&#xA;&lt;ul&gt;&#xA;&lt;li&gt;あるサイトAに訪問した時に広告画像をクリックした際に、このユーザー(ブラウザ)はこの広告をクリックしたよというCookieをセットする&lt;/li&gt;&#xA;&lt;li&gt;別のサイトBにアクセスし、広告画像を表示する際に、広告側にはこのユーザーが過去にクリックした広告情報をCookieから取得し、異なるサイト間でも同じような広告を表示させるという仕組み&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;セッションとユーザー管理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;セッションベースでのToDoアプリ例を見ると、セッション単位＝ブラウザ単位となるので、ユーザー情報を異なるブラウザで保持させることができない問題がある&lt;/li&gt;&#xA;&lt;li&gt;ここで登場するのが「認証」という仕組みになる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;7章-spaへの進化&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#7%e7%ab%a0-spa%e3%81%b8%e3%81%ae%e9%80%b2%e5%8c%96&#34;&gt;7章 SPAへの進化&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;(この章の背景を補足)&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;第2次ブラウザ戦争を経てGoogleがV8というJSエンジンを開発し、JSがとても速く実行できるようになった&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;その結果、こんな速いならサーバーサイドでも使えるんじゃね？となり、Nodeが登場&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;従来型の遷移が多く遅い・サーバからの通知ができない問題を解決したのがSPA&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;RIA(Flash)が流行りきらなかった理由としてクローズドな技術だったことが挙げられる。以降は標準化された技術の積み重ねで進化してきている&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;DOM&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ブラウザはHTMLを読み込むと、内部でDOMというツリー状のデータ構造を構築する&lt;/li&gt;&#xA;&lt;li&gt;このDOMがJavaScriptからHTMLを操作するための仕様&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;イベントドリブンプログラミング&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一般的なプログラムは逐次処理で上から下に記述された順で処理されるが、GUIのようなユーザー操作が基点となる処理では、逐次処理の書き方が複雑になる&lt;/li&gt;&#xA;&lt;li&gt;そこで生まれたのがイベントドリブンで、ユーザ操作などのイベントを起点とし、そのイベントが発生したときに実行すべき処理を、そのイベントと紐づけて記述する。これをイベントハンドラやイベントリスナと呼ぶ。&lt;/li&gt;&#xA;&lt;li&gt;JSでは、addEventListnerで関数登録できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;JavaScriptは、ブラウザ戦争やブラウザ間の互換性差異に課題があった背景があり、ECMAScriptという標準化団体が標準化を進めた&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これにより、各ブラウザに内蔵されるJavaScriptエンジンは異なるものの、ECMAScriptに準拠しているため、互換性が保たれている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;同期処理から非同期処理へ&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同期処理だと、処理中にブラウザでの操作がブロックされ、体験があまりよくない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;XMLHttpRequest&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;XMLとついているが、実際にはXMLと強い結びつきはない&lt;/li&gt;&#xA;&lt;li&gt;事実JSONでやり取りすることが多い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;XMLとJSON&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;XMLは構造化されたデータをテキストでやり取りできるが、パース処理が比較的重いのが欠点&lt;/li&gt;&#xA;&lt;li&gt;XMLの代わりとなったのがJSONで、JSの文法をそのまま使ってデータ表現をしている（のでパースが楽）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;ReactやVue.jsの存在&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DOM APIのみを使って、JSで画面を構築するのは結構大変なので、表題のようなFWを使用する&lt;/li&gt;&#xA;&lt;li&gt;SPAでは画面表示内容を全てJSで構築する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;フラグメントによる状態変化の表現&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SPAはURLパスが変わらないので、ブックマークやブラウザの戻る進むができない&lt;/li&gt;&#xA;&lt;li&gt;フラグメントは、見出しごとにアンカーを定義して、フラグメントでそれを参照するみたいなやつ&lt;/li&gt;&#xA;&lt;li&gt;URLのフラグメント部はサーバーへ送信されない（リクエストが発生しない）&lt;/li&gt;&#xA;&lt;li&gt;JSからはlocationオブジェクトで参照可能&lt;/li&gt;&#xA;&lt;li&gt;SPAではフラグメントを活用することで、状態ごとにURLパスを変えることができる（というよりは、フラグメントを元に表示状態を復元している）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;SPAの課題&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;検索エンジンとの相性の悪さ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SPAはHTMLがほとんど空っぽなので（JSで構築するので）クローラが(JS実行前の何もない状態の)HTMLを解析しても適切にインデックスが構築できない&lt;/li&gt;&#xA;&lt;li&gt;また、URLのフラグメント部はインデックス対象にならないので、フラグメント部に固有の商品ID的なものを埋め込んでも、商品固有のインデックスを構築できない&lt;/li&gt;&#xA;&lt;li&gt;ただ、現在はJSでレンダリングされたページでもある程度読み取れるように、クローラが改善されている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;初期表示の遅さ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JSで必要な情報をAPIから収集したり、その上で画面を構築していくので、どうしても初期描画が遅くなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;SPAの課題に対するアプローチ&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HistoryAPIによる画面遷移&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HTML5で登場したブラウザのAPI&lt;/li&gt;&#xA;&lt;li&gt;アドレスバーに表示させるURLや履歴をJSから操作できる&lt;/li&gt;&#xA;&lt;li&gt;SPAの非同期通信を活用した高速な画面切り替えという強みを残しつつ、URL変更に伴う擬似的な画面遷移を実現できるようになった&lt;/li&gt;&#xA;&lt;li&gt;実装的には、aタグリンククリック時のイベントリスナのコールバック関数の中で、&lt;code&gt;e.preventDefault();&lt;/code&gt;を実行し、ブラウザが本来行うページ遷移機能を奪い、JSでHistoryAPIを実行する&lt;/li&gt;&#xA;&lt;li&gt;もし仮にURLパスが含まれた状態でリロードされてもきちんとページが返るように、サーバ側ではindex.htmlを返すように実装する必要がある&lt;/li&gt;&#xA;&lt;li&gt;HistoryAPIとフラグメント方式は一長一短&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アプリケーション内の画面を検索エンジンにインデックスさせる必要がないなら、フラグメント方式でも良い（実際Gmailはフラグメント方式）&lt;/li&gt;&#xA;&lt;li&gt;フラグメント方式は、サーバ側での実装考慮が不要であり、実現方法が簡単&lt;/li&gt;&#xA;&lt;li&gt;HistoryAPI方式は、サーバ側での考慮必要で実装が複雑だが、検索エンジンとの相性が良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サーバーサイドレンダリングへの回帰&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HistoryAPIにより、SPAでもフラグメントに頼らず、画面とURLを一致させられるようになったものの、JSが実行されるまではページ内容がわからない＝検索エンジンがインデックスできないという問題がある&lt;/li&gt;&#xA;&lt;li&gt;それに加えて、初期表示の遅さという2つの課題を解決するものとしてサーバーサイドレンダリング&lt;/li&gt;&#xA;&lt;li&gt;これは初期表示に限って、HTMLをサーバー側で生成して返すというもの&lt;/li&gt;&#xA;&lt;li&gt;ちなみに初期表示の遅さは色々な要因があり、JSのコードを1つにまとめて、変数名や関数名を短くするミニファイ等がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;AltJS&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JSはES2015まで停滞していた、サーバーサイドとは異なりブラウザで唯一動く言語の停滞はクライアントサイドの開発においては大きな影響がある&lt;/li&gt;&#xA;&lt;li&gt;そんな中、JSにトランスパイル言語を開発することで、それらをAltJSと呼ぶ&lt;/li&gt;&#xA;&lt;li&gt;生き残ったのがTypeScriptとなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;8章-webapi&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#8%e7%ab%a0-webapi&#34;&gt;8章 WebAPI&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SPAの普及により、URLがコンテンツを返すではなく、アプリケーション・プログラムの関数呼び出しの位置付けに変化&lt;/li&gt;&#xA;&lt;li&gt;インターネットを経由したAPIの呼び出し、すなわちWebAPIが普及していった&lt;/li&gt;&#xA;&lt;li&gt;COBRAとSOAPを経て、WebAPIの普及へ&lt;/li&gt;&#xA;&lt;li&gt;WebAPIは設計の自由度が高いので、1つの指針を示したのがRESTになる&lt;/li&gt;&#xA;&lt;li&gt;RESTをWebAPIに当てはめて具体化する（リソース指向アーキテクチャ）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;さまざまな情報の集まりをリソースと表現する&lt;/li&gt;&#xA;&lt;li&gt;RESTに基づいたAPIは、リソースに対する操作を提供するという考え方で、次の4つの特性を持つ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リソースの示し方：リソースを表すURLがあり、URLによってリソースにアクセスできる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;/addとかではなく、/todoというリソースを指す場所&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;リソースのたどり方：あるリソースから別のリソースを辿ることができる&lt;/li&gt;&#xA;&lt;li&gt;リソースの操作方法：リソースに対して何をしたいかはHTTPメソッドで表現する&lt;/li&gt;&#xA;&lt;li&gt;リソース操作の手順：リソース操作に手順は不要で、一度のやり取りで求められる結果が得られる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ステートレスは、サーバーに状態を持たせてしまうとシステム規模に応じてサーバー台数を増やしにくくなってしまうため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;POSTとHTTPステータスの使い分け&#xA;&lt;ul&gt;&#xA;&lt;li&gt;POSTメソッドには、以下の2つの役割がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;子リソースの新規追加（TODOリストへの追加等、フォルダの中に新規ファイルを1つ作成するイメージ）&lt;/li&gt;&#xA;&lt;li&gt;既存リソースへの追加（既にあるファイルに追記するイメージ）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;子リソースへの追加の場合は、201 CreatedでLocationヘッダに作成したリソースのURLを返すべきとされている&lt;/li&gt;&#xA;&lt;li&gt;一方、既存リソースへの追加の場合は、対象が既に存在しているため、200 OKを返すだけで良いとされている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;オーバーロードPOST&#xA;&lt;ul&gt;&#xA;&lt;li&gt;本来使用したいメソッドが使えない場合、POSTリクエストのヘッダに&lt;code&gt;X-HTTP-Method-Override&lt;/code&gt;として本来使用したいメソッド(DELETE等)を設定する手法もある&lt;/li&gt;&#xA;&lt;li&gt;なお、&lt;code&gt;X-&lt;/code&gt;で始まるヘッダは非標準のカスタムヘッダを意味する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;再注目されるRPCスタイル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RESTに則ったAPIでは「オーバー/アンダーフェッチング」「N＋1問題」がある（つまり欲しい情報を手に入れるのに足りなかった理、逆に多すぎるというケースがあると理解）&lt;/li&gt;&#xA;&lt;li&gt;そこで注目されたのが「GraphQL」である&#xA;&lt;ul&gt;&#xA;&lt;li&gt;QueryLanguageなので、SQLと立て付けは同じで、SQLはデータを対象とし、GraphQLはオブジェクトを対象とする&lt;/li&gt;&#xA;&lt;li&gt;問い合わせ対象となるデータ構造を「スキーマ」として問い合わせパターンを定義する&lt;/li&gt;&#xA;&lt;li&gt;問い合わせパターンを「クエリ」と表現し、パラメータ部分（どのデータが欲しいか等）はクライアント側で自由に決められる&lt;/li&gt;&#xA;&lt;li&gt;/graphqlという1つのエンドポイントに、クエリ文字列をPOSTメソッドを送信する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Mutationというデータ更新の場合も同じ（クエリをURLに含めることができず、ボディにセットする必要があるためこの仕組みになっている）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;欲しいデータを指定できるので、「オーバー/アンダーフェッチング」「N＋1問題」も解決&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;GraphQLは、SOAPのようなRPCに近い仕組みになっている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SOAPは、RESTによって駆逐されてしまったが、結局APIだけでは全てのニーズを満たすことができなかった&lt;/li&gt;&#xA;&lt;li&gt;どっちがダメではなく相互補完である&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;9章-サーバプッシュ技術&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#9%e7%ab%a0-%e3%82%b5%e3%83%bc%e3%83%90%e3%83%97%e3%83%83%e3%82%b7%e3%83%a5%e6%8a%80%e8%a1%93&#34;&gt;9章 サーバプッシュ技術&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;サーバプッシュ技術の歴史&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#%e3%82%b5%e3%83%bc%e3%83%90%e3%83%97%e3%83%83%e3%82%b7%e3%83%a5%e6%8a%80%e8%a1%93%e3%81%ae%e6%ad%b4%e5%8f%b2&#34;&gt;サーバプッシュ技術の歴史&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当初のWWWで新たな情報を取得するためには同じURLにアクセスしてコンテンツを取得する必要があった&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これをPull型通信と呼ぶ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;これに対して、サーバからクライアントに情報を送信することをサーバプッシュと呼ぶ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;メタリフレッシュによる擬似サーバプッシュ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#%e3%83%a1%e3%82%bf%e3%83%aa%e3%83%95%e3%83%ac%e3%83%83%e3%82%b7%e3%83%a5%e3%81%ab%e3%82%88%e3%82%8b%e6%93%ac%e4%bc%bc%e3%82%b5%e3%83%bc%e3%83%90%e3%83%97%e3%83%83%e3%82%b7%e3%83%a5&#34;&gt;メタリフレッシュによる擬似サーバプッシュ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;初期のWWWで使用されていたのがmeta refreshというHTMLの機能&lt;/li&gt;&#xA;&lt;li&gt;meta要素に従って、URLを再ロードさせる&lt;/li&gt;&#xA;&lt;li&gt;簡単ではあるが、即時性が求められるシーンでは現実的な手段ではないし、ページリロードが走るのでUX的にも良くなかった&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;通信量の削減&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#%e9%80%9a%e4%bf%a1%e9%87%8f%e3%81%ae%e5%89%8a%e6%b8%9b&#34;&gt;通信量の削減&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ブラウザキャッシュという仕組み&lt;/li&gt;&#xA;&lt;li&gt;サーバ側がコンテンツ提供時にキャッシュ有効期間をきめ、その期間内はブラウザ側で保持し、それを表示に使用することで通信量を削減する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ajaxによるポーリング&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#ajax%e3%81%ab%e3%82%88%e3%82%8b%e3%83%9d%e3%83%bc%e3%83%aa%e3%83%b3%e3%82%b0&#34;&gt;Ajaxによるポーリング&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;setInterval関数で定期ポーリング&lt;/li&gt;&#xA;&lt;li&gt;定期的にFetchを行い、変更が必要な情報だけをJSONで取得することで、ページ全体のHTMLを返すよりも通信量を削減できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;cometロングポーリング&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#comet%e3%83%ad%e3%83%b3%e3%82%b0%e3%83%9d%e3%83%bc%e3%83%aa%e3%83%b3%e3%82%b0&#34;&gt;Comet(ロングポーリング)&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これは、クライアントがリクエストを送り、サーバはしばらく待ってからレスポンスを返すことでプッシュ風に見せる手法（今や古典的）&lt;/li&gt;&#xA;&lt;li&gt;キャッシュやAjaxでは即時性を向上させるのが難しい&lt;/li&gt;&#xA;&lt;li&gt;HTTPレスポンスの返し方を工夫することで、HTTPの枠組みの中で即時性を向上させる技術「Comet」が登場した&lt;/li&gt;&#xA;&lt;li&gt;Cometとは？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;意図的にレスポンスを保留し、通知すべき情報が変化が発生して初めてレスポンスを返す&lt;/li&gt;&#xA;&lt;li&gt;サーバは待ち時間が発生するがAjaxによる非同期通信であればユーザーに影響はない&lt;/li&gt;&#xA;&lt;li&gt;クライアント側はレスポンスを受け取ったらすぐにリクエストを送り（以下ループ）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Cometの問題点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一度サーバから情報を送信すると再接続が必要なので、高頻度で更新されるような場合はネットワークやサーバに負荷がかかる&lt;/li&gt;&#xA;&lt;li&gt;また、一定時間経過すると、ブラウザや途中経過のプロキシサーバによって、通信が切断される&lt;/li&gt;&#xA;&lt;li&gt;即時性の面でも、レスポンスを返し、再度接続されるまでの間は、すぐに通知ができない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;という問題点を抱えたが、既存の技術を使ってプッシュ技術が実現できるので、長く使われた&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;server-sent-eventsによるプッシュ配信&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#server-sent-events%e3%81%ab%e3%82%88%e3%82%8b%e3%83%97%e3%83%83%e3%82%b7%e3%83%a5%e9%85%8d%e4%bf%a1&#34;&gt;Server-sent eventsによるプッシュ配信&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Cometは既存の技術を使用し、無理矢理実現している感があった&lt;/li&gt;&#xA;&lt;li&gt;そんな状況で、HTML5で関連のAPIの1つとして制定されたのがServer-sent events&lt;/li&gt;&#xA;&lt;li&gt;Cometによるロングポーリングを1歩進めたHTTPストリーミング&lt;/li&gt;&#xA;&lt;li&gt;ロングポーリングでは1度レスポンスを返すと再接続が必要という課題があったが、HTTPストリーミングではレスポンスを少しずつ返すことで、一度のリクエストに対してサーバからの通知を連続して行うことができる&lt;/li&gt;&#xA;&lt;li&gt;これはHTTP1.1で追加されたチャンク転送という機能に基づいている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;チャンク転送&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#%e3%83%81%e3%83%a3%e3%83%b3%e3%82%af%e8%bb%a2%e9%80%81&#34;&gt;チャンク転送&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;chunkとは塊のこと&lt;/li&gt;&#xA;&lt;li&gt;リクエストやレスポンスをいくつかの塊に分割して送信する機能&lt;/li&gt;&#xA;&lt;li&gt;チャンク転送でレスポンスを返すには、&lt;code&gt;Transfer-Encoding: chunked&lt;/code&gt;というヘッダを返し、以下のような形式でデータの塊を少しづつ返す&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  &amp;lt;chunk size(16進数)&amp;gt;&#xA;  &amp;lt;data&amp;gt;&#xA;  &amp;lt;blank line&amp;gt;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;データを全て送信したら、最後に0を送信して、転送終了の合図とする&lt;/li&gt;&#xA;&lt;li&gt;クライアントはすべてのデータを持つことなく、チャンク単位で受け取って処理ができるので、総量が分からないデータを送信するのに役立つ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;server-sent-eventssse&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#server-sent-eventssse&#34;&gt;Server-sent events(SSE)&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SSEとは、サーバーからクライアントへの一方向リアルタイム通信を実現する技術で、クライアントはJavaScriptのEventSourceというAPIを使い、サーバーからのイベントストリームを受け取る&#xA;&lt;ul&gt;&#xA;&lt;li&gt;普通のHTTPリクエストを送った後、サーバーが&lt;code&gt;Content-Type: text/event-stream&lt;/code&gt;でストリームを送り続ける&lt;/li&gt;&#xA;&lt;li&gt;あくまでMIMEタイプtextで、UTF-8エンコードされたテキストを配信するので、バイナリには向いてない（Base64エンコードしてテキストに変換して送ることは可能ではあるが、サイズ膨らむし非効率なので..）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SSEの考え方はチャンク転送と同じだが、レスポンスの返し方が少し異なる&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Content-Type: text/event-stream&lt;/code&gt;というヘッダが、SSEによる応答を表す&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ついでにConnection: keep-aliveも必要で、これはリクエストを受信したサーバがレスポンスを返した後も通信を持続させることをお願いするもの&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SSEでは、サーバから通知する情報をチャンクとして返すが、個々をイベントと呼ぶ&lt;/li&gt;&#xA;&lt;li&gt;イベントの連なりによって構成される応答全体を「イベント・ストリーム」と呼ぶ&lt;/li&gt;&#xA;&lt;li&gt;チャンク転送とは異なり、サーバーかクライアントのどちらかが通信を止めない限り、通信が続く&#xA;&lt;ul&gt;&#xA;&lt;li&gt;チャンク転送のような最後に0を送信して終わり合図みたいなものはないので、必要であれば終了を表す合図を決めても良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SSEの受信処理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;チャンク転送と異なり、受信側であるブラウザは標準APIで受信を簡単に処理できる（EventSourceオブジェクト）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SSEのメリット&#xA;&lt;ul&gt;&#xA;&lt;li&gt;標準APIで扱えるので、Comet等に比べると手軽に利用できる&lt;/li&gt;&#xA;&lt;li&gt;HTTPで通信するので、FWやプロキシなど通信経路上の機器の設定変更等が不要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;注意点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;多くのブラウザではサーバ側の負荷をかけない目的で、同一ドメインのサーバーに対する同時接続は6つまで&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SSEのサーバー側の送信処理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;レスポンス自体は簡単だが、内部処理は少し難しくなる&amp;hellip;&lt;/li&gt;&#xA;&lt;li&gt;サーバーがブラウザからリクエストを受信するとサーバーはイベントを送信し続ける必要があるが、その間にもサーバー側はToDoの取得や追加のリクエストを処理することができる&lt;/li&gt;&#xA;&lt;li&gt;ToDoの追加や更新があった時に、それをサーバー内部でSSEの送信処理に通知する必要がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これを実現するには「並行処理」という手法が必要で、この本で紹介されているサーバー実装はGoで書かれているため、ゴルーチンを起動し、チャネルでゴルーチン同士で情報伝達を行っている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;websocket&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#websocket&#34;&gt;WebSocket&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CometもSSEも、クライアントからリクエストを送信する必要があるというHTTP本来の性質は変わっておらず、双方向通信ができないという点やオーバーヘッド（TCP接続処理やヘッダ）が大きいという点に改善の余地があった&lt;/li&gt;&#xA;&lt;li&gt;そんな中生まれたのが双方向・高頻度・大量の通信を実現するWebSocketという新たなプロトコル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Comet、SSEはあくまで既存のHTTPに則っていたのに対し、ほとんど別のプロトコルとして作られた(httpではなくws)&lt;/li&gt;&#xA;&lt;li&gt;最初はHTTPで通信を始め、プロトコルアップグレードという仕組みでWebSocketに切り替える&lt;/li&gt;&#xA;&lt;li&gt;HTTPと比較すると、ヘッダ相当の情報のやり取りがなく、送受信に伴いオーバーヘッドがとても少ないのが特徴&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HTTPは毎回封筒に入れてやり取り、WebSocketは電話を繋げっぱなしでやり取りみたいなイメージ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;イメージは以下&#xA;&lt;ul&gt;&#xA;&lt;li&gt;((SSE), HTTP) &amp;mdash; TCP &amp;mdash; IP&lt;/li&gt;&#xA;&lt;li&gt;HTTP |→| WebSockets &amp;mdash; TCP &amp;mdash; IP&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;WebSocketのハンドシェイク&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通信を始める時のハンドシェイクでプロトコルアップグレードという仕組みを使用する&lt;/li&gt;&#xA;&lt;li&gt;これは簡単にいうと最初はHTTPで通信を開始し、ここから別の言葉で話しましょうと別のプロトコルに切り替えるもの&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HTTPリクエストヘッダに&lt;code&gt;Connection: Upgrade&lt;/code&gt;, &lt;code&gt;Upgrade: websocket&lt;/code&gt;を指定することで、クライアントがWebSocket通信を希望することがわかる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;WebSocket上でどのような通信をするかはアプリケーションに委ねられている&lt;/li&gt;&#xA;&lt;li&gt;WebSocket上での通信の取り決めは「サブプロトコル」といい、クライアントが希望するサブプロトコルを&lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt;ヘッダで通知できるようになっている&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Sec-WebSocket-Key&lt;/code&gt;ヘッダは、クライアントとサーバーが互いにWebSocketに対応していることを確認するためのもので、クライアントからはnonceと呼ばれるランダムに生成した文字列をセットする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サーバーからの応答&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クライアントからのアップグレード要求に対し、101を返す（その要求を了承したことを示す）&lt;/li&gt;&#xA;&lt;li&gt;クライアントから受け取った&lt;code&gt;Sec-WebSocket-Key&lt;/code&gt;の値(nonce)を、規定通りに変換した値をレスポンスヘッダ&lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt;にセットすることで、サーバーがWebSocketに対応していることを確認する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;規定通りに変換: nonceをSHA-1ハッシュ化→Base64エンコード&lt;/li&gt;&#xA;&lt;li&gt;秘匿性はないが、WebSocketではないサーバーに対して、WebSocket通信を始めてしまうような事故を防ぐため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;アップグレード後は常時接続となり、双方向にいつでもデータを送ることが可能となる（つまりサーバー側からのプッシュ配信も可能）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;プロトコルアップグレードの必要性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一般的なサーバ側のセキュリティ設定として80番/443番ポートを防ぐことが多く、仮にWebSocketが別のポートを使用してしまうと、経路の途中で遮断されてしまう可能性があるため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;WebSocketの課題&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SSEと同じようにTCPコネクションが接続しっぱなしになるので、ブラウザ側の同時接続数の制限を受けることもあるし、サーバー側もより多くのクライアントから接続を受け付ける必要がある&lt;/li&gt;&#xA;&lt;li&gt;あくまでHTTPのフリをしているため、ハンドシェイク以降の通信はHTTPではないため、プロキシの処理内容によっては遮断されてしまうことがある&lt;/li&gt;&#xA;&lt;li&gt;プロキシサーバーがある環境では、プロキシサーバーが仲介する通信はHTTP前提で作られていることが多いので、ハンドシェイク以降の通信ができなくなる可能性がある&lt;/li&gt;&#xA;&lt;li&gt;負荷分散の問題: 1つのサーバーと長時間のTCP接続を行うと、均等に負荷分散されず、特定のサーバーに偏る可能性がある&lt;/li&gt;&#xA;&lt;li&gt;認証の問題&#xA;&lt;ul&gt;&#xA;&lt;li&gt;認証の（標準的な）仕組みがない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;そのため、アプリケーション側で実装してあげる必要がある&lt;/li&gt;&#xA;&lt;li&gt;具体的には、WebSocketの通信ではHTTPヘッダーを送らないので、最初の通信でJWTを送るとかいう形で、アプリケーション側で独自実装する形となる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;同一オリジンポリシーの制約がない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;このようになっている背景として、WebSocketは、WebアプリだけではなくネイティブアプリやIoT機器からの接続も想定されているため、Webブラウザ限定のSOPルールに縛られない仕様になっているみたい&lt;/li&gt;&#xA;&lt;li&gt;対策としては、サーバー側でOriginヘッダを検証する必要がある（Originヘッダはブラウザが自動的に付与するのでJSで改変することはできない）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;sseとwebsocketの使い分け&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#sse%e3%81%a8websocket%e3%81%ae%e4%bd%bf%e3%81%84%e5%88%86%e3%81%91&#34;&gt;SSEとWebSocketの使い分け&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;※これは個人的に気になったことのメモ&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SSEが向いているケース&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ニュース速報配信・株価リアルタイム表示・SNSの新着投稿ありの通知&lt;/li&gt;&#xA;&lt;li&gt;つまり、サーバーからの一方向の通信でテキスト情報をやり取りしたいシーンで採用される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;WebSocketが向いているケース&#xA;&lt;ul&gt;&#xA;&lt;li&gt;チャット、ゲームなどの画像のストリーミングや音声のリアルタイム配信などが向いている&lt;/li&gt;&#xA;&lt;li&gt;つまり、双方向・低レイテンシー・バイナリ対応が求められるシーンで採用される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;付録&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#%e4%bb%98%e9%8c%b2&#34;&gt;付録&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;2進数と16進数&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#2%e9%80%b2%e6%95%b0%e3%81%a816%e9%80%b2%e6%95%b0&#34;&gt;2進数と16進数&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;16進数を表記する場合は先頭に0x（ゼロエックス）をつける&lt;/li&gt;&#xA;&lt;li&gt;16進数はHEXと表現することもある&lt;/li&gt;&#xA;&lt;li&gt;16進数は4ビットを1桁で表現できるので、4ビット単位で区切って簡潔に表現できたり、2桁でバイト単位を表現できたりとできたりと2進数との相性が良い&lt;/li&gt;&#xA;&lt;li&gt;16進数がよく使われるシーン&#xA;&lt;ul&gt;&#xA;&lt;li&gt;文字コード&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パーセントエンコーディングやUnicodeのコードポイント表記&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;カラーコード&lt;/li&gt;&#xA;&lt;li&gt;IPv6アドレス&lt;/li&gt;&#xA;&lt;li&gt;MACアドレス&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;テキストとバイナリ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#%e3%83%86%e3%82%ad%e3%82%b9%e3%83%88%e3%81%a8%e3%83%90%e3%82%a4%e3%83%8a%e3%83%aa&#34;&gt;テキストとバイナリ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンピュータ内部での文字列は数字に割り当てられる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えばAであれば「65」&lt;/li&gt;&#xA;&lt;li&gt;この対応は、ASCIIと呼ばれ、アメリカの国内規格として制定されたので、この対応表に含まれるのは大小アルファベットと数字といくつかの記号のみ&lt;/li&gt;&#xA;&lt;li&gt;ASCII文字は95種類しかないので、1バイトの範囲に十分収まる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;テキストデータの符号化方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンピュータで文字を数値として表現することを「符号化方式」という&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;現在はUTF-8という符号化方式に統一されている&lt;/li&gt;&#xA;&lt;li&gt;HTTPではテキストデータでやり取りされており、人間が見て理解しやすいというメリットがある一方、通信効率が悪いというデメリットがある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;文字コード&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#%e6%96%87%e5%ad%97%e3%82%b3%e3%83%bc%e3%83%89&#34;&gt;文字コード&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;現代のコンピュータは、世界中の文字を扱えるようになっているため、文字コードの仕組みや体系は複雑になっている&lt;/li&gt;&#xA;&lt;li&gt;日本国内では、日本語を取り扱う文字コードとして「Shift_JIS」が主流だったが、WWWの普及と世界中のコンピュータが情報を交換するようになり、単一の文字コード体系で世界中の文字を扱えるようになる必要が出てきたが、現在はUnicodeという体系に統一されている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;utf-8とunicodeについて&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#utf-8%e3%81%a8unicode%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6&#34;&gt;UTF-8とUnicodeについて&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Unicodeは、文字の番号表（この文字はU+XXXXだというやつ）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;世界中の文字に通し番号を振った辞書&lt;/li&gt;&#xA;&lt;li&gt;元々は各国独自で文字コードを作っていた（日本はShift_JIS）が、異なる国の文字が混ざったときに文字化けが発生するので、世界共通のUnicodeに統一された&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;UTF-8は、符号化方式の1つでであり、その番号(U+XXXX)をバイト列に変換するルール&#xA;&lt;ul&gt;&#xA;&lt;li&gt;UTF＝Unicode Transformation Format Unicodeコードポイントを変換するフォーマット・ルールのこと&lt;/li&gt;&#xA;&lt;li&gt;バイト列: 複数バイトが連なったもの（01100001 01100010 01100011（= &amp;ldquo;abc&amp;rdquo;））&lt;/li&gt;&#xA;&lt;li&gt;軽さや処理効率に応じてUTF-16や32があるが、Webでは軽さ重視のためUTF-8が採用されることが多い（多分ネットワーク経由でやり取りするときに少ないバイト列で表現できた方がデータ量が削減できるからという意味だと思う＋UTF-8は、複数バイトの順番をどう並べるかのビッグ/リトルエンディアンを気にしなくて良いという理由もある）&lt;/li&gt;&#xA;&lt;li&gt;UTF-8では、英数(ASCII文字)は1バイト、日本語は3バイトとなっている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;文字境界の判別＝どこからどこまでを1文字とするかは、先頭のビットパターンで区別している（1バイト文字なら先頭ビットが&lt;code&gt;0&lt;/code&gt;,2バイト文字なら先頭ビットが&lt;code&gt;110&lt;/code&gt;&amp;hellip;）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;大前提として、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ネットワークは光のON/OFF、ストレージはセルがチャージされているかどうか、つまり0か1というビット単位でしか処理ができない（ハードウェアレイヤの都合）&lt;/li&gt;&#xA;&lt;li&gt;じゃあビットでやり取りすれば良いじゃんという話だが、それでは処理効率が悪い&lt;/li&gt;&#xA;&lt;li&gt;だからコンピュータ内部（CPUやメモリ等）では8ビットを1バイトを最小単位として処理するように設計されている&lt;/li&gt;&#xA;&lt;li&gt;1バイト＝8ビットである理由は、2の8乗＝256通りであり、英数字などを扱うのにちょうどよかったため&lt;/li&gt;&#xA;&lt;li&gt;これに伴い、通信プロトコルとかでも1バイト単位で送信するようになっている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;UnicodeとUTF-8の役割&#xA;&lt;ul&gt;&#xA;&lt;li&gt;まずコンピュータにはUnicodeの文字と番号が紐づいた表があり、番号から文字を割り出して、実際に文字を表示している&lt;/li&gt;&#xA;&lt;li&gt;じゃあその番号はどのように出されるかというと、ネットワークやストレージを介したデータはバイト列で通信・保存されているので、そのバイト列からデコード処理を行なって番号を割り出している&lt;/li&gt;&#xA;&lt;li&gt;じゃあそのバイト列は？という部分は、UTF-8なりで符号化（エンコードしてバイト列に変換）を行われているものになる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HTTPでやりとりするときやHTMLでは、&lt;code&gt;Content-Type&lt;/code&gt;でcharsetを指定することで、中身はこのルール(符号化方式)でエンコードしているよということを伝えている&lt;/li&gt;&#xA;&lt;li&gt;それを見て、コンピュータ側でデコード処理をしている（デコード結果の番号からUnicodeの表を見て、人間がわかる文字を表示している）&lt;/li&gt;&#xA;&lt;li&gt;ファイル周りではBOM(Byte Order Mark)をつけることで、このファイルは何のエンコードだよという&#xA;&lt;ul&gt;&#xA;&lt;li&gt;WindowsのExcelでファイルを開く場合、これがないとShift_JISと誤認されて、文字化けが発生する可能性がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;符号化文字集合&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#%e7%ac%a6%e5%8f%b7%e5%8c%96%e6%96%87%e5%ad%97%e9%9b%86%e5%90%88&#34;&gt;符号化文字集合&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;現在コンピュータで扱える文字数は約15万&lt;/li&gt;&#xA;&lt;li&gt;基本的にはASCIIと同じで、一つ一つの文字に数字を割り当てて識別している&lt;/li&gt;&#xA;&lt;li&gt;「符号化文字集合」というのは、扱える文字の集合（ASCIIなら英数）の中で、識別用の数値を割り振ったもの&#xA;&lt;ul&gt;&#xA;&lt;li&gt;つまり、そのままだが「文字集合を符号化したもの」&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;「符合位置（コードポイント）」と言うのが、その個々の文字を示す数値のこと&lt;/li&gt;&#xA;&lt;li&gt;符号化文字集合は「文字コード」呼ばれることが多いが、文字コード自体が文脈によって様々な意味を持つので、正確に表現すると「符号化文字集合」となる&lt;/li&gt;&#xA;&lt;li&gt;20世紀後半までは、各国や地域が独自にしており、Unicodeが普及するまでは統一されていなかった&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;フォント&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#%e3%83%95%e3%82%a9%e3%83%b3%e3%83%88&#34;&gt;フォント&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;符号化文字集合は、単なる対応表なので、実際に表示・印刷するには「フォント」が必要となる&lt;/li&gt;&#xA;&lt;li&gt;同じ文字コードでもフォントが異なれば見た目も異なる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;unicode&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#unicode&#34;&gt;Unicode&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;WWWやソフトウェアの普及により、世界で共通で使える文字コードが良いねとなり、それが今でも使われている「Unicode」である&lt;/li&gt;&#xA;&lt;li&gt;当初Unicodeは2バイトで世界の全ての文字を表現しようとしたが、それでは足りないことが発覚し、拡張された&lt;/li&gt;&#xA;&lt;li&gt;毎年更新されている&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;U+7DB2&lt;/code&gt;のようなU+で始まり16進数の形でコードポイントを表記する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;文字符号化方式エンコーディング&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#%e6%96%87%e5%ad%97%e7%ac%a6%e5%8f%b7%e5%8c%96%e6%96%b9%e5%bc%8f%e3%82%a8%e3%83%b3%e3%82%b3%e3%83%bc%e3%83%87%e3%82%a3%e3%83%b3%e3%82%b0&#34;&gt;文字符号化方式(エンコーディング)&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Unicodeの登場により、単一の体系で文字が表現できるようになった&lt;/li&gt;&#xA;&lt;li&gt;ただUnicodeのコードポイントをそのまま列挙するとメモリ効率が悪いという問題がある&lt;/li&gt;&#xA;&lt;li&gt;Unicodeの範囲は&lt;code&gt;U+0000&lt;/code&gt;~&lt;code&gt;U+10FFFF&lt;/code&gt;で、21ビットある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;「A」はUnicodeでもASCIIと同じ&lt;code&gt;U+00041&lt;/code&gt;であり、利用頻度の高い文字が比較的前半に配置されている&lt;/li&gt;&#xA;&lt;li&gt;なので列挙すると、&lt;code&gt;U+00041``U+00042&lt;/code&gt;のようにゼロが多くなってしまうことが多い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;そこでUnicodeでは、テキストデータの保存や交換用に、コードポイントを少し変形した形で表現する&lt;/li&gt;&#xA;&lt;li&gt;その代表的なのが「UTF-8」である（Unicode Transformation Format）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;UTF-8は、ASCIIと同じU+0000~U+007Fの範囲は1バイトで表し、それ以外の範囲はものによっては、2〜4バイトで表現する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;このようにすることでASCIIとの互換性を持たせるためで、ASCII文字だけで構成されるテキストデータはUTF-8でも同じデータになるため、使い勝手が良くなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;文字符号化方式はなぜ生まれたか&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#%e6%96%87%e5%ad%97%e7%ac%a6%e5%8f%b7%e5%8c%96%e6%96%b9%e5%bc%8f%e3%81%af%e3%81%aa%e3%81%9c%e7%94%9f%e3%81%be%e3%82%8c%e3%81%9f%e3%81%8b&#34;&gt;文字符号化方式はなぜ生まれたか&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;背景として、コンピュータが扱うべき文字が増加したというのがある&lt;/li&gt;&#xA;&lt;li&gt;ASCII時代は、扱う文字が少なかったため、符号化文字集合と符号化文字方式を区別する必要がなく、単に文字コードと言われていた&lt;/li&gt;&#xA;&lt;li&gt;しかしWWWの普及により、さまざまな体系の文字コードを扱う必要が生じ、符号化文字集合と符号化文字方式を分けて考えるようになった&lt;/li&gt;&#xA;&lt;li&gt;UTF-8が登場する前は、Shift_JISやEUC-JPというような文字符号化方式があり、対象とする文字符号化集合はいずれもJIS X 0208であった&lt;/li&gt;&#xA;&lt;li&gt;筆者の考えとして「文字コード」という言葉が両者それぞれを指すことがあるのは上記のような流れからだと考えているそう（どちらを指しているかは会話の文脈で変わる）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;改行コード&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#%e6%94%b9%e8%a1%8c%e3%82%b3%e3%83%bc%e3%83%89&#34;&gt;改行コード&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;文字コードには、目に見える文字だけではなく、画面表示を制御する「制御文字」もある&lt;/li&gt;&#xA;&lt;li&gt;改行コードもその1種で、歴史的背景から「CR+LF」(Windows)と「LF」(MacやLinux)の2パターンがある&lt;/li&gt;&#xA;&lt;li&gt;やり取りする双方で改行コードを取り決めておく必要がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;まとめ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/008_%E6%94%B9%E8%A8%82%E6%96%B0%E7%89%88%E3%83%97%E3%83%AD%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEweb%E6%8A%80%E8%A1%93%E5%85%A5%E9%96%80/#%e3%81%be%e3%81%a8%e3%82%81&#34;&gt;まとめ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンピュータの世界では、あらゆる文字とそれの対比となるコードポイントを符号化文字集合（Unicode）という形で、あらゆる文字を取り扱えるようにしている&lt;/li&gt;&#xA;&lt;li&gt;そのコードポイントをどう画面に表示するというのは、フォントデータとして保持している&lt;/li&gt;&#xA;&lt;li&gt;Unicodeは、コンピュータが保存・通信を行う時のメモリ効率が良くないという課題がある&lt;/li&gt;&#xA;&lt;li&gt;その課題を解消するのが、文字符号化方式（エンコーディング）であり、代表としてUTF-8がある&lt;/li&gt;&#xA;&lt;li&gt;つまりコンピュータがテキストファイルを保存したり、テキストデータを通信する時は、UTF-8エンコーディングした状態のものが扱っている（メモリ効率のため）&lt;/li&gt;&#xA;&lt;li&gt;つまり逆にそれを開いたり、受け取るときは同じ方式でデコードする必要がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これが異なると文字化けする&lt;/li&gt;&#xA;&lt;li&gt;防ぐために、HTTPヘッダを使用して相手に伝えたりしている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>システム設計の面接試験</title>
      <link>http://localhost:1313/posts/012_%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88%E3%81%AE%E9%9D%A2%E6%8E%A5%E8%A9%A6%E9%A8%93/</link>
      <pubDate>Thu, 08 May 2025 23:37:16 +0900</pubDate>
      <guid>http://localhost:1313/posts/012_%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88%E3%81%AE%E9%9D%A2%E6%8E%A5%E8%A9%A6%E9%A8%93/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;1章-ユーザー数ゼロから数百万人へのスケールアップ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/012_%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88%E3%81%AE%E9%9D%A2%E6%8E%A5%E8%A9%A6%E9%A8%93/#1%e7%ab%a0-%e3%83%a6%e3%83%bc%e3%82%b6%e3%83%bc%e6%95%b0%e3%82%bc%e3%83%ad%e3%81%8b%e3%82%89%e6%95%b0%e7%99%be%e4%b8%87%e4%ba%ba%e3%81%b8%e3%81%ae%e3%82%b9%e3%82%b1%e3%83%bc%e3%83%ab%e3%82%a2%e3%83%83%e3%83%97&#34;&gt;1章 ユーザー数ゼロから数百万人へのスケールアップ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;NoSQLを選択するケース&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アプリケーションに超低遅延が必要な場合&lt;/li&gt;&#xA;&lt;li&gt;非構造化データを扱う場合&lt;/li&gt;&#xA;&lt;li&gt;リレーショナルデータがない場合&lt;/li&gt;&#xA;&lt;li&gt;データのシリアライズとデシリアライズだけが必要な場合(JSON,YAML等)&lt;/li&gt;&#xA;&lt;li&gt;大量データの保存が必要な場合&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;シャーディング&#xA;&lt;ul&gt;&#xA;&lt;li&gt;水平スケーリングを実現&lt;/li&gt;&#xA;&lt;li&gt;ユーザーID % 4というハッシュ関数を元にサーバーを振り分けている&lt;/li&gt;&#xA;&lt;li&gt;この場合ユーザーIDがシャーディングキーとなり、シャーディングキーはどうするかは重要な戦略&lt;/li&gt;&#xA;&lt;li&gt;ただシャーディングにはいくつかの問題がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;データ量の偏りや特定シャードに負荷がかかり、再シャードが必要になる→解決方法として一貫性ハッシュがよく使われる&lt;/li&gt;&#xA;&lt;li&gt;セレブ問題といわれる特定シャードに過負荷がかかる&lt;/li&gt;&#xA;&lt;li&gt;シャード間でのジョイン操作が難しい。対策としては非正規化して単一テーブルで実行できるようにする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;この章では一部非リレーショナルな機能はNoSQLを採用し、RDBへの負荷を軽減&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;感想&#xA;&lt;ul&gt;&#xA;&lt;li&gt;この章はアプリケーションにおける各レイヤの基本的なスケール戦略が紹介されていて良かった&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;2章-おおまかな見積もり&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/012_%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88%E3%81%AE%E9%9D%A2%E6%8E%A5%E8%A9%A6%E9%A8%93/#2%e7%ab%a0-%e3%81%8a%e3%81%8a%e3%81%be%e3%81%8b%e3%81%aa%e8%a6%8b%e7%a9%8d%e3%82%82%e3%82%8a&#34;&gt;2章 おおまかな見積もり&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;</description>
    </item>
    <item>
      <title>認証認可まとめ</title>
      <link>http://localhost:1313/posts/matome/</link>
      <pubDate>Sat, 03 May 2025 11:24:57 +0900</pubDate>
      <guid>http://localhost:1313/posts/matome/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/matome/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;認証認可についての知識が散らかりがちなので調べたことをメモ（随時更新）&lt;/p&gt;&#xA;&lt;p&gt;MDNに良い感じにまとめてあった。&#xA;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/HTTP/Authentication&#34;&gt;HTTP 認証 - HTTP | MDN&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;認証認可を実現する技術と仕様&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/matome/#%e8%aa%8d%e8%a8%bc%e8%aa%8d%e5%8f%af%e3%82%92%e5%ae%9f%e7%8f%be%e3%81%99%e3%82%8b%e6%8a%80%e8%a1%93%e3%81%a8%e4%bb%95%e6%a7%98&#34;&gt;認証認可を実現する技術と仕様&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ID/パスワード&lt;/li&gt;&#xA;&lt;li&gt;SAML&lt;/li&gt;&#xA;&lt;li&gt;OAuth&lt;/li&gt;&#xA;&lt;li&gt;OpenID Connect&lt;/li&gt;&#xA;&lt;li&gt;JWT&lt;/li&gt;&#xA;&lt;li&gt;MFA&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;basic認証&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/matome/#basic%e8%aa%8d%e8%a8%bc&#34;&gt;Basic認証&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;usernameとpasswordをBase64エンコードしてHTTPヘッダのAuthorizationに設定する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リクエストのたびにパスワードを送信する形&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;実装が簡単（ヘッダの値をセット・検証するだけ）&lt;/li&gt;&#xA;&lt;li&gt;しかし盗聴されるとBase64デコードすることで元の値が見れてしまうのでセキュリティ性は低くない&lt;/li&gt;&#xA;&lt;li&gt;Basic認証を採用する場合はHTTPS化することが推奨される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ダイジェスト認証&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/matome/#%e3%83%80%e3%82%a4%e3%82%b8%e3%82%a7%e3%82%b9%e3%83%88%e8%aa%8d%e8%a8%bc&#34;&gt;ダイジェスト認証&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Basic認証の改良版&lt;/li&gt;&#xA;&lt;li&gt;サーバが生成したランダムの文字列をパスワードに付与し、IDとパスワードをMD5でハッシュ化して送信&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これもリクエストのたびにパスワードを送信する形&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サーバ側でも登録済みの認証情報をハッシュ化し、照合することで認証する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;セッションベース認証&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/matome/#%e3%82%bb%e3%83%83%e3%82%b7%e3%83%a7%e3%83%b3%e3%83%99%e3%83%bc%e3%82%b9%e8%aa%8d%e8%a8%bc&#34;&gt;セッションベース認証&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リクエストの度にパスワード等を送る(Basic/ダイジェスト認証)のは良くないので、サーバー側でログイン済み情報を保持する「セッション」という仕組みが誕生&lt;/li&gt;&#xA;&lt;li&gt;セッションは、このユーザーはこのセッションという情報を保持しているので「ステートフル」と言える（サーバーが状態を持っている）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバー側で強制ログアウトや履歴管理が可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;クライアント側では、セッションID的なものをCookieで保持することが多い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Cookieで保持することが多い理由&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クライアント側はセッションIDだけを知っていれば良い&lt;/li&gt;&#xA;&lt;li&gt;セッションIDをCookieに保存しておけば、ブラウザが自動で送信してくれる（フロントエンドがセッションの存在を意識しなくて良い）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;jwt認証&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/matome/#jwt%e8%aa%8d%e8%a8%bc&#34;&gt;JWT認証&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JSON Web Tokeの略で、クライアントとサーバー間で認証等の情報を安全にやりとりするための標準規格&lt;/li&gt;&#xA;&lt;li&gt;JWTには、ヘッダー（トークン種類や署名アルゴリズム）とペイロード（ユーザーID、有効期限、ロール等）と署名（ヘッダとペイロードを暗号鍵で署名し、改竄されていないことを保証する）&lt;/li&gt;&#xA;&lt;li&gt;JWTはトークンに全ての情報（ユーザーIDや期限など）を持っているので「ステートレス」な認証と言える&lt;/li&gt;&#xA;&lt;li&gt;サーバーは、クライアントから送られてきたトークンを検証するだけなので、DBやセッションを見に行く必要はない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;その代わり、サーバ側で保持していない＝一度発行したトークンをサーバ側で無効化するみたいなことはできない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;JWTは、LocalStorageで保持することが多い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;LocalStorageで保持することが多い理由&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JWTは、Authorizationヘッダにセットする（自動送信されるCookieとは異なり、リクエストごとにセットする必要がある）&lt;/li&gt;&#xA;&lt;li&gt;つまり、ブラウザで保持しているトークンを何かしらの形で、リクエストに含める必要がある&lt;/li&gt;&#xA;&lt;li&gt;そうなると、JSからアクセスできる場所が都合良いので、LocalStorageに保存することが多い（CookieにHttpOnly属性が付与されているとJSから読み取れないため）&lt;/li&gt;&#xA;&lt;li&gt;結果、SPAやCSR前提のアプリケーションで採用されるケースが多い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;JSからアクセスできるということはXSSのリスクがある（CookieはHttpOnly属性を防げる）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;LocalStorageにあるトークンを盗まれてしまうリスクがある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;最近ではJWTをCookieに保存するケースもある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;セッション-vs-jwt&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/matome/#%e3%82%bb%e3%83%83%e3%82%b7%e3%83%a7%e3%83%b3-vs-jwt&#34;&gt;セッション vs JWT&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;※保存場所(Cookie vs LocalStorage)の話も含む&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバーとクライアント結合度合い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Cookieは、ブラウザ前提とした設計になりがち&lt;/li&gt;&#xA;&lt;li&gt;Authorizationヘッダでトークン送る形式(JWT)は、ブラウザ以外（例：モバイルアプリ）でも使用できる&lt;/li&gt;&#xA;&lt;li&gt;つまり、Cookieを使用するとサーバーとクライアント(種類)の依存度が強まってしまう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CORS制御の面倒度合い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;APIとフロントが別ドメインである場合、CORS設定が面倒（Cookie送るのにcredentials: &amp;lsquo;include&amp;rsquo;が必要、SameSite設定）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;スケーリング&#xA;&lt;ul&gt;&#xA;&lt;li&gt;セッションは、サーバー側で保持されるのでスケーリングに不向き&lt;/li&gt;&#xA;&lt;li&gt;ただし昨今はデータストアに置くケースが多いのであまり考えなくて良いかも&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;トークンを強制的に無効化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;セッションは消せば良いのでサーバー側で可能(サーバー側が中央集権的に管理できる)&lt;/li&gt;&#xA;&lt;li&gt;JWTはできない・・・？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;クライアント側での考慮&#xA;&lt;ul&gt;&#xA;&lt;li&gt;セッションはCookieにさえセットされていれば自動で送信されるのでクライアント側での考慮が必要ない&lt;/li&gt;&#xA;&lt;li&gt;また、CookieはSSRやHTMLフォームとの相性が良い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SSRで初回リクエストした時、Cookieなら自動で送信されるため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;クライアント側でのログイン状態管理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SPAなどではログイン状態をクライアント側で保持・制御するケースが多く、JWTの方が向いている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;未ログイン状態ではログインボタンを表示するというような制御&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;一方、SSRのシステムでは、サーバー側でログイン状態を判断し、HTMLを返却しているので、クライアント側では基本的にログイン状態を持たない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;マイクロサービス&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバーが異なっていても送りやすいJWTが向いている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;結論&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/matome/#%e7%b5%90%e8%ab%96&#34;&gt;結論&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;p&gt;アプリケーションの作り方でどちらを採用するかを決めるのが良いか？（私見）&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SSR前提のアプリケーション：セッション&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SSR初回リクエスト/HTMLフォーム送信時にCookieに送ってくれるのは大きい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SPA：トークンベース（JWT）&lt;/li&gt;&#xA;&lt;li&gt;ハイブリッド構成(SSR/CSR)：セッション&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;サーバー側で認証認可に関連する情報を保持する方法&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/matome/#%e3%82%b5%e3%83%bc%e3%83%90%e3%83%bc%e5%81%b4%e3%81%a7%e8%aa%8d%e8%a8%bc%e8%aa%8d%e5%8f%af%e3%81%ab%e9%96%a2%e9%80%a3%e3%81%99%e3%82%8b%e6%83%85%e5%a0%b1%e3%82%92%e4%bf%9d%e6%8c%81%e3%81%99%e3%82%8b%e6%96%b9%e6%b3%95&#34;&gt;サーバー側で認証認可に関連する情報を保持する方法&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;セッション&#xA;&lt;ul&gt;&#xA;&lt;li&gt;データベースやRedisなどの外部ストレージに保存する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;クライアント側で認証認可に関連する情報を保持する方法&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/matome/#%e3%82%af%e3%83%a9%e3%82%a4%e3%82%a2%e3%83%b3%e3%83%88%e5%81%b4%e3%81%a7%e8%aa%8d%e8%a8%bc%e8%aa%8d%e5%8f%af%e3%81%ab%e9%96%a2%e9%80%a3%e3%81%99%e3%82%8b%e6%83%85%e5%a0%b1%e3%82%92%e4%bf%9d%e6%8c%81%e3%81%99%e3%82%8b%e6%96%b9%e6%b3%95&#34;&gt;クライアント側で認証認可に関連する情報を保持する方法&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;LocalStorage&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;実装は楽(setItemとかremoveItemなどのAPIを実行するだけ)&lt;/li&gt;&#xA;&lt;li&gt;一方、JavaScriptを使用するのでXSSで盗まれる可能性がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Cookie&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HTTP Onlyを属性を付加することでJavaScriptからの操作を無効にできる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;インメモリ&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JavaScriptでブラウザのメモリ内に保存する(クロージャに入れるとかするイメージ)&lt;/li&gt;&#xA;&lt;li&gt;リロードするとログアウト状態になる、タブ間でログイン状態が共有されないなどの問題がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Auth0&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Silent Authenticationという仕組みがある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;インメモリ形式で実装しているが、リロード時にログアウトしてしまう問題がないのが利点&lt;/li&gt;&#xA;&lt;li&gt;実際の仕組みとしては、HTMLのiframeタグを駆使している&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;認証基盤のロックインや一定規模が超えた場合に課金が発生するという課題はある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;参考&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://logmi.jp/main/technology/324349&#34;&gt;認証用トークン保存先の第4選択肢としての「Auth0」 | ログミーBusiness&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;読みたい記事や見たい動画&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.docswell.com/s/ockeghem/ZM6VNK-phpconf2021-spa-security&#34;&gt;SPAセキュリティ入門～PHP Conference Japan 2021 | ドクセル&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PLWiFLcGkQgLx8lbno3zZEinqu5C19hwET&#34;&gt;Cookieにまつわるセキュリティ - YouTube&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;認証技術&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/matome/#%e8%aa%8d%e8%a8%bc%e6%8a%80%e8%a1%93&#34;&gt;認証技術&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/matome/#&#34;&gt;&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/matome/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/HTTP/Authentication&#34;&gt;HTTP 認証 - HTTP | MDN&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>フォント</title>
      <link>http://localhost:1313/posts/font/</link>
      <pubDate>Wed, 30 Apr 2025 07:20:59 +0900</pubDate>
      <guid>http://localhost:1313/posts/font/</guid>
      <description>&lt;p&gt;FEの開発で特定の端末でのみ、英語の文字が太字にならないという問題が発生した。&lt;br&gt;&#xA;この問題に対処した上でフォント周りを調べたので雑にメモを残しておく。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;フォントとは反映されるまでの流れ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/font/#%e3%83%95%e3%82%a9%e3%83%b3%e3%83%88%e3%81%a8%e3%81%af%e5%8f%8d%e6%98%a0%e3%81%95%e3%82%8c%e3%82%8b%e3%81%be%e3%81%a7%e3%81%ae%e6%b5%81%e3%82%8c&#34;&gt;フォントとは？＋反映されるまでの流れ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;フォントの実態は.woff2のようなファイルに、CMAPテーブルというそのフォントがどのUnicodeに対応しているかをものがある&lt;/li&gt;&#xA;&lt;li&gt;DOM構築時にUnicodeを取得し、CMAPテーブルをチェックし、フォントを確定&lt;/li&gt;&#xA;&lt;li&gt;そのフォントを使って描画する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;フォントの種類とか&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/font/#%e3%83%95%e3%82%a9%e3%83%b3%e3%83%88%e3%81%ae%e7%a8%ae%e9%a1%9e%e3%81%a8%e3%81%8b&#34;&gt;フォントの種類とか&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;※実際にどのようなフォントをあてるかはCSSのfont-familyで指定される&lt;/p&gt;&#xA;&lt;p&gt;まずフォントには、どこにあるかの場所により大きく2分できる&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ローカルフォント&lt;/li&gt;&#xA;&lt;li&gt;Webフォント&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;ローカルフォントはそのままで私たちが触っている携帯やPC等にあるやつ。&lt;br&gt;&#xA;Webフォントは、Web経由で配信されているフォントのこと（Google Fontsとかが有名）&lt;/p&gt;&#xA;&lt;p&gt;その上で、Noto Sans JPやRobot, sans-serifのようなフォント種類がある。&lt;br&gt;&#xA;sans-serifは、汎用フォントファミリであり、serif(飾り)がsans(フランス語で「無い」という意味)という意味。実際の具体のフォント名ではなく「飾りがない」フォントをあててねというものであり、実際にどのフォントがあたるかは環境によって異なる。&lt;/p&gt;&#xA;&lt;p&gt;あとはフォントの種類によって、日本語に対応しているもの・そうでないものとかある。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;webフォント&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/font/#web%e3%83%95%e3%82%a9%e3%83%b3%e3%83%88&#34;&gt;Webフォント&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Webフォントを指定することで、ユーザーの環境に依存することなく、統一のフォントをあてることができる。その一方で、ページ描画時にフォントダウンロードが発生するデメリットがある（フォントは長い時間キャッシュされることが多いのでそこまで大きな問題にならないが）&lt;br&gt;&#xA;※Webフォントは、headタグ内のlinkタグで指定される（CSSとかと同様に読み込み時にダウンロードが走る）&lt;/p&gt;&#xA;&lt;p&gt;雑に使ってしまうと容量大きくなるので、日本語だけ取得するサブセット化すると、サイズ縮小できる。&lt;/p&gt;&#xA;&lt;p&gt;[追記]&#xA;以下のパフォーマンスチューニングのスライドでは、ウェブセーフフォント(sans-serif等)使うのが良いと書かれている。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/cp20/shi-jian-webhurontopahuomansutiyuningu?slide=72&#34;&gt;https://speakerdeck.com/cp20/shi-jian-webhurontopahuomansutiyuningu?slide=72&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;nextfont-nextjsでのアプローチ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/font/#nextfont-nextjs%e3%81%a7%e3%81%ae%e3%82%a2%e3%83%97%e3%83%ad%e3%83%bc%e3%83%81&#34;&gt;next/font: Next.jsでのアプローチ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;next/fontとは？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://nextjs.org/docs/app/building-your-application/optimizing/fonts&#34;&gt;最適化: フォント | Next.js&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;上記にあるが、next/fontというフォント最適化の仕組みがある。これはセルフホスティングされるので、ユーザーが表示時に外部サイトからフォントダウンロードが走る・レイアウトズレが生じるというようなことを発生を抑制できる。&lt;br&gt;&#xA;セルフホスティングとは、ビルド(next build)を実行するとビルド結果にwoff2ファイルが含まれる（ビルド時にフォントダウンロードしてくれる）つまり、ブラウザからGoogle等のフォント配信先へのリクエストが走らないようになる。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;セルフホスティング-vs-従来のwebフォントインストール&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/font/#%e3%82%bb%e3%83%ab%e3%83%95%e3%83%9b%e3%82%b9%e3%83%86%e3%82%a3%e3%83%b3%e3%82%b0-vs-%e5%be%93%e6%9d%a5%e3%81%aeweb%e3%83%95%e3%82%a9%e3%83%b3%e3%83%88%e3%82%a4%e3%83%b3%e3%82%b9%e3%83%88%e3%83%bc%e3%83%ab&#34;&gt;セルフホスティング vs 従来のWebフォントインストール&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;※従来のWebフォントインストール: headタグのlinkタグでフォント配信先URLを指定&lt;/p&gt;&#xA;&lt;p&gt;結局どちらもブラウザからすると、ネットワーク経由のリクエスト/レスポンスが発生するからそこまでセルフホスティングにメリットがあるのか？を調べてみた。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DNSルックアップやTLSハンドシェイクが外部サーバーに対して不要になる(セキュリティ性向上？)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;冒頭の問題解決方法&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/font/#%e5%86%92%e9%a0%ad%e3%81%ae%e5%95%8f%e9%a1%8c%e8%a7%a3%e6%b1%ba%e6%96%b9%e6%b3%95&#34;&gt;冒頭の問題解決方法&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;冒頭述べた問題に対しては以下の対処を行なった。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Webフォントを採用&lt;/li&gt;&#xA;&lt;li&gt;font-weightを一般的な400,700を採用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;まず表示する端末に依存することを避けるためWebフォントを使うことにした。&lt;br&gt;&#xA;また、今回プロジェクトで使用されていたfont-weightの太字にあたる値が600であったため、一般的な太字の700と異なり、これがそもそも特定の端末で太字にならない本あの原因だった説が高い。ので、一般的な400,700という値を統一して使用することにした（フォントが同じでも太さが異なると、フォントファイルも違うという学びも得られた）&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>CSRF(Cross Site Request Forgery)</title>
      <link>http://localhost:1313/posts/csrf/</link>
      <pubDate>Mon, 28 Apr 2025 23:15:14 +0900</pubDate>
      <guid>http://localhost:1313/posts/csrf/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;csrfとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/csrf/#csrf%e3%81%a8%e3%81%af&#34;&gt;CSRFとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;認証済みユーザーが勝手にリクエストを送られる&lt;/li&gt;&#xA;&lt;li&gt;例えば、A銀行のサイトがあり、Cookieにセッションを保持した状態で、別の悪意あるサイトに遷移した際に勝手にそのセッションを用いて、A銀行サーバーにリクエストを送ってしまう（勝手に送金されるとか..）&lt;/li&gt;&#xA;&lt;li&gt;Forgeryは「偽造」という意味&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;対策&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/csrf/#%e5%af%be%e7%ad%96&#34;&gt;対策&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;リクエスト元を制御-cookieのsamesite属性&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/csrf/#%e3%83%aa%e3%82%af%e3%82%a8%e3%82%b9%e3%83%88%e5%85%83%e3%82%92%e5%88%b6%e5%be%a1-cookie%e3%81%aesamesite%e5%b1%9e%e6%80%a7&#34;&gt;リクエスト元を制御: CookieのSameSite属性&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;StrictもしくはLaxを設定することで、クロスサイトでのCookie送信を防止する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;リクエスト元を検証-csrfトークン&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/csrf/#%e3%83%aa%e3%82%af%e3%82%a8%e3%82%b9%e3%83%88%e5%85%83%e3%82%92%e6%a4%9c%e8%a8%bc-csrf%e3%83%88%e3%83%bc%e3%82%af%e3%83%b3&#34;&gt;リクエスト元を検証: CSRFトークン&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバー側で発行したトークンをフォームに埋め込む&lt;/li&gt;&#xA;&lt;li&gt;クライアントからのリクエストにそのトークンがあるかを確認し、リクエストの妥当性をチェック&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;認証トークンを送らせない-authorizationヘッダを利用&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/csrf/#%e8%aa%8d%e8%a8%bc%e3%83%88%e3%83%bc%e3%82%af%e3%83%b3%e3%82%92%e9%80%81%e3%82%89%e3%81%9b%e3%81%aa%e3%81%84-authorization%e3%83%98%e3%83%83%e3%83%80%e3%82%92%e5%88%a9%e7%94%a8&#34;&gt;認証トークンを送らせない: Authorizationヘッダを利用&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Cookieだと自動送信されてしまう&lt;/li&gt;&#xA;&lt;li&gt;代わりにAuthorizationヘッダを利用すればブラウザが自動送信しないため、CSRF攻撃は成立しない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>XSS(Cross-Site Scripting)</title>
      <link>http://localhost:1313/posts/xss/</link>
      <pubDate>Mon, 28 Apr 2025 23:15:14 +0900</pubDate>
      <guid>http://localhost:1313/posts/xss/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;xssとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/xss/#xss%e3%81%a8%e3%81%af&#34;&gt;XSSとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;悪意あるスクリプト（JavaScriptなど）をユーザーのブラウザ上で実行させる攻撃&lt;/li&gt;&#xA;&lt;li&gt;例えば、HTML入力フォームに、&lt;code&gt;&amp;lt;script&amp;gt;alert(&#39;hello&#39;)&amp;lt;/script&amp;gt;&lt;/code&gt;という内容を入力する形でJSを実行できてしまう&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えばCookie, LocalStorageにあるセッション・トークン情報を盗んだり&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;対策&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/xss/#%e5%af%be%e7%ad%96&#34;&gt;対策&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;発動を防ぐ-csp&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/xss/#%e7%99%ba%e5%8b%95%e3%82%92%e9%98%b2%e3%81%90-csp&#34;&gt;発動を防ぐ: CSP&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバ側でContent-Security-Policy（CSP）を設定する(レスポンスにヘッダをセットする)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CSPは、ブラウザに命令をするもの(インラインのJS実行禁止とか、同一オリジンのJSのみ実行許可するとか)&lt;/li&gt;&#xA;&lt;li&gt;ブラウザがCSPに書かれている命令を読み取り、それに則り行動する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;設定例:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;script-src &#39;self&#39;&lt;/code&gt;: &lt;code&gt;&amp;lt;script src=&amp;quot;./script/app.js&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;といった 外部スクリプトの同一オリジンのみ許可（インライン＝HTML内のJSやbutton等のHTMLタグのonclick属性等のJSもブロック）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/HTTP/Guides/CSP&#34;&gt;コンテンツセキュリティポリシー (CSP) - HTTP | MDN&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;埋め込みを防ぐ-入力値サニタイズ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/xss/#%e5%9f%8b%e3%82%81%e8%be%bc%e3%81%bf%e3%82%92%e9%98%b2%e3%81%90-%e5%85%a5%e5%8a%9b%e5%80%a4%e3%82%b5%e3%83%8b%e3%82%bf%e3%82%a4%e3%82%ba&#34;&gt;埋め込みを防ぐ: 入力値サニタイズ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ユーザー入力値をエスケープ処理する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例：&lt;code&gt;&amp;lt;script&amp;gt; → &amp;amp;lt;script&amp;amp;gt;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;読み取りを防ぐ-cookie-httponly属性&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/xss/#%e8%aa%ad%e3%81%bf%e5%8f%96%e3%82%8a%e3%82%92%e9%98%b2%e3%81%90-cookie-httponly%e5%b1%9e%e6%80%a7&#34;&gt;読み取りを防ぐ: Cookie HttpOnly属性&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Cookie HttpOnly属性をつけることでJSからトークンを盗まれないようにできる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;対策まとめ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/xss/#%e5%af%be%e7%ad%96%e3%81%be%e3%81%a8%e3%82%81&#34;&gt;対策まとめ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;サーバーからブラウザに変なJSを実行しないでね＋ユーザー入力値はきちんと文字列として扱ってね＋もし万が一Cookieにアクセスされても盗まれないようにね&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>PrivateLinkを理解する</title>
      <link>http://localhost:1313/posts/private-link/</link>
      <pubDate>Sat, 26 Apr 2025 23:26:39 +0900</pubDate>
      <guid>http://localhost:1313/posts/private-link/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;privatelinkとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/private-link/#privatelink%e3%81%a8%e3%81%af&#34;&gt;PrivateLinkとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サービスがVPC内にあるかのようにVPCをそれらのサービスにプライベートに接続できるようにするサービス&#xA;&lt;ul&gt;&#xA;&lt;li&gt;あるVPCから別のVPCのあるリソースをあたかも同一VPC内にホストされているかのように、プライベートIPアドレスを使用して接続することを可能にする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;後述のVPCエンドポイントVPCエンドポイントサービスを使用して、上記の機能が実現することができ、その提供される機能（サービス）のことをPrivateLinkという&lt;/li&gt;&#xA;&lt;li&gt;IGW、NATデバイス、パブリックIPアドレス、DirectConnect、Site-to-Site VPN接続を使用する必要はない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;セキュリティが向上するのはもちろん、NATゲートウェイ（インスタンス）やEIPが不要ということでコスト面でもメリットが大きい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/vpc/latest/privatelink/what-is-privatelink.html&#34;&gt;AWS PrivateLink とは&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/vpc/latest/privatelink/concepts.html&#34;&gt;AWS PrivateLink の概念&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;vpcエンドポイントとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/private-link/#vpc%e3%82%a8%e3%83%b3%e3%83%89%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88%e3%81%a8%e3%81%af&#34;&gt;VPCエンドポイントとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPCと他サービス間でプライベート接続を可能にするコンポーネント&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;サービス利用側&lt;/strong&gt;のVPC内に作成する&lt;/li&gt;&#xA;&lt;li&gt;(インターフェイス型)VPCエンドポイントを作成するとENIが作成（アタッチ）される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPCエンドポイントを作成するときは1つ以上のサブネットを選択するが、選択したサブネットそれぞれにENIが作成される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;vpcエンドポイントサービスとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/private-link/#vpc%e3%82%a8%e3%83%b3%e3%83%89%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88%e3%82%b5%e3%83%bc%e3%83%93%e3%82%b9%e3%81%a8%e3%81%af&#34;&gt;VPCエンドポイントサービスとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPCと他サービス間でプライベート接続を可能にするコンポーネント&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;サービス提供側&lt;/strong&gt;のVPC内に作成する&lt;/li&gt;&#xA;&lt;li&gt;実体はロードバランサー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;NLB or GLBが必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;VPCエンドポイントサービス側では、VPCエンドポイントの接続リクエストを承諾を行う必要がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;なぜサービス提供側にnlbが必要なのか考察&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/private-link/#%e3%81%aa%e3%81%9c%e3%82%b5%e3%83%bc%e3%83%93%e3%82%b9%e6%8f%90%e4%be%9b%e5%81%b4%e3%81%abnlb%e3%81%8c%e5%bf%85%e8%a6%81%e3%81%aa%e3%81%ae%e3%81%8b%e8%80%83%e5%af%9f&#34;&gt;なぜサービス提供側にNLBが必要なのか？（考察）&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;（そういう仕様だからというのは置いておいて、どうしてそのようになっているか考えてみた）&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;PrivateLinkの思想はあくまでネットワークレイヤの透過的な疎通なので、L7レイヤのことは気にするべきでない（ALBでは実現不可）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;L4レイヤであれば内部ネットワークで通信を延長できるイメージ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;加えて、L7レイヤではHTTPリクエストの解釈等の負荷があるが、IPとポートだけで接続先を決めるL4レイヤは軽くてパフォーマンスも良い&lt;/li&gt;&#xA;&lt;li&gt;じゃあECSとかサーバーに直接繋げるのはダメなの？起動のたびにIP変わったりするし、そうなるとPrivateLinkも貼り直しになり色々微妙（そもそもL7レイヤでの通信じゃんという話ももちろんあるが）&lt;/li&gt;&#xA;&lt;li&gt;PrivateLinkは、あくまでネットワーク（VPC）のサービスだから、アプリケーションレイヤが立ち入るのは良くないよねという設計思想なのかもしれない&lt;/li&gt;&#xA;&lt;li&gt;ちなみに、NLBのターゲットにALBを指定することは可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;vpcエンドポイントの種類&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/private-link/#vpc%e3%82%a8%e3%83%b3%e3%83%89%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88%e3%81%ae%e7%a8%ae%e9%a1%9e&#34;&gt;VPCエンドポイントの種類&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;インターフェイスタイプ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/private-link/#%e3%82%a4%e3%83%b3%e3%82%bf%e3%83%bc%e3%83%95%e3%82%a7%e3%82%a4%e3%82%b9%e3%82%bf%e3%82%a4%e3%83%97&#34;&gt;インターフェイスタイプ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プライベートIPが割り当てられたENIが作成される(これはEC2のようなもの&amp;hellip;？)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ゲートウェイタイプ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/private-link/#%e3%82%b2%e3%83%bc%e3%83%88%e3%82%a6%e3%82%a7%e3%82%a4%e3%82%bf%e3%82%a4%e3%83%97&#34;&gt;ゲートウェイタイプ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ルートテーブルで送信先に対するターゲットとして指定する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;このサブネットのこの宛先（プレフィックスリスト）の通信はS3/DyanamoDBに流すというやつ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;内部的にENIやIPアドレスは作成されない（恐らく仮想ルータ的なものだけ）&lt;/li&gt;&#xA;&lt;li&gt;つまり、ルートテーブルだけでの制御(L3 IPレベルの単純な転送)なので、軽いしスケールしやすい&#xA;&lt;ul&gt;&#xA;&lt;li&gt;だから、通信容量が多そうなS3とDynamoDBだけなのだろうか&amp;hellip;？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;インターフェースvpcエンドポイントの料金&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/private-link/#%e3%82%a4%e3%83%b3%e3%82%bf%e3%83%bc%e3%83%95%e3%82%a7%e3%83%bc%e3%82%b9vpc%e3%82%a8%e3%83%b3%e3%83%89%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88%e3%81%ae%e6%96%99%e9%87%91&#34;&gt;インターフェースVPCエンドポイントの料金&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;時間課金: VPCエンドポイント1つあたり 0.014USD/1h&lt;/li&gt;&#xA;&lt;li&gt;データ処理量: 0.01USD/1PB&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;→これって多分ENI（EC2的な？）を内部で立てているための料金なのかも？&lt;/p&gt;&#xA;&lt;p&gt;※ゲートウェイ型は、データ処理量のみ発生する&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/private-link/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://dev.classmethod.jp/articles/aws-vpcendpoint-privatelink-beginner/&#34;&gt;【初心者向け】VPCエンドポイントとAWS PrivateLinkの違いを実際に構築して理解してみた | DevelopersIO&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>ReactにおけるCSS</title>
      <link>http://localhost:1313/posts/css-in-react/</link>
      <pubDate>Mon, 21 Apr 2025 06:49:42 +0900</pubDate>
      <guid>http://localhost:1313/posts/css-in-react/</guid>
      <description>&lt;p&gt;勉強会でCSS周りの話を聞いたので調べてみる。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;どのような種類があるか&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/css-in-react/#%e3%81%a9%e3%81%ae%e3%82%88%e3%81%86%e3%81%aa%e7%a8%ae%e9%a1%9e%e3%81%8c%e3%81%82%e3%82%8b%e3%81%8b&#34;&gt;どのような種類があるか&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;css&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/css-in-react/#css&#34;&gt;CSS&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;（言わずもがな）&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ブラウザが直接解釈する（のでパフォーマンス良い）&lt;/li&gt;&#xA;&lt;li&gt;クラス名設計等のスコープ管理が難しいのと、コンポーネントベースの設計と相性が微妙&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンポーネントごとにスタイルを独立させたいが、純粋CSSだとそうもいかない&lt;/li&gt;&#xA;&lt;li&gt;どのスタイルがどのコンポーネントに対応しているかが追いづらい&lt;/li&gt;&#xA;&lt;li&gt;使用されなくなったCSSが残り、肥大する可能性もある&lt;/li&gt;&#xA;&lt;li&gt;BEM等を採用してクラス名ルールを決めたり、CSS Modulesでローカルスコープ化したりやり方はあるが、JSではないので、モジュール化(import/export)を使用できないので、JSフレームワークとの相性はあまり良くないという意味&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;css-in-jsランタイム&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/css-in-react/#css-in-js%e3%83%a9%e3%83%b3%e3%82%bf%e3%82%a4%e3%83%a0&#34;&gt;CSS in JS(ランタイム)&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JSファイル内でCSSを書く&lt;/li&gt;&#xA;&lt;li&gt;ランタイムでCSSを生成してDOMに注入する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CSS文字列からパース処理を経てstyleタグを生成し、classNameをハッシュ関数等で作成しstyleタグを直接挿入し、コンポーネントにバインドする&lt;/li&gt;&#xA;&lt;li&gt;パース処理とDOMへの直接埋め込みという負荷の大きい処理をランタイムで行うことになりオーバーヘッドが大きい&lt;/li&gt;&#xA;&lt;li&gt;サーバー側でコンポーネントがレンダリング処理が行われるためにDOMアクセスができないので、ServerComponentでは動作しない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;styled-components, Emotion等&lt;/li&gt;&#xA;&lt;li&gt;ゼロランタイムCSSとの比較で、ランタイムCSS in JSと呼ぶこともある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ゼロランタイムcss&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/css-in-react/#%e3%82%bc%e3%83%ad%e3%83%a9%e3%83%b3%e3%82%bf%e3%82%a4%e3%83%a0css&#34;&gt;ゼロランタイムCSS&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;書き方はCSS in JSだが、ビルド時に純粋CSSを出力する&lt;/li&gt;&#xA;&lt;li&gt;JS実行時にスタイルを処理しないので「ゼロランタイム」と呼ばれている&lt;/li&gt;&#xA;&lt;li&gt;純粋CSSなので、ブラウザがそのまま解釈可能、パフォーマンスが高い&lt;/li&gt;&#xA;&lt;li&gt;CSS in JSの実装面の良い所である型安全やスコープ管理が使える&lt;/li&gt;&#xA;&lt;li&gt;ステートの状態でcolorが変わるようなものは、ClientComponentとしてランタイムでスタイリングが当てられる（なるべくこの処理を減らした方がパフォーマンスが良い）&lt;/li&gt;&#xA;&lt;li&gt;vanilla-extractやLinaria、Kuma-UI&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/css-in-react/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zenn.dev/mk668a/articles/6ef02b7ea8ba74&#34;&gt;ゼロランタイムCSS in JSとは？結局、何を使えばいい？- フロントエンドの現在 -&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zenn.dev/poteboy/articles/d94573793d56ed&#34;&gt;ゼロランタイムUIコンポーネントライブラリ「Kuma UI」の紹介&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;日本人の方が作成したゼロランタイムCSS in JSライブラリ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>CORS</title>
      <link>http://localhost:1313/posts/cors/</link>
      <pubDate>Sun, 20 Apr 2025 15:23:16 +0900</pubDate>
      <guid>http://localhost:1313/posts/cors/</guid>
      <description>&lt;p&gt;SOPというブラウザのセキュリティ制約を理解した上で、CORSをちゃんと理解する。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;same-origin-policysop&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cors/#same-origin-policysop&#34;&gt;Same Origin Policy(SOP)&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SOPとは、ブラウザにある仕組みのことで、あるオリジンから別のオリジンにあるリソースへのアクセスを制限するというもの&#xA;&lt;ul&gt;&#xA;&lt;li&gt;オリジン：&lt;code&gt;スキーム（プロトコル）&lt;/code&gt;、&lt;code&gt;ホスト&lt;/code&gt;、&lt;code&gt;ポート&lt;/code&gt;の3つの組み合わせたもの(なので、いずれかがど異なるだけでも別オリジンと見なされる)&lt;/li&gt;&#xA;&lt;li&gt;この仕組みが存在する理由は、例えば悪意あるスクリプトが仕込まれたWebページを読み込んだ時に、JSであらゆるリソースにアクセスできたらセキュリティ的な問題が生じうるので、それを防ぐため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ここで制限の対象となるのは、JavaScriptからリクエストするもののみ（fetch()とか、scriptタグでのフォントインストールとか）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;なので、HTMLのimgタグのsrc属性に別オリジンとなるURLが設定されていても、SOPによる制限は受けない&lt;/li&gt;&#xA;&lt;li&gt;また、これはあくまでブラウザの機能なので、curlコマンドとかだとSOPの仕組みはない（CORSエラーは発生しない）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;cross-origin-resource-sharingcors&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cors/#cross-origin-resource-sharingcors&#34;&gt;Cross Origin Resource Sharing(CORS)&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CORSは、異なるオリジンからのリソース要求を可能にするブラウザの機能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;この機能は、HTTPヘッダーを利用して実現される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;実装的には、サーバーのレスポンスヘッダ&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;に許可したいリクエスト元のドメインを設定することで、そのドメイン(オリジン)からのリクエストを許可する仕組みとなっている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えば、APIサーバー側のレスポンスヘッダ&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;の値にフロントエンドドメインを設定することで、フロントエンドからのAPIサーバーへのアクセスが可能になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;補足として、よくCORSエラーと表現されることが多いが、あくまでCORS自体はクロスオリジンからのリクエストを許可するものである（CORSエラーというのは、SOPという制約を受けて＋CORSが設定されていないという内容のエラーである）&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;corsエラーが発生するタイミング&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cors/#cors%e3%82%a8%e3%83%a9%e3%83%bc%e3%81%8c%e7%99%ba%e7%94%9f%e3%81%99%e3%82%8b%e3%82%bf%e3%82%a4%e3%83%9f%e3%83%b3%e3%82%b0&#34;&gt;CORSエラーが発生するタイミング&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;CORSエラーが発生するタイミングは、リクエストの種類によって異なる。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;1シンプルリクエストの場合&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cors/#1%e3%82%b7%e3%83%b3%e3%83%97%e3%83%ab%e3%83%aa%e3%82%af%e3%82%a8%e3%82%b9%e3%83%88%e3%81%ae%e5%a0%b4%e5%90%88&#34;&gt;1.シンプルリクエストの場合&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;シンプルリクエストとは？&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;プリフライトリクエストが発生しないリクエストのことで、以下の条件に当てはまるもの。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HTTPメソッドはGET、POST、HEADのいずれか&lt;/li&gt;&#xA;&lt;li&gt;リクエストヘッダーが以下のみ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Accept&lt;/li&gt;&#xA;&lt;li&gt;Accept-Language&lt;/li&gt;&#xA;&lt;li&gt;Content-Language&lt;/li&gt;&#xA;&lt;li&gt;Content-Type（ただしapplication/x-www-form-urlencoded,multipart/form-data,text/plainのみ）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Authorizationやカスタムヘッダ(X-API-KEYなど)を含む場合は、非シンプルリクエストになる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;リクエストボディにBlobやArrayBufferなどを含まない（通常のテキストデータのみ）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;簡単にまとめると「GETやHEADのサーバー側に影響を及ぼさない安全なメソッド」や「HTMLフォームで送信できる範囲のPOSTリクエスト」が該当する。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;CORSの検証〜エラー発生までの流れ&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ブラウザがサーバーにリクエストを送信し＆サーバーからのレスポンスを受け取った後に&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;ヘッダーをみて、自身のOriginが含まれているかをチェックする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;自身のOriginが含まれていない場合、ブラウザがエラーを発生させ、レスポンスをJavaScript側に渡さない&lt;/li&gt;&#xA;&lt;li&gt;仮にサーバー側が200 OKを返してもいても、自身のOriginが含まれていなければエラーが発生する&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;ヘッダー自体がそもそもない場合もエラーとなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;シンプルリクエストは、基本的にはサーバー側に影響を及ぼさないリクエストなので、事後チェックとなっている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;（なお、サーバー側に影響を及ぼす可能性がある）HTMLフォームから送信される範囲のPOSTリクエストが同じく事後チェックなのは互換性重視のため（HTMLフォームからのクロスオリジンリクエストはCORS登場の前から行われていた）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;2プリフライトリクエストが必要なリクエストの場合&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cors/#2%e3%83%97%e3%83%aa%e3%83%95%e3%83%a9%e3%82%a4%e3%83%88%e3%83%aa%e3%82%af%e3%82%a8%e3%82%b9%e3%83%88%e3%81%8c%e5%bf%85%e8%a6%81%e3%81%aa%e3%83%aa%e3%82%af%e3%82%a8%e3%82%b9%e3%83%88%e3%81%ae%e5%a0%b4%e5%90%88&#34;&gt;2.プリフライトリクエスト(が必要なリクエスト)の場合&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ブラウザがリクエスト送信前にOPTIONSメソッドでプリフライトリクエストを送る&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ブラウザから、Access-Control-Request-Methodで実際に送るリクエストのメソッドをサーバー側に伝える&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サーバーがCORS関連の情報をブラウザに返却する&lt;/li&gt;&#xA;&lt;li&gt;ブラウザがレスポンスヘッダを見て、リクエストが許可されているかをチェックする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;許可されていれば、本リクエストを送信する&lt;/li&gt;&#xA;&lt;li&gt;許可されていなければ、本リクエストは送信されず、エラーが発生する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cors/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/HTTP/CORS&#34;&gt;オリジン間リソース共有 (CORS) - HTTP | MDN&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/Security/Same-origin_policy&#34;&gt;同一オリジンポリシー - ウェブセキュリティ | MDN&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>DNSがよくわかる教科書</title>
      <link>http://localhost:1313/posts/011_dns%E3%81%8C%E3%82%88%E3%81%8F%E3%82%8F%E3%81%8B%E3%82%8B%E6%95%99%E7%A7%91%E6%9B%B8/</link>
      <pubDate>Thu, 17 Apr 2025 23:10:29 +0900</pubDate>
      <guid>http://localhost:1313/posts/011_dns%E3%81%8C%E3%82%88%E3%81%8F%E3%82%8F%E3%81%8B%E3%82%8B%E6%95%99%E7%A7%91%E6%9B%B8/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;委任によって管理を任された範囲をゾーンと呼ぶ&lt;/li&gt;&#xA;&lt;li&gt;ゾーンの管理者はネームサーバで以下の2種類を情報を管理する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;そのゾーンに存在するドメイン名とIPアドレスの対応づけ&lt;/li&gt;&#xA;&lt;li&gt;委任情報(委任先のネームサーバ情報)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;問い合わせが来たら委任先を紹介するイメージ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ドメイン登録手順&#xA;&lt;ul&gt;&#xA;&lt;li&gt;申請者→レジストラ(リセらとか)→レジストリ(データベース)&lt;/li&gt;&#xA;&lt;li&gt;そのドメインが使えるかはWhoisというシステムで確認可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;3種類と構成要素&#xA;&lt;ul&gt;&#xA;&lt;li&gt;スタブリゾルバー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これがDNSクライアントとなる&lt;/li&gt;&#xA;&lt;li&gt;端末のOSに存在する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;フルサービスリゾルバー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;キャッシュDNSサーバー&lt;/li&gt;&#xA;&lt;li&gt;ISPとかに存在&lt;/li&gt;&#xA;&lt;li&gt;プロキシ的に動く&lt;/li&gt;&#xA;&lt;li&gt;DNS結果をキャッシュする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;権威サーバー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ネームサーバーのことで、ドメインに紐づくIPアドレスを持つ&lt;/li&gt;&#xA;&lt;li&gt;そのドメインに対する権威を保持していることから権威という名前&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;複数あるネームサーバーのどれに問い合わせるの？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RTTをチェックし、最も短いサーバーに問い合わせる&lt;/li&gt;&#xA;&lt;li&gt;ラウンドトリップタイム: 問い合わせてから応答が返るまでの時間&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Bashのpipefailオプションについて</title>
      <link>http://localhost:1313/posts/bash-pipefail-option/</link>
      <pubDate>Mon, 14 Apr 2025 22:56:57 +0900</pubDate>
      <guid>http://localhost:1313/posts/bash-pipefail-option/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/bash-pipefail-option/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;GHAでGitHubHostedRunner上でUbuntuを動かす場合、デフォルトのシェルはbashとなる。&#xA;ただ厄介なことにshellキーの有無で、bash起動オプションが異なるという挙動があり、その点を深掘ってみる。&lt;/p&gt;&#xA;&lt;p&gt;なおshellキーの有というのは、&lt;code&gt;shell: bash&lt;/code&gt;というのをステップで宣言することを指している。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;具体的なghaでの起動オプションの違い&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/bash-pipefail-option/#%e5%85%b7%e4%bd%93%e7%9a%84%e3%81%aagha%e3%81%a7%e3%81%ae%e8%b5%b7%e5%8b%95%e3%82%aa%e3%83%97%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%ae%e9%81%95%e3%81%84&#34;&gt;具体的なGHAでの起動オプションの違い&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;省略時: &lt;code&gt;bash -e {0}&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;記述時: &lt;code&gt;bash --noprofile --norc -eo pipefail&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;※起動オプションでなくても、&lt;code&gt;set -e&lt;/code&gt;等でスクリプトの中で実行することも可能&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;オプションを理解する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/bash-pipefail-option/#%e3%82%aa%e3%83%97%e3%82%b7%e3%83%a7%e3%83%b3%e3%82%92%e7%90%86%e8%a7%a3%e3%81%99%e3%82%8b&#34;&gt;オプションを理解する&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;-e&lt;/code&gt;: スクリプト内のどこかでコマンドが失敗すると即時終了する&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-o pipefail&lt;/code&gt;: パイプラインの中で失敗したコマンドをエラーとして扱う&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;--noprofile --norc&lt;/code&gt;: .bash_profile や .bashrc を読み込まずに起動する（環境の違いを排除）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;パイプラインとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/bash-pipefail-option/#%e3%83%91%e3%82%a4%e3%83%97%e3%83%a9%e3%82%a4%e3%83%b3%e3%81%a8%e3%81%af&#34;&gt;パイプラインとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コマンドの出力を次のコマンドの入力として渡す構文のこと&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;cat example.txt | grep &amp;quot;keyword&amp;quot;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;pipefailがないデフォルトの状態では、パイプラインの最終コマンドの終了ステータスのみが評価されるので、途中のコマンドが失敗してもスルーされる可能性がある&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-o pipefail&lt;/code&gt;の設定をすることで、パイプラインのどこかが1つでも失敗すれば、全体が失敗と評価される&lt;/li&gt;&#xA;&lt;li&gt;スクリプトの中で、&lt;code&gt;set -o pipefail&lt;/code&gt;とやることでも設定可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;なぜデフォルトではpipefailがないのか&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/bash-pipefail-option/#%e3%81%aa%e3%81%9c%e3%83%87%e3%83%95%e3%82%a9%e3%83%ab%e3%83%88%e3%81%a7%e3%81%afpipefail%e3%81%8c%e3%81%aa%e3%81%84%e3%81%ae%e3%81%8b&#34;&gt;なぜデフォルトではpipefailがないのか？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pipefailは比較的新しいオプションであり、、後方互換性のためデフォルトでは無効になっている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Unixの思想として「小さいコマンドを繋いで処理を作る」というのがあり、パイプで繋いで小さい処理をインタラクティブに繋ぎ合わせる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;そもそもユーザー入力値を前提に処理を進める場合はpipefailが無効の方が便利だったりする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;grepして結果無いたびにエラーになるより、エラーなしで処理が継続できた方が柔軟性が高い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;pipefail以外でシェルを堅牢にするオプション&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/bash-pipefail-option/#pipefail%e4%bb%a5%e5%a4%96%e3%81%a7%e3%82%b7%e3%82%a7%e3%83%ab%e3%82%92%e5%a0%85%e7%89%a2%e3%81%ab%e3%81%99%e3%82%8b%e3%82%aa%e3%83%97%e3%82%b7%e3%83%a7%e3%83%b3&#34;&gt;pipefail以外でシェルを堅牢にするオプション&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;-e&lt;/code&gt;(errexit): コマンドが失敗したら即スクリプトを終了&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-u&lt;/code&gt;(nounset): 未定義の変数を使ったらエラーにする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>go mod vendor</title>
      <link>http://localhost:1313/posts/go-mod-vendor/</link>
      <pubDate>Wed, 02 Apr 2025 23:32:55 +0900</pubDate>
      <guid>http://localhost:1313/posts/go-mod-vendor/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;go-mod-vendorとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/go-mod-vendor/#go-mod-vendor%e3%81%a8%e3%81%af&#34;&gt;go mod vendorとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;go mod vendor&lt;/code&gt;とは、Goのモジュールシステムにおけるコマンドの1つである。  　&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;go mod vendor&lt;/code&gt;を実行すると、ビルドとテストに必要な全ての依存パッケージのコピーをvendorディレクトリに格納する。&lt;/p&gt;&#xA;&lt;p&gt;vendoringが有効な場合、goコマンド(ex:go buildやgo test等)はソースからモジュールキャッシュをダウンロードする代わりに、&#xA;vendorディレクトリからパッケージをロードしてビルドやテストを実行してくれる。&lt;/p&gt;&#xA;&lt;p&gt;Go1.14以上の場合は、ルートディレクトリにvendorディレクトリがあれば自動的にvendorディレクトリが使用される&#xA;(現行バージョンだとvendoringはデフォルトでONになっているという認識で良さそう)&lt;/p&gt;&#xA;&lt;p&gt;明示的に無効にしたい場合は、goコマンドに&lt;code&gt;-mod=readonly&lt;/code&gt;または&lt;code&gt;-mod=mod&lt;/code&gt;のオプションを使用する。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;メリット&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/go-mod-vendor/#%e3%83%a1%e3%83%aa%e3%83%83%e3%83%88&#34;&gt;メリット&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ネットワーク不要でビルド可能になる&lt;/li&gt;&#xA;&lt;li&gt;依存パッケージのバージョンを固定できる(ビルドの安定度向上等)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;デメリット&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/go-mod-vendor/#%e3%83%87%e3%83%a1%e3%83%aa%e3%83%83%e3%83%88&#34;&gt;デメリット&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リポジトリサイズの肥大化&lt;/li&gt;&#xA;&lt;li&gt;依存パッケージが更新された場合は再度コマンド実行が必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;実際のユースケースを考えてみる&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/go-mod-vendor/#%e5%ae%9f%e9%9a%9b%e3%81%ae%e3%83%a6%e3%83%bc%e3%82%b9%e3%82%b1%e3%83%bc%e3%82%b9%e3%82%92%e8%80%83%e3%81%88%e3%81%a6%e3%81%bf%e3%82%8b&#34;&gt;実際のユースケースを考えてみる&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;現在自分が担当しているGoを使用したプロジェクトではdockerコンテナ上で開発をしており、&#xA;コンテナを破棄してイメージの再ビルド(docker compose down &amp;amp;&amp;amp; up)を行う度にモジュールダウンロードが発生するため、&#xA;ローカルでの開発での速度向上には良いのかもしれない(と教えてもらった)&lt;/p&gt;&#xA;&lt;p&gt;ただ注意点としては、複数人で開発を行うときはgit管理対象外にするのは必須なのと、&lt;!-- raw HTML omitted --&gt;&#xA;依存パッケージの更新時は、go mod vendorを再実行することを忘れずないようにする。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/go-mod-vendor/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://go.dev/ref/mod#go-mod-vendor&#34;&gt;go mod vendor&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://go.dev/ref/mod#vendoring&#34;&gt;Vendoring&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>HomebrewでGoバージョンを切り替える</title>
      <link>http://localhost:1313/posts/version-switching-with-homebrew/</link>
      <pubDate>Wed, 02 Apr 2025 23:32:55 +0900</pubDate>
      <guid>http://localhost:1313/posts/version-switching-with-homebrew/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;概要&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/version-switching-with-homebrew/#%e6%a6%82%e8%a6%81&#34;&gt;概要&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;今まではgoenvとかを使ってローカルのGoバージョンを管理していたが、PC切り替えたタイミングでシンプルにHomebrewで管理してみることにした。&lt;br&gt;&#xA;Homebrewだと&lt;code&gt;brew update&lt;/code&gt;で新しいバージョンが入るので良いが、バージョン切り替えに手こずったのでその方法を残しておく。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;やり方&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/version-switching-with-homebrew/#%e3%82%84%e3%82%8a%e6%96%b9&#34;&gt;やり方&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;1.23.4から1.23.6に上げる方法&lt;br&gt;&#xA;※ここではあえて、&lt;code&gt;brew update&lt;/code&gt;ではなくgoのインストールから手動で行うで紹介&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;// 存在を確認&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;brew search go@1.23.6&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;// インストール&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;brew install &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;go@1.23&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;// 現在リンクされているgoバージョンを解除&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;brew unlink go&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;// 1.23に設定&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;brew link go@1.23&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;// 出力されたパス通すコマンド実行&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;export PATH=&amp;#34;...&amp;#34;&amp;#39;&lt;/span&gt; &amp;gt;&amp;gt; ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;source ~/.zshrc&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;go version&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt;&amp;gt; go version go1.23.6 darwin/arm64&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;p&gt;注意点としては、brew switchを紹介している古い記事が結構あるが、switchコマンドは廃止されており、使用できなかった&amp;hellip;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>interface{} vs any</title>
      <link>http://localhost:1313/posts/interface-vs-any/</link>
      <pubDate>Wed, 02 Apr 2025 23:32:55 +0900</pubDate>
      <guid>http://localhost:1313/posts/interface-vs-any/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/interface-vs-any/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;空のインターフェイスを表現するものとして、interface{}とanyがある&lt;!-- raw HTML omitted --&gt;&#xA;両者の違いとどちらを使うべきかを調べた際のメモ&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;interface&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/interface-vs-any/#interface&#34;&gt;interface&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Goの初期バージョンから存在する&lt;/li&gt;&#xA;&lt;li&gt;全ての型はinterface{}を実装しているので任意の型を格納できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;any&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/interface-vs-any/#any&#34;&gt;any&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Go1.18で追加されたinterface{}の型エイリアス&lt;/li&gt;&#xA;&lt;li&gt;可読性向上のために導入された&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;まとめ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/interface-vs-any/#%e3%81%be%e3%81%a8%e3%82%81&#34;&gt;まとめ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;anyを使うべし&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/interface-vs-any/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://zenn.dev/syumai/articles/c6q5un1j0msim0aj0ca0&#34;&gt;Go 1.18 で interface{} の代わりに any が使えるようになる話&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>uintptr型</title>
      <link>http://localhost:1313/posts/uintptr-type/</link>
      <pubDate>Wed, 02 Apr 2025 23:32:55 +0900</pubDate>
      <guid>http://localhost:1313/posts/uintptr-type/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;uintptr型とは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/uintptr-type/#uintptr%e5%9e%8b%e3%81%a8%e3%81%af&#34;&gt;uintptr型とは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ポインタを整数として扱うための型&lt;/li&gt;&#xA;&lt;li&gt;ポインタ操作やメモリアドレスの計算を行う際に役立つ&lt;/li&gt;&#xA;&lt;li&gt;特に低レベルのメモリ操作や特定のシステムプログラミングで重要&lt;/li&gt;&#xA;&lt;li&gt;ただし安全でない操作を行うため、unsafeパッケージのインポートが必要になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;使用例&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/uintptr-type/#%e4%bd%bf%e7%94%a8%e4%be%8b&#34;&gt;使用例&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;  &#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;unsafe&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// int型のポインタを取得&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ポインタをunsafe.Pointer型に変換&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;up&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// unsafe.Pointer型をuintptr型に変換&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;uip&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; uintptr(&lt;span style=&#34;color:#a6e22e&#34;&gt;up&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// uintptr型を再びunsafe.Pointer型に変換&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;up2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;uip&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// unsafe.Pointer型を元の型（*int）に変換（キャストする)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;p2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)(&lt;span style=&#34;color:#a6e22e&#34;&gt;up2&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;元の値:&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ポインタ経由の値:&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;p2&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;p&gt;解説&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;unsafeパッケージを用いて、メモリ操作を可能にしている&lt;/li&gt;&#xA;&lt;li&gt;int型の変数xをポインタ経由で操作している&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;(*int)(up2)&lt;/code&gt;でup2を*int型にキャストする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;実際のユースケース&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/uintptr-type/#%e5%ae%9f%e9%9a%9b%e3%81%ae%e3%83%a6%e3%83%bc%e3%82%b9%e3%82%b1%e3%83%bc%e3%82%b9&#34;&gt;実際のユースケース&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;特定のメモリアドレスやハードウェアにアクセスが必要がある低レイヤーの開発&lt;/li&gt;&#xA;&lt;li&gt;メモリアロケータやガベージコレクタの実装など&#xA;&lt;ul&gt;&#xA;&lt;li&gt;メモリアロケータ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アロケータとは割り当てのこと&lt;/li&gt;&#xA;&lt;li&gt;プログラム実行時にメモリを動的に割り当てる機能を提供するシステムコンポーネントのことをメモリアロケータという&lt;/li&gt;&#xA;&lt;li&gt;メモリの割り当て（アロケーション）や解放（デアロケーション）や再利用という機能を有する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ガベージコレクタ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不要になったメモリを自動的に解放するシステムコンポーネント&lt;/li&gt;&#xA;&lt;li&gt;メモリリークを起こさないようにしてくれるやつ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Webサーバー</title>
      <link>http://localhost:1313/posts/web-server/</link>
      <pubDate>Wed, 02 Apr 2025 23:32:55 +0900</pubDate>
      <guid>http://localhost:1313/posts/web-server/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;概要&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/web-server/#%e6%a6%82%e8%a6%81&#34;&gt;概要&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;PHP/LaravelでWebアプリケーションを開発する場合、ApacheやNginx等のWebサーバーが必要になる一方で、&lt;br&gt;&#xA;Node.jsの場合は不要である。この違いが気になったのと、そもそもWebサーバーって何をやってくれているのか気になるので調べてみる。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;phplaravelにおけるapacheやnginxの必要性&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/web-server/#phplaravel%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8bapache%e3%82%84nginx%e3%81%ae%e5%bf%85%e8%a6%81%e6%80%a7&#34;&gt;PHP/LaravelにおけるApacheやNginxの必要性&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リクエストのルーティング&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pacheやNginxはクライアント（ブラウザなど）からのHTTPリクエストを受け取り、リクエストされたURLとHTTPメソッドに基づいて、PHPアプリケーションを振り分けている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;PHPエンジンとの連携&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ApacheやNginxはリクエストをPHPエンジンに渡している&lt;/li&gt;&#xA;&lt;li&gt;Apacheではmod_phpモジュール、Nginxでは、PHP-FPM（FastCGI Process Manager）を使用している&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;静的ファイルの配信&lt;/li&gt;&#xA;&lt;li&gt;負荷分散やリバースプロキシ機能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;nodejsにおけるwebサーバーが不要である理由&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/web-server/#nodejs%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8bweb%e3%82%b5%e3%83%bc%e3%83%90%e3%83%bc%e3%81%8c%e4%b8%8d%e8%a6%81%e3%81%a7%e3%81%82%e3%82%8b%e7%90%86%e7%94%b1&#34;&gt;Node.jsにおけるWebサーバーが不要である理由&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;理由：内臓のHTTPサーバー機能を持っており、Node.js自体がHTTPリクエストを直接処理可能であるため&#xA;&lt;ul&gt;&#xA;&lt;li&gt;httpやexpressなどのモジュールを使用して直接HTTPリクエストを受け取り、レスポンスを返す&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;phplaravelとecs-on-fargateにデプロイしたい時はどうするの&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/web-server/#phplaravel%e3%81%a8ecs-on-fargate%e3%81%ab%e3%83%87%e3%83%97%e3%83%ad%e3%82%a4%e3%81%97%e3%81%9f%e3%81%84%e6%99%82%e3%81%af%e3%81%a9%e3%81%86%e3%81%99%e3%82%8b%e3%81%ae&#34;&gt;PHP/LaravelとECS on Fargateにデプロイしたい時はどうするの？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HTTPリクエスト処理を行うNginx/ApacheコンテナとPHP-FPM（PHP FastCGI Process Manager）コンテナに分割する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同居も可能ではあるが、リソース効率やスケールの柔軟性を考慮すると分割するのが推奨らしい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;(Nginxを仮定し、前面にALBを配置したケースを例)具体的には、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ALBのターゲットをNginxコンテナの80番ポートに転送する&lt;/li&gt;&#xA;&lt;li&gt;NginxコンテナからPHPリクエストをFastCGIでPHP-FPMコンテナに転送するように設定(nginx.conf)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>write: broken pipeエラーを解決する</title>
      <link>http://localhost:1313/posts/fix-write-broken-pipe-error/</link>
      <pubDate>Wed, 02 Apr 2025 23:32:55 +0900</pubDate>
      <guid>http://localhost:1313/posts/fix-write-broken-pipe-error/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;概要&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fix-write-broken-pipe-error/#%e6%a6%82%e8%a6%81&#34;&gt;概要&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;個人開発しているアプリでDB接続時に以下のエラーが度々発生するので解決したい&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;write tcp &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;:51724-&amp;gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;:5432: write: broken pipe&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;p&gt;※&amp;hellip;という部分にはIPv6アドレスが入っている&lt;/p&gt;&#xA;&lt;p&gt;個人開発しているアプリの技術スタックは以下の通り。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;バックエンド: Go(Cloud Run)&lt;/li&gt;&#xA;&lt;li&gt;データベース: Neon(Serverless Postgres)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;エラーを読み解く&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fix-write-broken-pipe-error/#%e3%82%a8%e3%83%a9%e3%83%bc%e3%82%92%e8%aa%ad%e3%81%bf%e8%a7%a3%e3%81%8f&#34;&gt;エラーを読み解く&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;まずエラーが発生している箇所をソースコードで追うと、DB処理の部分でエラーが吐かれている。&lt;/p&gt;&#xA;&lt;p&gt;エラー内容で検索すると、TCPコネクションにデータを書き込もうとした際にネットワークエラーが発生するもので、broken pipeというのは、ネットワーク接続上でデータを送受信ができなかったことを意味するらしい。&lt;/p&gt;&#xA;&lt;p&gt;エラーが発生する条件としては、以下の通り。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一度API内部のDB処理が成功した後&lt;/li&gt;&#xA;&lt;li&gt;一定の時間が経過した後に再度DB処理が実行された時に当該エラーが発生する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サンプルが少ないため自信はないが、成功から次の実行まで5分以上空く時にエラーになってるっぽい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;仮説を立てる&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fix-write-broken-pipe-error/#%e4%bb%ae%e8%aa%ac%e3%82%92%e7%ab%8b%e3%81%a6%e3%82%8b&#34;&gt;仮説を立てる&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;以上のことから、既に死んでいるコネクションを使用してDB接続を行い、エラーが出ているのではと仮説を立ててみる&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;調査&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fix-write-broken-pipe-error/#%e8%aa%bf%e6%9f%bb&#34;&gt;調査&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Go(sqlパッケージ)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;maxIdleTimeのデフォルト値はない＝無限に保持される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;DB(Neon)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;デフォルトでは5分でインスタンスが0になるらしい&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://neon.tech/docs/connect/connection-latency#:~:text=By%20default%2C%20Neon%20scales%20a%20compute%20to%20zero%20after%205%20minutes%20of%20inactivity.&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;調査結果を経て考察&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fix-write-broken-pipe-error/#%e8%aa%bf%e6%9f%bb%e7%b5%90%e6%9e%9c%e3%82%92%e7%b5%8c%e3%81%a6%e8%80%83%e5%af%9f&#34;&gt;調査結果を経て考察&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;恐らく仮説の通りで、5分経過するとDBインスタンスが落ちるが、アプリ側では既に消失しているDBインスタンスに対するコネクションを保持してしまっていた。&lt;br&gt;&#xA;そのコネクションを用いてDBにアクセスしようとした時に本ネットワークエラーが発生してしまったと思われる。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;対応&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fix-write-broken-pipe-error/#%e5%af%be%e5%bf%9c&#34;&gt;対応&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/nyuusen/ayoze/commit/25719057cfc4a140f8e422d1e7aa8938f0eae769&#34;&gt;https://github.com/nyuusen/ayoze/commit/25719057cfc4a140f8e422d1e7aa8938f0eae769&lt;/a&gt; にて対応。&lt;br&gt;&#xA;アイドルコネクションの保持時間を4分(DBインスタンスが自動停止する5分より短い時間)に設定した。&lt;/p&gt;&#xA;&lt;p&gt;サーバレスDBを使うとこの辺りも考慮しなければいけないんだなという学びがあった。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>ゴールデンテスト</title>
      <link>http://localhost:1313/posts/golden-test/</link>
      <pubDate>Wed, 02 Apr 2025 23:32:55 +0900</pubDate>
      <guid>http://localhost:1313/posts/golden-test/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ゴールデンテストの目的&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/golden-test/#%e3%82%b4%e3%83%bc%e3%83%ab%e3%83%87%e3%83%b3%e3%83%86%e3%82%b9%e3%83%88%e3%81%ae%e7%9b%ae%e7%9a%84&#34;&gt;ゴールデンテストの目的&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;目的を一言で言うとシステムリグレッションを防ぎたい&#xA;&lt;ul&gt;&#xA;&lt;li&gt;システムリグレッションとはソフトウェアの機能改修やリファクタリングにより、機能の低下や仕様差異を発生させてしまうこと&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ゴールデンテストとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/golden-test/#%e3%82%b4%e3%83%bc%e3%83%ab%e3%83%87%e3%83%b3%e3%83%86%e3%82%b9%e3%83%88%e3%81%a8%e3%81%af&#34;&gt;ゴールデンテストとは&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;システムが過去の仕様と変更がないことを保証するためのリグレッションテスト手法&lt;/li&gt;&#xA;&lt;li&gt;具体的には、同じ内容でHTTPリクエストを実行した時に、同じ内容でHTTPレスポンスが返ってくることをテストする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;過去に実行したテスト結果をゴールデンファイルに保存し、再度実行したときに同じ結果が返ってくるかを確認する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ゴールデンテストを書いてみた&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/golden-test/#%e3%82%b4%e3%83%bc%e3%83%ab%e3%83%87%e3%83%b3%e3%83%86%e3%82%b9%e3%83%88%e3%82%92%e6%9b%b8%e3%81%84%e3%81%a6%e3%81%bf%e3%81%9f&#34;&gt;ゴールデンテストを書いてみた&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;// TODO&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/golden-test/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://swet.dena.com/entry/2020/03/16/173000&#34;&gt;Golden TestではじめるGoのAPI ServerのRegression Test - DeNA Testing Blog&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>ピュアなGo言語のみでWebアプリケーションを実装する</title>
      <link>http://localhost:1313/posts/pure-go-web-app/</link>
      <pubDate>Wed, 02 Apr 2025 23:32:55 +0900</pubDate>
      <guid>http://localhost:1313/posts/pure-go-web-app/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;概要&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/pure-go-web-app/#%e6%a6%82%e8%a6%81&#34;&gt;概要&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://zenn.dev/bigen1925/books/introduction-to-web-application-with-python&#34;&gt;伸び悩んでいる3年目Webエンジニアのための、Python Webアプリケーション自作入門&lt;/a&gt;をGoで実装した際のメモ帳。&#xA;実際のソースコードはこちら: &lt;a href=&#34;https://github.com/nyuusen/pure-go-web-app&#34;&gt;https://github.com/nyuusen/pure-go-web-app&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;※ピュアなGo言語といっても、低レイヤすぎる箇所(TCPコネクション等)は標準ライブラリを使用&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;tcpコネクションの確立&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/pure-go-web-app/#tcp%e3%82%b3%e3%83%8d%e3%82%af%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%ae%e7%a2%ba%e7%ab%8b&#34;&gt;TCPコネクションの確立&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;listener.Accept()&lt;/code&gt;でTCPコネクションを確立させる&lt;/li&gt;&#xA;&lt;li&gt;内部的には&lt;code&gt;TCPConn&lt;/code&gt;インスタンスを作成している&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Accept()&lt;/code&gt;の責務としては、&lt;code&gt;TCPConn&lt;/code&gt;インスタンスを作成するのみであり、以降のリクエスト/レスポンス処理は&lt;code&gt;TCPConn&lt;/code&gt;が行う&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;TCPConn&lt;/code&gt;については、&lt;a href=&#34;https://zenn.dev/hsaki/books/golang-io-package/viewer/netconn#%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%82%B3%E3%83%8D%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%28net.tcpconn%E3%81%AE%E6%AD%A3%E4%BD%93%29&#34;&gt;ネットワーク｜Goから学ぶI/O&lt;/a&gt;が参考になった。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ソケットとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/pure-go-web-app/#%e3%82%bd%e3%82%b1%e3%83%83%e3%83%88%e3%81%a8%e3%81%af&#34;&gt;ソケットとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ネットワーク通信のために作られるソフトウェア的な構造で、通信のエンドポイントとして機能する&lt;/li&gt;&#xA;&lt;li&gt;アプリケーションとネットワーク層を結びつけるインターフェースであり、TCP通信において重要な役割を果たしている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ソケットがやること&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/pure-go-web-app/#%e3%82%bd%e3%82%b1%e3%83%83%e3%83%88%e3%81%8c%e3%82%84%e3%82%8b%e3%81%93%e3%81%a8&#34;&gt;ソケットがやること&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アプリケーションが送信したデータをTCPプロトコルに渡してネットワーク層へ送信する&lt;/li&gt;&#xA;&lt;li&gt;逆に、ネットワーク層から受信したデータをアプリケーションに渡すこともする&lt;/li&gt;&#xA;&lt;li&gt;接続の確立や終了(3wayハンドシェイク)を管理する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;必要性&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/pure-go-web-app/#%e5%bf%85%e8%a6%81%e6%80%a7&#34;&gt;必要性&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;前提として、TCP通信はデータを送受信するために必ず双方向の通信チャネルが必要である&lt;/li&gt;&#xA;&lt;li&gt;この前提を満たすために、以下の理由で必要となる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ソケットがこのチャネルを作成・管理する役割を果たしている&lt;/li&gt;&#xA;&lt;li&gt;ソケットが接続情報(IPやポート番号)を保持する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1つのサーバーが複数のクライアントと通信する場合、ソケットごとに接続を管理する&lt;/li&gt;&#xA;&lt;li&gt;この仕組みがあることで、各クライアントとの通信が独立して行われる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;実装に落とし込むと&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/pure-go-web-app/#%e5%ae%9f%e8%a3%85%e3%81%ab%e8%90%bd%e3%81%a8%e3%81%97%e8%be%bc%e3%82%80%e3%81%a8&#34;&gt;実装に落とし込むと..&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;双方向の通信チャネルに必要ということで、サーバー側もクライアント側もソケットの作成が必要となる&lt;/li&gt;&#xA;&lt;li&gt;サーバー側&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ソケットを作成する&lt;/li&gt;&#xA;&lt;li&gt;ポートにバインドする&lt;/li&gt;&#xA;&lt;li&gt;接続してきたクライアントごとに新しいソケットを生成し、それぞれ独立した通信を行う(これは内部的に行われている?)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;クライアント側&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバーに接続するためのソケットを作成する(作成時に接続先の指定が必要)&lt;/li&gt;&#xA;&lt;li&gt;ソケットを通じてデータの送受信を行う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;独り言&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/pure-go-web-app/#%e7%8b%ac%e3%82%8a%e8%a8%80&#34;&gt;独り言&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;この辺りの知識があると、実装したコードとそのコードが何をやるのかがリンクしてよき&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;goにおけるビット演算子&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/pure-go-web-app/#go%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8b%e3%83%93%e3%83%83%e3%83%88%e6%bc%94%e7%ae%97%e5%ad%90&#34;&gt;Goにおけるビット演算子&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;参考: &lt;a href=&#34;https://zenn.dev/edash_tech_blog/articles/c0a3a5035e9196&#34;&gt;Go言語 ビット演算でのフラグ管理&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;  &#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 1100&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 0111&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;// ビット論理積を計算&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;and&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;AND: %04b\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;and&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;// ビット論理和を計算&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;or&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; | &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;OR: %04b\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;or&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ビット演算をする理由&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/pure-go-web-app/#%e3%83%93%e3%83%83%e3%83%88%e6%bc%94%e7%ae%97%e3%82%92%e3%81%99%e3%82%8b%e7%90%86%e7%94%b1&#34;&gt;ビット演算をする理由&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;osパッケージの中を見ていくとflagの比較等でビット演算を使用している処理を見かける&lt;/li&gt;&#xA;&lt;li&gt;単純にenumみたいにintegerで扱えば良いのに、なぜビット演算を行うのか調べてみた&lt;/li&gt;&#xA;&lt;li&gt;調べた感じ、以下のような理由があるらしい&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ビット演算はCPUが直接サポートする高速な処理であるから&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数値や文字列演算だとその分オーバーヘッドが発生し、メモリ効率も悪くなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;1つの整数値で、複数の状態や設定を管理することができるから(コードがコンパクトになる＋拡張性も高い)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えば1ビット目は新規作成するか、2ビット目はRead Onlyかとか..&lt;/li&gt;&#xA;&lt;li&gt;新しくフラグ管理したい要素が出た場合は、単純にその分のビットを追加すれば良いということになる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;POSIXやOS固有の低レベルAPI（例: syscall）との相性が良い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;osパッケージなどでは、この辺りを直接利用して処理を行うことが多い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ビット演算はC言語やUNIX系のシステムプログラミングで長く使用されてきた標準的な手法であるから&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;そもそもhttpとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/pure-go-web-app/#%e3%81%9d%e3%82%82%e3%81%9d%e3%82%82http%e3%81%a8%e3%81%af&#34;&gt;そもそもHTTPとは&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;TCPが「漏れなく順序よく」送るためのルール&lt;/li&gt;&#xA;&lt;li&gt;その上で何をどうやって送るかのルールを定義するのがHTTPやSFTPになる&lt;/li&gt;&#xA;&lt;li&gt;ここまで実装を進めたことで、以下の章が理解度が素晴らしい..&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zenn.dev/bigen1925/books/introduction-to-web-application-with-python/viewer/what-is-http&#34;&gt;HTTPとは？｜伸び悩んでいる3年目Webエンジニアのための、Python Webアプリケーション自作入門&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;レスポンスパーサの自作&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/pure-go-web-app/#%e3%83%ac%e3%82%b9%e3%83%9d%e3%83%b3%e3%82%b9%e3%83%91%e3%83%bc%e3%82%b5%e3%81%ae%e8%87%aa%e4%bd%9c&#34;&gt;レスポンスパーサの自作&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HTTPリクエストはリクエストライン,ヘッダー,ボディという構成になっている&lt;/li&gt;&#xA;&lt;li&gt;この構成のスペースの数や改行文字(CRLF)がきちんと定義されていることで安心してパースする&lt;/li&gt;&#xA;&lt;li&gt;この辺の処理を自作することで、HTTP含めプロトコルが定義されている理由やありがたみがわかるのがとても良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;post通信のフォーマットについて&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/pure-go-web-app/#post%e9%80%9a%e4%bf%a1%e3%81%ae%e3%83%95%e3%82%a9%e3%83%bc%e3%83%9e%e3%83%83%e3%83%88%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6&#34;&gt;POST通信のフォーマットについて&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;formタグのenctype属性で指定することが可能&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;デフォルト値&lt;/li&gt;&#xA;&lt;li&gt;URLに使用可能な文字のみ使用する&lt;/li&gt;&#xA;&lt;li&gt;別名URLエンコーディング&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;multipart/form-data&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ファイルを送信するとき使用する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;application/json&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;素のHTMLとブラウザの組み合わせでは使用できない&lt;/li&gt;&#xA;&lt;li&gt;JavaScriptのAjaxやAPI同士の通信でよく使用される(と思う)&lt;/li&gt;&#xA;&lt;li&gt;利点としては、各言語にエンコード/デコード機能が豊富にあること・配列を持てること・数値と文字列の区別ができることが挙げられる&lt;/li&gt;&#xA;&lt;li&gt;ただし、JSONはただのテキストデータなので、バイナリデータを送信することはできない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;これをサーバー側とクライアント側で同じフォーマットルールを共有することで、互いに解釈することができる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;フォーマットルールの共有にHTTPヘッダーのContent-Typeを利用しているというわけ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zenn.dev/bigen1925/books/introduction-to-web-application-with-python/viewer/post-parameters&#34;&gt;POSTパラメータを扱えるようにする｜伸び悩んでいる3年目Webエンジニアのための、Python Webアプリケーション自作入門&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>ポインタとガベージコレクション</title>
      <link>http://localhost:1313/posts/pointer-gabage-collection/</link>
      <pubDate>Wed, 02 Apr 2025 23:32:55 +0900</pubDate>
      <guid>http://localhost:1313/posts/pointer-gabage-collection/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/pointer-gabage-collection/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Goで関数の戻り値としてポインタを返しすぎると、ガベージコレクション(GC)も負担が増えるという問題について調べたのでメモする&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;スタックとヒープ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/pointer-gabage-collection/#%e3%82%b9%e3%82%bf%e3%83%83%e3%82%af%e3%81%a8%e3%83%92%e3%83%bc%e3%83%97&#34;&gt;スタックとヒープ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;まずは前提として、スタックとヒープを理解する必要がある。&lt;br&gt;&#xA;プログラムがデータを保存するメモリ領域として、スタックとヒープというものが存在する。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;スタック&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/pointer-gabage-collection/#%e3%82%b9%e3%82%bf%e3%83%83%e3%82%af&#34;&gt;スタック&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;関数の中で宣言された一時的なローカル変数が保存される場所&lt;/li&gt;&#xA;&lt;li&gt;関数が終わると自動的に消えるので、管理が簡単で高速&lt;/li&gt;&#xA;&lt;li&gt;小さいデータはスタックに置かれることが多い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ヒープ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/pointer-gabage-collection/#%e3%83%92%e3%83%bc%e3%83%97&#34;&gt;ヒープ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プログラムのどこからでもアクセスできるデータを保存する場所&lt;/li&gt;&#xA;&lt;li&gt;プログラムが明示的に消すまでメモリに残る&#xA;&lt;ul&gt;&#xA;&lt;li&gt;それ故に不要なデータが増えるとメモリを圧迫する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ポインタで管理されるデータはヒープに保存されることが多い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;関数のスコープを超えて存続する可能性があるデータであるため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;gcの必要性&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/pointer-gabage-collection/#gc%e3%81%ae%e5%bf%85%e8%a6%81%e6%80%a7&#34;&gt;GCの必要性&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;上で述べたが「ヒープに確保されたデータは明示的に消さない限り残り続ける」という問題を解決するための仕組み&lt;/li&gt;&#xA;&lt;li&gt;具体的には、GCが動いて、不要なデータを自動的に回収する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不要なデータを回収するから「ガベージコレクション」という&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;GCにより、開発者が手動でメモリを解放しなくても、安全にメモリ管理が可能となる&lt;/li&gt;&#xA;&lt;li&gt;一方、GCが頻繁に動くと、プログラムの動作が遅くなることがある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ポインタを返しすぎるとgcの負担が増える問題まとめ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/pointer-gabage-collection/#%e3%83%9d%e3%82%a4%e3%83%b3%e3%82%bf%e3%82%92%e8%bf%94%e3%81%97%e3%81%99%e3%81%8e%e3%82%8b%e3%81%a8gc%e3%81%ae%e8%b2%a0%e6%8b%85%e3%81%8c%e5%a2%97%e3%81%88%e3%82%8b%e5%95%8f%e9%a1%8c%e3%81%be%e3%81%a8%e3%82%81&#34;&gt;ポインタを返しすぎるとGCの負担が増える問題まとめ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ポインタで管理されるデータヒープに保存される(ことが多い)&lt;/li&gt;&#xA;&lt;li&gt;ヒープのデータは自動的には消されないので、GCという仕組みにより、不要なデータが回収される&lt;/li&gt;&#xA;&lt;li&gt;つまりポインタを使いすぎるとその分GCが動くので、それにより処理が遅くなるといった問題が発生する可能性がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;余談-gcはどのようにしていつ動いているのか&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/pointer-gabage-collection/#%e4%bd%99%e8%ab%87-gc%e3%81%af%e3%81%a9%e3%81%ae%e3%82%88%e3%81%86%e3%81%ab%e3%81%97%e3%81%a6%e3%81%84%e3%81%a4%e5%8b%95%e3%81%84%e3%81%a6%e3%81%84%e3%82%8b%e3%81%ae%e3%81%8b&#34;&gt;余談: GCはどのようにして、いつ動いているのか？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;どのように動く？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;バックグラウンドで走り続け、不要なメモリを検出すると解放する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;いつ動く？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;自動的に適切なタイミングで実行される&lt;/li&gt;&#xA;&lt;li&gt;手動実行も可能(&lt;code&gt;runtime.GC()&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;発展&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GCが動くと不要なメモリが解放される一方、CPU使用率が一時的に上がってしまう可能性がある&lt;/li&gt;&#xA;&lt;li&gt;そのため、GCの回数を減らす工夫として、小さい構造体なら値で返したり等でスタックを活用するということが考えられる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>依存パッケージのアップデート方法</title>
      <link>http://localhost:1313/posts/how-to-update-deps/</link>
      <pubDate>Wed, 02 Apr 2025 23:32:55 +0900</pubDate>
      <guid>http://localhost:1313/posts/how-to-update-deps/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;概要&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/how-to-update-deps/#%e6%a6%82%e8%a6%81&#34;&gt;概要&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Goのプロジェクトにおいて、依存パッケージをアップデート方法を記載する&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;やり方&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/how-to-update-deps/#%e3%82%84%e3%82%8a%e6%96%b9&#34;&gt;やり方&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;go.sumファイルを削除する&lt;/li&gt;&#xA;&lt;li&gt;go.modファイルのgoのバージョン表記から下を削除する&lt;/li&gt;&#xA;&lt;li&gt;go mod tidyを実行する&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;手順1と2を行うことで、インストール済みのパッケージのチェックサムとバージョン情報が削除される。&lt;br&gt;&#xA;手順3で、必要な依存解決を1から実行してくれるので、結果的にパッケージのバージョンが上がったりする(もちろんバージョンが変わらないものもある)&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>関数型にインターフェイスを実装する</title>
      <link>http://localhost:1313/posts/impl-interface-to-function/</link>
      <pubDate>Wed, 02 Apr 2025 23:32:55 +0900</pubDate>
      <guid>http://localhost:1313/posts/impl-interface-to-function/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/impl-interface-to-function/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Goの特徴として、構造体にメソッドを定義する以外に関数型にもインターフェイスを実装できる。&lt;/p&gt;&#xA;&lt;p&gt;net/httpパッケージを例に調べてみたのでメモ。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;関数型にインターフェイスを実装とはをnethttpパッケージを例に理解する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/impl-interface-to-function/#%e9%96%a2%e6%95%b0%e5%9e%8b%e3%81%ab%e3%82%a4%e3%83%b3%e3%82%bf%e3%83%bc%e3%83%95%e3%82%a7%e3%82%a4%e3%82%b9%e3%82%92%e5%ae%9f%e8%a3%85%e3%81%a8%e3%81%af%e3%82%92nethttp%e3%83%91%e3%83%83%e3%82%b1%e3%83%bc%e3%82%b8%e3%82%92%e4%be%8b%e3%81%ab%e7%90%86%e8%a7%a3%e3%81%99%e3%82%8b&#34;&gt;関数型にインターフェイスを実装とは？をnet/httpパッケージを例に理解する&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;前提として、今回題材にするnet/httpパッケージのhttp.Handlerインターフェイスについて理解しておく。&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Handler&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;ServeHTTP&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;ResponseWriter&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Request&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;p&gt;Handlerは、ServeHTTPというメソッドを定義しているインターフェイスである。&lt;br&gt;&#xA;中身としては、Handlerという名の通り、HTTPリクエストを受けて、HTTPレスポンスを返す処理が記述されるものである。&lt;/p&gt;&#xA;&lt;p&gt;本題に入るが、まずは違いをわかりやすくするために、通常の(よくある)方法である「構造体とメソッドを使ってインターフェイスを実装する」の実装例を書いてみる。&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;net/http&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 構造体定義&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyHandler&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt;{}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 構造体メソッドでインターフェイスを実装&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyHandler&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;ServeHTTP&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ResponseWriter&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Request&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fprintln&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, World!&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;handler&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyHandler&lt;/span&gt;{}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Handle&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/hello&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;handler&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ListenAndServe&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:8080&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;p&gt;MyHandlerという構造体に対し、Handlerインターフェイスを満たすServeHTTPというメソッドの実装を行なっている。&lt;br&gt;&#xA;その後、main関数内でMyHandlerインスタンスを生成し、http.Handleに渡すことで、パスに対してハンドラーを登録している。&lt;/p&gt;&#xA;&lt;p&gt;次に「関数型を使ったインターフェイスを実装する」の実装例を書いてみる。&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;net/http&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;helloHandler&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ResponseWriter&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Request&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fprintln&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, World!&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;HandleFunc&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/hello&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;helloHandler&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ListenAndServe&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:8080&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;p&gt;helloHandlerというfunc(http.ResponseWriter, *http.Request)シグネチャの関数を実装する。　&lt;br&gt;&#xA;&amp;hellip;あれ、ハンドラーを定義するHandlerインターフェイスとハンドラーを登録するHandleはどこにいった&amp;hellip;？&lt;/p&gt;&#xA;&lt;p&gt;今回登場したhttp.HandlerFuncは、以下のように定義されている。&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HandlerFunc&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ResponseWriter&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Request&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HandlerFunc&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;ServeHTTP&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ResponseWriter&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Request&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;p&gt;HandlerFuncという関数型に対し、ServeHTTPメソッドが実装されている。&lt;br&gt;&#xA;つまり、以下のhelloHandlerの実装時点＝HandlerFunc型の実装時点で自動的にServeHTTPというメソッドの実装が行われている。&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;helloHandler&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ResponseWriter&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Request&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fprintln&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, World!&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;p&gt;HandlerFuncを使用してハンドラーを実装した場合は、HandleFuncでハンドラーを登録する。&lt;br&gt;&#xA;両者の違いとしては、Handleの第2引数にはHandlerインターフェイスを実装しているハンドラーを登録するものであり、&lt;br&gt;&#xA;HandlerFuncの第2引数には、単純な関数をハンドラーとして登録するものである。&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Handle&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;pattern&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;handler&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Handler&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HandleFunc&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;pattern&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;handler&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;ResponseWriter&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Request&lt;/span&gt;))&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;整理すると&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/impl-interface-to-function/#%e6%95%b4%e7%90%86%e3%81%99%e3%82%8b%e3%81%a8&#34;&gt;整理すると&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;ハンドラーの登録&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;Handle or HandleFunc&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;ハンドラーの実装&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;Handler or HandlerFunc&lt;/p&gt;&#xA;&lt;p&gt;特段理由がなければ、短く書ける後者の方を選択するケースが多いと思われる。&#xA;HandlerFuncを使うとServeHTTPを実装する(空の)構造体をわざわざ作らなくて良いのがポイント。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;最後に&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/impl-interface-to-function/#%e6%9c%80%e5%be%8c%e3%81%ab&#34;&gt;最後に&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;あれどっちがどっちだっけってよくなってたけど、今回まとめたから流石に覚えた（多分)&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/impl-interface-to-function/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://pkg.go.dev/net/http#Handler&#34;&gt;http package - net/http - Go Packages&lt;/a&gt;&#xA;&lt;a href=&#34;https://journal.lampetty.net/entry/understanding-http-handler-in-go&#34;&gt;Goのhttp.Handlerやhttp.HandlerFuncをちゃんと理解する - oinume journal&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>コネクション</title>
      <link>http://localhost:1313/posts/connection/</link>
      <pubDate>Thu, 27 Mar 2025 22:12:34 +0900</pubDate>
      <guid>http://localhost:1313/posts/connection/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;コネクションやコネクションプールについて&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/connection/#%e3%82%b3%e3%83%8d%e3%82%af%e3%82%b7%e3%83%a7%e3%83%b3%e3%82%84%e3%82%b3%e3%83%8d%e3%82%af%e3%82%b7%e3%83%a7%e3%83%b3%e3%83%97%e3%83%bc%e3%83%ab%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6&#34;&gt;コネクションやコネクションプールについて&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アプリケーション側で接続先のDB情報とともにコネクションIDを保持し、データベース側ではコネクションIDとそれに対応したプロセスIDを保持する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;上記をメモリ上に保持しておくことで、接続情報を使い回すことができる（コネクションプール）&lt;/li&gt;&#xA;&lt;li&gt;再利用しない場合は、アプリケーション側でコネクションクローズ処理を忘れずに&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;基本的にはDBサーバー側には最大接続数があるので、アプリケーション側ではそれを超えないようにコネクションプールを実装する必要がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;実装する必要があると言っても、基本的にはライブラリがよしなにやってくれるので、DBインスタンス初期化時に最大接続数の設定をするくらいで良いと思われる&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Managing.Performance.html&#34;&gt;Amazon Aurora MySQL のパフォーマンスとスケーリングの管理 - Amazon Aurora&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;アプリケーション側でのコネクション管理の詳細&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/connection/#%e3%82%a2%e3%83%97%e3%83%aa%e3%82%b1%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%e5%81%b4%e3%81%a7%e3%81%ae%e3%82%b3%e3%83%8d%e3%82%af%e3%82%b7%e3%83%a7%e3%83%b3%e7%ae%a1%e7%90%86%e3%81%ae%e8%a9%b3%e7%b4%b0&#34;&gt;アプリケーション側でのコネクション管理の詳細&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最大接続数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;少なすぎると処理待ちが多くなるし、多すぎるとDB側に負荷がかかる&lt;/li&gt;&#xA;&lt;li&gt;DB側の最大接続数を超えないようにする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えばRDSだと、インスタンスタイプによって異なるので注意&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;最大アイドル時間&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アクティブでないコネクションをどれくらいの時間維持するか&lt;/li&gt;&#xA;&lt;li&gt;長すぎると不要なコネクションが増えてリソースが無駄になるし、短すぎるとコネクションの再作成が頻発してオーバーヘッドが増える&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;最大生存期間&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1つのコネクションが使われ続ける最大時間&lt;/li&gt;&#xA;&lt;li&gt;DBの設定によっては、一定の時間でコネクションが強制的に切られることがあるので、アプリケーション側で事前に適切なタイミングで切ることで予期せぬエラーを防ぐ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;rds-proxyというアプローチ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/connection/#rds-proxy%e3%81%a8%e3%81%84%e3%81%86%e3%82%a2%e3%83%97%e3%83%ad%e3%83%bc%e3%83%81&#34;&gt;RDS Proxyというアプローチ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コネクションの管理を良い感じにマネージド管理してくれるのがRDS Proxyである&lt;/li&gt;&#xA;&lt;li&gt;詳細は&lt;a href=&#34;https://github.com/nyuusen/TIL/blob/de7727820ca1fc9f8e3f39003df022446116edfc/reading/003_AWS%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89.md#rds-proxy&#34;&gt;ここ&lt;/a&gt;に色々まとめている&lt;/li&gt;&#xA;&lt;li&gt;RDS Proxy自身は、VPC内のENIを使って、RDSに接続する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Proxyのスケールに応じて、ENIが多く使用される＝IP枯渇問題が発生する可能性がある点に注意&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サブネットのCIDR範囲はあらかじめ広めにしておくとかの対策&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>CloudFront</title>
      <link>http://localhost:1313/posts/cloudfront/</link>
      <pubDate>Wed, 19 Mar 2025 22:10:29 +0900</pubDate>
      <guid>http://localhost:1313/posts/cloudfront/</guid>
      <description>&lt;p&gt;なんとなく使っているCloudFrontを理解したい。&#xA;多分何が設定できるかを理解できたら使い方がわかるはずだからまずは設定できる内容を調査する。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;基本用語&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cloudfront/#%e5%9f%ba%e6%9c%ac%e7%94%a8%e8%aa%9e&#34;&gt;基本用語&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CloudFrontディストリビューション:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ユーザーが設定(作成)するCloudFrontリソース&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ビヘイビア:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;振り分けルール&lt;/li&gt;&#xA;&lt;li&gt;パスパターンでオリジンを振り分ける&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;/api/*&lt;/code&gt;はALBに、&lt;code&gt;/image/*&lt;/code&gt;はS3にみたいな&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ビューア/オリジン&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クライアント ==== ビューアリクエスト ==== CloudFrontディストリビューション ==== オリジンリクエスト ==== オリジン といった感じ。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;「リクエスト」の部分を「レスポンス」に置き換えると、ビューア/オリジンレスポンスの説明になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ビューア/オリジンリクエスト/レスポンスにはCloudFront Functionを割り当てることが可能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えば、Authorizationヘッダを検証してBasic検証するとか&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ディストリビューションに設定できること&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cloudfront/#%e3%83%87%e3%82%a3%e3%82%b9%e3%83%88%e3%83%aa%e3%83%93%e3%83%a5%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%ab%e8%a8%ad%e5%ae%9a%e3%81%a7%e3%81%8d%e3%82%8b%e3%81%93%e3%81%a8&#34;&gt;ディストリビューションに設定できること&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- コンテンツオリジン — CloudFront が配信するファイルの取得元である Amazon S3 バケット、AWS Elemental MediaPackage チャネル、AWS Elemental MediaStore コンテナ、Elastic Load Balancing ロードバランサー、または HTTP サーバーです。1 つのディストリビューションで、最大で 25 のオリジンの任意に組み合わせて指定できます。&#xA;&#xA;- アクセス - ファイルをすべてのユーザーが使用できるようにするか、または一部のユーザーにアクセスを制限するか。&#xA;&#xA;- セキュリティ - AWS WAF 保護を有効にして、HTTPS を使用したコンテンツへのアクセスを必須にするかどうか。&#xA;&#xA;- キャッシュキー - キャッシュキーに含める値 (存在する場合)。キャッシュキーは、特定のディストリビューションのキャッシュ内の各ファイルを一意に識別します。&#xA;&#xA;- オリジンリクエスト設定 - CloudFront でオリジンに送信するリクエストに HTTP ヘッダー、Cookie、またはクエリ文字列を含めるかどうか。&#xA;&#xA;- 地理的制限 — CloudFront で特定の国のユーザーがコンテンツにアクセスできないようにするかどうか。&#xA;&#xA;- ログ — CloudFront で標準ログを作成するか、ビューワーのアクティビティを示すリアルタイムログを作成するかどうか。&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;ref: &lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/AmazonCloudFront/latest/DeveloperGuide/distribution-working-with.html&#34;&gt;ディストリビューションの設定 - Amazon CloudFront&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>AWS運用入門</title>
      <link>http://localhost:1313/posts/007_aws%E9%81%8B%E7%94%A8%E5%85%A5%E9%96%80/</link>
      <pubDate>Tue, 18 Mar 2025 21:43:29 +0900</pubDate>
      <guid>http://localhost:1313/posts/007_aws%E9%81%8B%E7%94%A8%E5%85%A5%E9%96%80/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.sbcr.jp/product/4815615499/&#34;&gt;AWS運用入門 | SBクリエイティブ&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;chapter9-セキュリティ統制&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/007_aws%E9%81%8B%E7%94%A8%E5%85%A5%E9%96%80/#chapter9-%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3%e7%b5%b1%e5%88%b6&#34;&gt;Chapter9 セキュリティ統制&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;waf&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/007_aws%E9%81%8B%E7%94%A8%E5%85%A5%E9%96%80/#waf&#34;&gt;WAF&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SGでは4層のトランスポート層レベルの脅威から守ることができるが、通信内容(パケット)まではチェックすることはできない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例にすると、監視カメラで宅配業者を通過させることができるが、荷物の中身までは見えない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;WAFでは、CloudFront, ALB, API Gateway, AppSyncにWeb Access Control List(Web ACL)を関連づけることで動作する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Web ACLとは、WAFが通信内容を検査する際に適用するルールのことで、1つのWeb ACLに複数の検査ルールを定義することが可能&lt;/li&gt;&#xA;&lt;li&gt;1つのAWSリソースに対して、1つのWeb ACLのみ関連づけが可能である&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Web ACLで定義するルールは、JSON形式のStatementとして、そのStatementに「合致あるいは不一致の場合に検査した通信を許可するのか拒否するのか」をActionとして定義する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ルールで定義する条件には、IPアドレス・HTTPヘッダー・HTTP本文・URL文字列・SQLインジェクション・XSSがある&lt;/li&gt;&#xA;&lt;li&gt;定義可能なルールとして、AWSが提供するマネージドルールとユーザーが独自に作成可能なカスタムルールの2つがある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;適用可能なルール数はAWS WAF Web ACL capacity units(WCU)によって制限される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;WCUは、検査にかかるコストを表現したもので、5000WCUsが上限である&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;サーバー側の暗号化&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/007_aws%E9%81%8B%E7%94%A8%E5%85%A5%E9%96%80/#%e3%82%b5%e3%83%bc%e3%83%90%e3%83%bc%e5%81%b4%e3%81%ae%e6%9a%97%e5%8f%b7%e5%8c%96&#34;&gt;サーバー側の暗号化&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;電子データにおける暗号化には「通信の暗号化」と「データの暗号化」がある&lt;/li&gt;&#xA;&lt;li&gt;変換方法を「アルゴリズム」、変換ルールを「キー（鍵）」という&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例：シーザー暗号（アルファベットを辞書順に3文字ずらして暗号文を作る」&#xA;&lt;ul&gt;&#xA;&lt;li&gt;この時の「アルファベットを辞書順にずらす」というのをアルゴリズム、「3文字」がキーとなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;現在普及しているアルゴリズムは仕様が全て公開されている（外部の専門家から弱点を指摘してもらい、より強固なアルゴリズムを構築するため）&lt;/li&gt;&#xA;&lt;li&gt;なので、暗号化においては「キーの取り扱い」がセキュリティを担保する上で重要となる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;「アルゴリズム」は公開されているので、「キー」の方を大事に取り扱いましょうという話&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;aws-kms&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/007_aws%E9%81%8B%E7%94%A8%E5%85%A5%E9%96%80/#aws-kms&#34;&gt;AWS KMS&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;KMSは、データ保護に使用される暗号鍵の作成・管理・運用基盤を提供するサービス&lt;/li&gt;&#xA;&lt;li&gt;保管データの暗号化だけでなく、「キー」自体も暗号化することでセキュリティを高めている&lt;/li&gt;&#xA;&lt;li&gt;保管データを暗号化する暗号鍵をCustomer Data Key(CDK)、CDKを暗号化するための暗号鍵をCustomer Master Key(CMK)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;暗号化時にKMSはCDKを都度生成するので、ユーザー側ではCDKは管理することができない&lt;/li&gt;&#xA;&lt;li&gt;よってユーザーはCMKの作成・管理・運用を行うことになる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CMKの運用・管理を「ライフサイクル」と「アクセス」という2つの観点から考える&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;cmkのライフサイクル管理&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/007_aws%E9%81%8B%E7%94%A8%E5%85%A5%E9%96%80/#cmk%e3%81%ae%e3%83%a9%e3%82%a4%e3%83%95%e3%82%b5%e3%82%a4%e3%82%af%e3%83%ab%e7%ae%a1%e7%90%86&#34;&gt;CMKのライフサイクル管理&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;キーローテーションと削除スケジュールの2つがある&lt;/li&gt;&#xA;&lt;li&gt;1年に1回、自動でローテーションされる&lt;/li&gt;&#xA;&lt;li&gt;ローテーションの前後で作成されたCMKは世代管理されている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;注意点として、削除されたCMKで暗号化されたデータは復号できなくなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;そこで登場するのが削除スケジュールであり、削除までの一定の期間を待機状態とさせることができる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;cmkのアクセス管理&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/007_aws%E9%81%8B%E7%94%A8%E5%85%A5%E9%96%80/#cmk%e3%81%ae%e3%82%a2%e3%82%af%e3%82%bb%e3%82%b9%e7%ae%a1%e7%90%86&#34;&gt;CMKのアクセス管理&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;誰がどのような権限で利用できるかをキーポリシーで定義する&lt;/li&gt;&#xA;&lt;li&gt;キーポリシーは「リソースベースポリシー」に該当するため、IAMポリシーよりも優先度が高い&lt;/li&gt;&#xA;&lt;li&gt;Principalには街頭のリソースへのアクセスを許可・拒否するエンティティを指定する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;誰が・どのような人がにあたる部分で、AWSアカウント全体、IAMユーザーやロールを指定する、特定のサービス（Lambdaとか）が指定可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>## AWSで実装する場合</title>
      <link>http://localhost:1313/posts/basic-auth-on-aws/</link>
      <pubDate>Sun, 16 Mar 2025 22:15:01 +0900</pubDate>
      <guid>http://localhost:1313/posts/basic-auth-on-aws/</guid>
      <description>&lt;p&gt;以下のどちらかで実装が可能&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;WAF&lt;/li&gt;&#xA;&lt;li&gt;CloudFront Functions&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;それぞれを比較してみる（Lambda@Edgeも可能だが、CFFできるなら&amp;hellip;と思い、選択肢から外した）&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;waf&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic-auth-on-aws/#waf&#34;&gt;WAF&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;WebACLのルールグループにヘッダに関するStatementを記述する形で実装する&lt;/li&gt;&#xA;&lt;li&gt;Block時のカスタムレスポンスとして、ヘッダにWWW-Authenticateを返すことも可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;cloudfront-functions&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic-auth-on-aws/#cloudfront-functions&#34;&gt;CloudFront Functions&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://iret.media/95931&#34;&gt;https://iret.media/95931&lt;/a&gt; みたいな感じで手軽に実装可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;どっちが良いか&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/basic-auth-on-aws/#%e3%81%a9%e3%81%a3%e3%81%a1%e3%81%8c%e8%89%af%e3%81%84%e3%81%8b&#34;&gt;どっちが良いか？&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;手軽さと「CloudFront Functions」だと思う&lt;/li&gt;&#xA;&lt;li&gt;ただし、既にCFのViewer RequestにCFFを割り当てている場合やWAFを既に利用している環境ではWAFの利用もアリなのではと思った&#xA;&lt;ul&gt;&#xA;&lt;li&gt;実際、私が業務で対応した際は、IP制限を既にWAFを利用しており、IP制限外からでもBasic認証情報が検証できればリクエストを通したいといった要件だったので、WAFを採用した（したい）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Basic認証</title>
      <link>http://localhost:1313/posts/basic-auth/</link>
      <pubDate>Sun, 16 Mar 2025 22:15:01 +0900</pubDate>
      <guid>http://localhost:1313/posts/basic-auth/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;username:passwordをBase64エンコードしてAuthorizationヘッダにセットする&lt;/li&gt;&#xA;&lt;li&gt;なぜbase64エンコードするのか？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;base64は暗号化ではなくデコードが容易&lt;/li&gt;&#xA;&lt;li&gt;base64エンコードすることでASCII文字で表現できるため(ヘッダはASCII文字で構成される)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サーバー側の認証(照合)処理では単純な文字列比較ではなく、タイミング攻撃を考え、以下のような実装にするのが推奨される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zenn.dev/foxtail88/articles/constant-time-compare&#34;&gt;https://zenn.dev/foxtail88/articles/constant-time-compare&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;WWW-Authenticateで認証チャレンジを定義可能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えば、&lt;code&gt;WWW-Authenticate: Basic&lt;/code&gt; とした場合は、Basic認証情報を入力させるダイアログを表示させて、ユーザーに入力をリクエストすることが可能&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/WWW-Authenticate&#34;&gt;https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/WWW-Authenticate&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>ecspresso</title>
      <link>http://localhost:1313/posts/ecspresso/</link>
      <pubDate>Wed, 12 Mar 2025 23:29:34 +0900</pubDate>
      <guid>http://localhost:1313/posts/ecspresso/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/ecspresso/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ECSデプロイツールであるecspressoについてまとめてみた。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ecspressoとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/ecspresso/#ecspresso%e3%81%a8%e3%81%af&#34;&gt;ecspressoとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;発音は「エスプレッソ」&lt;/li&gt;&#xA;&lt;li&gt;Amazon ECSのためのデプロイツール&lt;/li&gt;&#xA;&lt;li&gt;タスク定義とサービスをファイルで管理する&lt;/li&gt;&#xA;&lt;li&gt;Goで実装され、シングルバイナルとして動作するCLI&lt;/li&gt;&#xA;&lt;li&gt;ソースコード: &lt;a href=&#34;https://github.com/kayac/ecspresso&#34;&gt;https://github.com/kayac/ecspresso&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OSS(MIT LICENSE)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;必要なもの&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/ecspresso/#%e5%bf%85%e8%a6%81%e3%81%aa%e3%82%82%e3%81%ae&#34;&gt;必要なもの&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ecspressoを用いてECSデプロイを行うには以下が必要である&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;インフラリソース&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ecspressoはインフラリソースを作成・管理する機能はないため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ecspresso(CLI)のインストール&lt;/li&gt;&#xA;&lt;li&gt;ecspressoの設定情報を定義するYAMLファイル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用するリージョンやECSクラスター/サービス/タスク定義のJSONファイル名等を記述する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;タスク及びサービスの設定情報を定義するJSONファイル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWS CLI互換のJSONファイル&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;上記を用意した上で、ecspressoコマンドを実行すると、デプロイ等を実行してくれる&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;設計思想特徴&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/ecspresso/#%e8%a8%ad%e8%a8%88%e6%80%9d%e6%83%b3%e7%89%b9%e5%be%b4&#34;&gt;設計思想・特徴&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;基本的には「ECSのデプロイに関わる最小限のリソースのみを管理するツール」が主な設計思想である。&lt;br&gt;&#xA;どのような問題を解決するのかも含め、詳細については以下に記載する。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サービスとタスク定義の管理に特化されている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;他のリソース(ex:VPCやRDS等)に比べ、タスク定義とサービスはデプロイの度に更新される&lt;/li&gt;&#xA;&lt;li&gt;これらを単一のツールで管理するとなると、意図しない変更による障害発生のリスクが上がってしまう&lt;/li&gt;&#xA;&lt;li&gt;ライフサイクルが異なるから、それぞれ別のツールを使った方が安全&lt;/li&gt;&#xA;&lt;li&gt;さらに、アプリケーションデプロイには、アプリケーション側の知識(環境情報等)が必要なので、インフラ担当者じゃなくても扱いやすくなるというメリットもある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Amazon ECS専用のツールとして作られている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;抽象度が高くならないため、理解が容易＋機能追加への追従も容易(作者談)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;設定ファイルを作成する手間を削減&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ecspresso initコマンドを利用することで、既にECSサービスから情報を参照して、ベースとなるJSONファイルを生成してくれる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;なぜ必要か&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/ecspresso/#%e3%81%aa%e3%81%9c%e5%bf%85%e8%a6%81%e3%81%8b&#34;&gt;なぜ必要か？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;そもそもTerraformがあればこのようなツールじゃないの？みたいな疑問をまず持ったので、持論を混ぜつつなぜ必要かをまとめる&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;前提として、ECSタスクのデプロイには、タスク定義内容の変更(対象のイメージタグの変更)およびサービスの更新が必要になる&lt;/li&gt;&#xA;&lt;li&gt;その上で、インフラリソースとアプリケーションのライフサイクルは異なることがほとんど&#xA;&lt;ul&gt;&#xA;&lt;li&gt;というか一緒にすべきでもないし、組織によってはアプリケーションとインフラで管理の主体が異なることも多く、色々と不健全&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;なので。IaCでECSクラスタ/サービス/タスク定義のリソースを作成するというインフラリソース管理とは別に、アプリケーションデプロイのみを目的するために使用するというのが必要な理由となる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ecspressoの機能と使い方&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/ecspresso/#ecspresso%e3%81%ae%e6%a9%9f%e8%83%bd%e3%81%a8%e4%bd%bf%e3%81%84%e6%96%b9&#34;&gt;ecspressoの機能と使い方&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kayac/ecspresso&#34;&gt;README&lt;/a&gt;に書かれている内容をもとにコマンドごとの機能と使い方を簡単に見てみる。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;init: 設定ファイル生成&lt;/li&gt;&#xA;&lt;li&gt;deploy: サービス更新&#xA;&lt;ul&gt;&#xA;&lt;li&gt;多分これが一番使うやつ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;run: タスク実行&#xA;&lt;ul&gt;&#xA;&lt;li&gt;単発実行するようなタスクを動かすものだと思われる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;基本的な使い方はかなり簡単&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;設定ファイル生成&lt;/li&gt;&#xA;&lt;li&gt;タスク定義ファイルのimageフィールドの値を{{ must_env &lt;code&gt;IMAGE_TAG&lt;/code&gt; }}のような形にする&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;IMAGE_TAG=stable ecspresso deploy --config ecspresso.yml&lt;/code&gt;のように環境変数IMAGE_TAGにイメージタグをセットし、ecspresso deployコマンドを実行する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;terraformとの共存&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/ecspresso/#terraform%e3%81%a8%e3%81%ae%e5%85%b1%e5%ad%98&#34;&gt;terraformとの共存&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;terraformで先にECS Service/Taskを作成する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;lifecycle ignore_changes=allを設定することで、以降は変更検知せずにterraformではスルーさせることができる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;その後はecspresso設定ファイルを編集することで、タスク定義の変更等を行い、ecspressoでアプリケーションデプロイができるようになる&lt;/li&gt;&#xA;&lt;li&gt;こうすることで、本来あるべきインフラとアプリのライフサイクルに沿った運用が可能になりそう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考リンク&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/ecspresso/#%e5%8f%82%e8%80%83%e3%83%aa%e3%83%b3%e3%82%af&#34;&gt;参考リンク&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/fujiwara3/amazon-ecs-depuroituru-ecspresso-kai-fa-5nian-nobu-mi?slide=29&#34;&gt;Amazon ECS デプロイツール ecspresso 開発5年の歩み - Speaker Deck&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zenn.dev/fujiwara/books/ecspresso-handbook-v2&#34;&gt;ecspresso handbook v2対応版&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Terraform</title>
      <link>http://localhost:1313/posts/terraform/</link>
      <pubDate>Sun, 09 Mar 2025 22:36:07 +0900</pubDate>
      <guid>http://localhost:1313/posts/terraform/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/terraform/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;業務で雰囲気で触っているTerraformをきちんと学んでみる。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;コマンド群&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/terraform/#%e3%82%b3%e3%83%9e%e3%83%b3%e3%83%89%e7%be%a4&#34;&gt;コマンド群&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;init&#xA;&lt;ul&gt;&#xA;&lt;li&gt;実行するディレクトリにおける準備を行う&lt;/li&gt;&#xA;&lt;li&gt;以下が生成される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;.terraform/ : providerの実体が置かれる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これはコマンドを実行するディレクトリごとに作成されるので、離任したプロジェクトのもの等を放置しているとそれなりに容量を食ってしまう点に注意&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;.terraform.lock.hcl : providerの同じバージョンを使うためのファイル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これはinitの度に作成されるので、CI上でterraform init -&amp;gt; plan -&amp;gt; applyと実行すると、結局バージョン固定されないので、どういう運用が良いかは別途考えたい(そもそもこのファイルの存在意義&amp;hellip;)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;plan&#xA;&lt;ul&gt;&#xA;&lt;li&gt;構築するインフラの計画を行う&lt;/li&gt;&#xA;&lt;li&gt;stateファイルとterraformコードを比較し、差分計算する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;apply&#xA;&lt;ul&gt;&#xA;&lt;li&gt;実際にリソースの作成等を行う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;destroy&#xA;&lt;ul&gt;&#xA;&lt;li&gt;インフラの削除を行う&lt;/li&gt;&#xA;&lt;li&gt;正式にはapply -destroyである&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;tips&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/terraform/#tips&#34;&gt;Tips&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;standard-module-structure&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/terraform/#standard-module-structure&#34;&gt;Standard Module Structure&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;公式による基本構成に関する説明&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://developer.hashicorp.com/terraform/language/modules/develop/structure&#34;&gt;https://developer.hashicorp.com/terraform/language/modules/develop/structure&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;変数定義&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/terraform/#%e5%a4%89%e6%95%b0%e5%ae%9a%e7%be%a9&#34;&gt;変数定義&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Terraformでは&lt;code&gt;variables.tf&lt;/code&gt;を用いて変数を定義し、その変数を&lt;code&gt;var.&lt;/code&gt;の形で参照することができる&#xA;&#xA;  &#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-variables.tf&#34; data-lang=&#34;variables.tf&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;variable&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;allow_ssh&amp;#34;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bool&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;default&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;値を何もセットしなかった場合はterraform planやapplyコマンド実行時にCLIで聞かれる(対話形式でコマンド実行が進むイメージ)&lt;/li&gt;&#xA;&lt;li&gt;値をセットする方法としては、&lt;a href=&#34;https://developer.hashicorp.com/terraform/language/values/variables#assigning-values-to-root-module-variables&#34;&gt;Assigning Values to Root Module Variables&lt;/a&gt;に記載されている通りいくつかある&lt;/li&gt;&#xA;&lt;li&gt;(恐らく業務では扱う変数の数は一定あると思うので)&lt;code&gt;.tfvars&lt;/code&gt;に変数の値を代入していく形が多くなりそう&#xA;&lt;ul&gt;&#xA;&lt;li&gt;毎回、&lt;code&gt;terraform plan --var-file=&amp;quot;ecs/dev/ecs.tfvars&amp;quot;&lt;/code&gt;みたいに指定するのはとても面倒なので、各リソースのディレクトリ構成を統一させて、Makeコマンドなりで各リソース名や環境名を引数としてもらい、Makefileの中でterraformコマンドを組み立てるのが良さそう(実際に自分が今担当しているプロジェクトではこの作りになっている)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;状態管理tfstate&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/terraform/#%e7%8a%b6%e6%85%8b%e7%ae%a1%e7%90%86tfstate&#34;&gt;状態管理(tfstate)&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これはapplyした後の状態を管理するためのファイル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;このファイルがあること、一度applyした後にもう一度applyを実行すると前回との差分だけが適用される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;複数人で運用する場合は、共有ストレージ(S3等)に管理すべきである&#xA;&lt;ul&gt;&#xA;&lt;li&gt;そうでないと、人によってインフラの実態とtfstateの中身とで乖離ができてしまい、正しく運用できなくなってしまう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;このtfstateをどのように管理するかを指定することをbackendという&lt;/li&gt;&#xA;&lt;li&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ディレクトリ構成&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/terraform/#%e3%83%87%e3%82%a3%e3%83%ac%e3%82%af%e3%83%88%e3%83%aa%e6%a7%8b%e6%88%90&#34;&gt;ディレクトリ構成&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;大きく分けて2つのディレクトリに分けるのが良い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1.リソースの共通情報定義用(ex: &lt;code&gt;modules/&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;li&gt;2.環境毎の情報定義用(ex: &lt;code&gt;env/&lt;/code&gt;)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2の&lt;code&gt;main.tf&lt;/code&gt;を以下のようにすることでmodules配下の共通情報を読み取ることができる&#xA;&#xA;  &#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-main.tf&#34; data-lang=&#34;main.tf&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ec2&amp;#34;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;source&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;../../modules/ec2&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;allow_ssh&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;terraformやterraformlockhclの管理方法&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/terraform/#terraform%e3%82%84terraformlockhcl%e3%81%ae%e7%ae%a1%e7%90%86%e6%96%b9%e6%b3%95&#34;&gt;.terraform/や.terraform.lock.hclの管理方法&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;複数人で運用する際に気をつけること&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/terraform/#%e8%a4%87%e6%95%b0%e4%ba%ba%e3%81%a7%e9%81%8b%e7%94%a8%e3%81%99%e3%82%8b%e9%9a%9b%e3%81%ab%e6%b0%97%e3%82%92%e3%81%a4%e3%81%91%e3%82%8b%e3%81%93%e3%81%a8&#34;&gt;複数人で運用する際に気をつけること&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;stateファイルはS3などの共有ストレージで管理する&lt;/li&gt;&#xA;&lt;li&gt;厳密に競合を避けたい場合はDynamo DBを利用する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>API Gateway &#43; Lambda</title>
      <link>http://localhost:1313/posts/apigateway-lambda/</link>
      <pubDate>Fri, 28 Feb 2025 23:13:29 +0900</pubDate>
      <guid>http://localhost:1313/posts/apigateway-lambda/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;概要&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/apigateway-lambda/#%e6%a6%82%e8%a6%81&#34;&gt;概要&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;API Gateway（Lambda統合）をterraformで実装したいので色々調査&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;やりたいこと&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/apigateway-lambda/#%e3%82%84%e3%82%8a%e3%81%9f%e3%81%84%e3%81%93%e3%81%a8&#34;&gt;やりたいこと&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;API GatewayでPOSTリクエストを受け付け、Lambda関数をトリガーする&lt;/li&gt;&#xA;&lt;li&gt;Lambda関数ではリクエストの一部フィールドをdumpしたい&lt;/li&gt;&#xA;&lt;li&gt;dump先はCloudWatchLogs&lt;/li&gt;&#xA;&lt;li&gt;Lambda関数はPythonで書きたい&lt;/li&gt;&#xA;&lt;li&gt;PythonソースコードはS3バケットにアップロードしたい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;必要なリソースまとめ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/apigateway-lambda/#%e5%bf%85%e8%a6%81%e3%81%aa%e3%83%aa%e3%82%bd%e3%83%bc%e3%82%b9%e3%81%be%e3%81%a8%e3%82%81&#34;&gt;必要なリソースまとめ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;API Gateway本体&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IAMロール（lambda:InvokeFunctionポリシーをアタッチ）も必要&lt;/li&gt;&#xA;&lt;li&gt;パスやスキーマ定義用にOpenAPI（YAML or JSON）も必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Lambda関数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IAMロール（AWSLambdaBasicExecutionRoleポリシーをアタッチ）も必要&#xA;&lt;ul&gt;&#xA;&lt;li&gt;LambdaからCloudWatchLogsへの書き込みに必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Lambda関数を置くS3バケット&lt;/li&gt;&#xA;&lt;li&gt;Pythonコード群&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;調査メモ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/apigateway-lambda/#%e8%aa%bf%e6%9f%bb%e3%83%a1%e3%83%a2&#34;&gt;調査メモ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;httpリクエストを使用してlambda関数を呼び出す方法&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/apigateway-lambda/#http%e3%83%aa%e3%82%af%e3%82%a8%e3%82%b9%e3%83%88%e3%82%92%e4%bd%bf%e7%94%a8%e3%81%97%e3%81%a6lambda%e9%96%a2%e6%95%b0%e3%82%92%e5%91%bc%e3%81%b3%e5%87%ba%e3%81%99%e6%96%b9%e6%b3%95&#34;&gt;HTTPリクエストを使用してLambda関数を呼び出す方法&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;API Gatewayの他にLambdaURLがある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/apig-http-invoke-decision.html&#34;&gt;HTTP リクエストを使用して Lambda 関数を呼び出す方法を選択する - AWS Lambda&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;シンプル・コスト効率を意識する場合は、LambdaURLで推奨&lt;/li&gt;&#xA;&lt;li&gt;大規模やOpenAPI Descriptionサポート、認証オプション、カスタムドメイン名..などの高度な機能が必要な場合にはAPI Gatewayが適している&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;api-gatewayのapiタイプ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/apigateway-lambda/#api-gateway%e3%81%aeapi%e3%82%bf%e3%82%a4%e3%83%97&#34;&gt;API GatewayのAPIタイプ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;HTTP API: 軽量で低レイテンシーの RESTful API。&#xA;REST API: カスタマイズ可能で機能豊富な RESTful API。&#xA;WebSocket API: 全二重通信のためにクライアントとの永続的な接続を維持するウェブ API。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HTTPとRESTどっちを選べば良いか問題&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html&#34;&gt;Choose between REST APIs and HTTP APIs - Amazon API Gateway&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;RESTは機能が豊富、HTTPがシンプル(その分低価格)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;api-gatewayのパスやスキーマはopenapiで管理が可能&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/apigateway-lambda/#api-gateway%e3%81%ae%e3%83%91%e3%82%b9%e3%82%84%e3%82%b9%e3%82%ad%e3%83%bc%e3%83%9e%e3%81%afopenapi%e3%81%a7%e7%ae%a1%e7%90%86%e3%81%8c%e5%8f%af%e8%83%bd&#34;&gt;API GatewayのパスやスキーマはOpenAPIで管理が可能&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OpenAPI定義ファイルをインポートすることで、API Gatewayのパスやスキーマの管理が可能&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/apigateway/latest/developerguide/api-gateway-import-api.html&#34;&gt;API Gateway で OpenAPI を使用して REST API を開発する - Amazon API Gateway&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;リクエストのバリデーションも設定可能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/apigateway/latest/developerguide/api-gateway-swagger-extensions-request-validator.html&#34;&gt;x-amazon-apigateway-request-validator プロパティ - Amazon API Gateway&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;lambda関数の更新方法&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/apigateway-lambda/#lambda%e9%96%a2%e6%95%b0%e3%81%ae%e6%9b%b4%e6%96%b0%e6%96%b9%e6%b3%95&#34;&gt;Lambda関数の更新方法&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;S3バケットにコードを配置する場合、source_code_hashで変更有無と更新が可能&lt;/li&gt;&#xA;&lt;li&gt;つまり、S3バケットに更新後のコード(zip)を配置した後、terraformを流せば、Lambda関数の更新が行われる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;アクセス許可について&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/apigateway-lambda/#%e3%82%a2%e3%82%af%e3%82%bb%e3%82%b9%e8%a8%b1%e5%8f%af%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6&#34;&gt;アクセス許可について&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://techblog.kayac.com/aws-lambda-iam&#34;&gt;https://techblog.kayac.com/aws-lambda-iam&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/apigateway-lambda/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/services-apigateway.html&#34;&gt;Amazon API Gateway エンドポイントを使用した Lambda 関数の呼び出し - AWS Lambda&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>AWS開発を成功させる技術</title>
      <link>http://localhost:1313/posts/006_aws%E9%96%8B%E7%99%BA%E3%82%92%E6%88%90%E5%8A%9F%E3%81%95%E3%81%9B%E3%82%8B%E6%8A%80%E8%A1%93/</link>
      <pubDate>Thu, 27 Feb 2025 21:38:10 +0900</pubDate>
      <guid>http://localhost:1313/posts/006_aws%E9%96%8B%E7%99%BA%E3%82%92%E6%88%90%E5%8A%9F%E3%81%95%E3%81%9B%E3%82%8B%E6%8A%80%E8%A1%93/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.sbcr.jp/product/4815617523/&#34;&gt;エバンジェリストの知識と経験を1冊にまとめた AWS開発を《成功》させる技術 | SBクリエイティブ&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;3章-クラウドならではのアーキテクチャ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/006_aws%E9%96%8B%E7%99%BA%E3%82%92%E6%88%90%E5%8A%9F%E3%81%95%E3%81%9B%E3%82%8B%E6%8A%80%E8%A1%93/#3%e7%ab%a0-%e3%82%af%e3%83%a9%e3%82%a6%e3%83%89%e3%81%aa%e3%82%89%e3%81%a7%e3%81%af%e3%81%ae%e3%82%a2%e3%83%bc%e3%82%ad%e3%83%86%e3%82%af%e3%83%81%e3%83%a3&#34;&gt;3章 クラウドならではのアーキテクチャ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;autoscalingを使うかどうか&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/006_aws%E9%96%8B%E7%99%BA%E3%82%92%E6%88%90%E5%8A%9F%E3%81%95%E3%81%9B%E3%82%8B%E6%8A%80%E8%A1%93/#autoscaling%e3%82%92%e4%bd%bf%e3%81%86%e3%81%8b%e3%81%a9%e3%81%86%e3%81%8b&#34;&gt;AutoScalingを使うかどうか&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リソースを厳密に行わなくて良いというメリットがある一方、以下のようなデメリットがある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;メトリクスによるスケーリング設定が難しい&lt;/li&gt;&#xA;&lt;li&gt;アプリケーション側が対応していないケースに向いていない（サーバー内にセッションを持っているなど）&lt;/li&gt;&#xA;&lt;li&gt;EDoS攻撃を受けた時に料金が無限にリソースが増えてしまい、多額の請求が発生する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;対策として以下を考慮しておくとよい&#xA;&lt;ul&gt;&#xA;&lt;li&gt;早い段階でAutoScaling設定を活用するかどうかを決めておく&lt;/li&gt;&#xA;&lt;li&gt;スケールアウトした時の上限値（台数）を設定しておく&lt;/li&gt;&#xA;&lt;li&gt;CDNを利用してサーバー負荷を低減する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;vpc同士の繋ぎ方&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/006_aws%E9%96%8B%E7%99%BA%E3%82%92%E6%88%90%E5%8A%9F%E3%81%95%E3%81%9B%E3%82%8B%E6%8A%80%E8%A1%93/#vpc%e5%90%8c%e5%a3%ab%e3%81%ae%e7%b9%8b%e3%81%8e%e6%96%b9&#34;&gt;VPC同士の繋ぎ方&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPCピアリングとTransitGatewayがある&lt;/li&gt;&#xA;&lt;li&gt;VPCピアリング&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPCをまたがって通信ができない&lt;/li&gt;&#xA;&lt;li&gt;なので接続する先のVPCが増えれば増えるほど、VPCピアリングが増えていく&lt;/li&gt;&#xA;&lt;li&gt;その時に登場するのがTransitGatewayとなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>CloudFront &#43; S3構成でCORSを設定する</title>
      <link>http://localhost:1313/posts/cors-cloudfront-s3/</link>
      <pubDate>Wed, 19 Feb 2025 22:26:30 +0900</pubDate>
      <guid>http://localhost:1313/posts/cors-cloudfront-s3/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;前提&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cors-cloudfront-s3/#%e5%89%8d%e6%8f%90&#34;&gt;前提&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;S3バケットに何かしらの資材を配置する&lt;/li&gt;&#xA;&lt;li&gt;S3バケットは外部公開しておらずCloudFront Distributionに設定(OAC)&lt;/li&gt;&#xA;&lt;li&gt;クライアント(ブラウザ) &amp;ndash; CloudFront(ディストリビューション) &amp;ndash; S3(バケット)という構成&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;corsおさらい&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cors-cloudfront-s3/#cors%e3%81%8a%e3%81%95%e3%82%89%e3%81%84&#34;&gt;CORSおさらい&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/nyuusen/TIL/blob/main/other/cors.md&#34;&gt;https://github.com/nyuusen/TIL/blob/main/other/cors.md&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;cloudfront--s3構成でcorsを設定する方法&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cors-cloudfront-s3/#cloudfront--s3%e6%a7%8b%e6%88%90%e3%81%a7cors%e3%82%92%e8%a8%ad%e5%ae%9a%e3%81%99%e3%82%8b%e6%96%b9%e6%b3%95&#34;&gt;CloudFront + S3構成でCORSを設定する方法&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;実現したいことは「CloudFront + S3で返す内容にCORSの設定を追加したい」&lt;br&gt;&#xA;もう少し具体にすると「クライアントからのリクエストに対するレスポンスのヘッダに&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;とその値として該当オリジンを追加したい」となる。&lt;/p&gt;&#xA;&lt;p&gt;そのためには以下のようにいくつかの手順が必要となる。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;step1-s3オリジンサーバーからaccess-control-allow-originヘッダを返す&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cors-cloudfront-s3/#step1-s3%e3%82%aa%e3%83%aa%e3%82%b8%e3%83%b3%e3%82%b5%e3%83%bc%e3%83%90%e3%83%bc%e3%81%8b%e3%82%89access-control-allow-origin%e3%83%98%e3%83%83%e3%83%80%e3%82%92%e8%bf%94%e3%81%99&#34;&gt;STEP1: S3(オリジンサーバー)からAccess-Control-Allow-Originヘッダを返す&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;バケットにCORS設定を作成する&lt;/li&gt;&#xA;&lt;li&gt;詳細: &lt;a href=&#34;https://docs.aws.amazon.com/AmazonS3/latest/userguide/ManageCorsUsing.html&#34;&gt;CORS 設定の要素 - Amazon Simple Storage Service&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;step2-cloudfrontディストリビューションからorigin等のヘッダをオリジンサーバに転送するように設定する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cors-cloudfront-s3/#step2-cloudfront%e3%83%87%e3%82%a3%e3%82%b9%e3%83%88%e3%83%aa%e3%83%93%e3%83%a5%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%8b%e3%82%89origin%e7%ad%89%e3%81%ae%e3%83%98%e3%83%83%e3%83%80%e3%82%92%e3%82%aa%e3%83%aa%e3%82%b8%e3%83%b3%e3%82%b5%e3%83%bc%e3%83%90%e3%81%ab%e8%bb%a2%e9%80%81%e3%81%99%e3%82%8b%e3%82%88%e3%81%86%e3%81%ab%e8%a8%ad%e5%ae%9a%e3%81%99%e3%82%8b&#34;&gt;STEP2: CloudFrontディストリビューションからOrigin等のヘッダをオリジンサーバに転送するように設定する&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CloudFrontディストリビューションに、以下のヘッダをS3に転送するように設定する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Access-Control-Request-Headers&lt;/li&gt;&#xA;&lt;li&gt;Access-Control-Request-Method&lt;/li&gt;&#xA;&lt;li&gt;Origin&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;上記の設定は、マネージドポリシー「CORS-S3Origin」もしくは「CORS-CustomOrigin」に含まれているので、どちらかを選択すると良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;step3-cloudfrontディストリビューションのキャッシュ動作をhttpリクエストのoptionsメソッドを許可する設定にする&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cors-cloudfront-s3/#step3-cloudfront%e3%83%87%e3%82%a3%e3%82%b9%e3%83%88%e3%83%aa%e3%83%93%e3%83%a5%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%ae%e3%82%ad%e3%83%a3%e3%83%83%e3%82%b7%e3%83%a5%e5%8b%95%e4%bd%9c%e3%82%92http%e3%83%aa%e3%82%af%e3%82%a8%e3%82%b9%e3%83%88%e3%81%aeoptions%e3%83%a1%e3%82%bd%e3%83%83%e3%83%89%e3%82%92%e8%a8%b1%e5%8f%af%e3%81%99%e3%82%8b%e8%a8%ad%e5%ae%9a%e3%81%ab%e3%81%99%e3%82%8b&#34;&gt;STEP3: CloudFrontディストリビューションのキャッシュ動作を、HTTPリクエストのOPTIONSメソッドを許可する設定にする&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プリフライトリクエストが使用される場合は、OPTIONSメソッドを明示的に許可する必要がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;デフォルトでは、GETとHEADリクエストのみ許可されている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;step4-cloudfrontディストリビューションでレスポンスヘッダーポリシーを設定する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cors-cloudfront-s3/#step4-cloudfront%e3%83%87%e3%82%a3%e3%82%b9%e3%83%88%e3%83%aa%e3%83%93%e3%83%a5%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%a7%e3%83%ac%e3%82%b9%e3%83%9d%e3%83%b3%e3%82%b9%e3%83%98%e3%83%83%e3%83%80%e3%83%bc%e3%83%9d%e3%83%aa%e3%82%b7%e3%83%bc%e3%82%92%e8%a8%ad%e5%ae%9a%e3%81%99%e3%82%8b&#34;&gt;STEP4: CloudFrontディストリビューションでレスポンスヘッダーポリシーを設定する&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CloudFrontディストリビューションのCORSを有効にするレスポンスヘッダーポリシーを追加する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cors-cloudfront-s3/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://repost.aws/ja/knowledge-center/no-access-control-allow-origin-error&#34;&gt;CloudFront からの「アクセス制御-オリジン許可ヘッダなし」エラーを解決する | AWS re:Post&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>GitHubActionsでジョブ実行の条件に指定できるステータスの動作検証</title>
      <link>http://localhost:1313/posts/condition-status/</link>
      <pubDate>Sat, 15 Feb 2025 22:03:42 +0900</pubDate>
      <guid>http://localhost:1313/posts/condition-status/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/condition-status/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;GitHubActionsでジョブ実行の条件に指定できるが幾つがあるが、RequiredReviewが設定したEnvironmentにおいて、承認・承認却下した時の該当ステップの出力結果を検証したい。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;検証リポジトリ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/condition-status/#%e6%a4%9c%e8%a8%bc%e3%83%aa%e3%83%9d%e3%82%b8%e3%83%88%e3%83%aa&#34;&gt;検証リポジトリ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/nyuusen/github-actions-sandbox&#34;&gt;https://github.com/nyuusen/github-actions-sandbox&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;検証対象&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/condition-status/#%e6%a4%9c%e8%a8%bc%e5%af%be%e8%b1%a1&#34;&gt;検証対象&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;success&lt;/li&gt;&#xA;&lt;li&gt;failure&lt;/li&gt;&#xA;&lt;li&gt;cancel&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;検証結果&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/condition-status/#%e6%a4%9c%e8%a8%bc%e7%b5%90%e6%9e%9c&#34;&gt;検証結果&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ワークフロー実行画面でcancel-workflowを押下する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/condition-status/#%e3%83%af%e3%83%bc%e3%82%af%e3%83%95%e3%83%ad%e3%83%bc%e5%ae%9f%e8%a1%8c%e7%94%bb%e9%9d%a2%e3%81%a7cancel-workflow%e3%82%92%e6%8a%bc%e4%b8%8b%e3%81%99%e3%82%8b&#34;&gt;ワークフロー実行画面で「Cancel Workflow」を押下する&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;success: false&lt;/li&gt;&#xA;&lt;li&gt;failure: false&lt;/li&gt;&#xA;&lt;li&gt;cancel: true&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;承認する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/condition-status/#%e6%89%bf%e8%aa%8d%e3%81%99%e3%82%8b&#34;&gt;承認する&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;success: true&lt;/li&gt;&#xA;&lt;li&gt;failure: false&lt;/li&gt;&#xA;&lt;li&gt;cancel: false&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;却下する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/condition-status/#%e5%8d%b4%e4%b8%8b%e3%81%99%e3%82%8b&#34;&gt;却下する&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;success: false&lt;/li&gt;&#xA;&lt;li&gt;failure: true&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;cancel: false&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;まとめ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/condition-status/#%e3%81%be%e3%81%a8%e3%82%81&#34;&gt;まとめ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;却下した時に、canceledがtrueにならない点は注意したほうが良さそう。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Linuxディストリビューション</title>
      <link>http://localhost:1313/posts/linux-distribution/</link>
      <pubDate>Sat, 15 Feb 2025 21:58:13 +0900</pubDate>
      <guid>http://localhost:1313/posts/linux-distribution/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/linux-distribution/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Linuxには多くのディストリビューションが存在する。&lt;br&gt;&#xA;特にDockerでベースイメージを選定する時などに一応知っておいた方が良さそうなので簡単にまとめる。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;linuxディストリビューションとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/linux-distribution/#linux%e3%83%87%e3%82%a3%e3%82%b9%e3%83%88%e3%83%aa%e3%83%93%e3%83%a5%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%a8%e3%81%af&#34;&gt;Linuxディストリビューションとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;そもそもdistributionという単語は「配布」という意味を持つ単語である。&lt;/p&gt;&#xA;&lt;p&gt;なので、LinuxディストリビューションというのはLinuxを配布するためのパッケージみたいなものだという理解で大丈夫そう。&lt;/p&gt;&#xA;&lt;p&gt;具体的には、Linuxカーネルとそのほかソフトウェア群を1つにまとめたものである。&lt;br&gt;&#xA;Linux=OSという風に認識されがちだけど、厳密にはLinuxはカーネルというOSのコア部分を指していて、実際にOSとして利用可能な状態にパッケージ化されたものがLinuxディストリビューションだと思われる。&lt;/p&gt;&#xA;&lt;p&gt;詳細は: &lt;a href=&#34;https://ja.wikipedia.org/wiki/Linux%E3%83%87%E3%82%A3%E3%82%B9%E3%83%88%E3%83%AA%E3%83%93%E3%83%A5%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3&#34;&gt;Linuxディストリビューション - Wikipedia&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;私がよく見かける主要なlinuxディストリビューション&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/linux-distribution/#%e7%a7%81%e3%81%8c%e3%82%88%e3%81%8f%e8%a6%8b%e3%81%8b%e3%81%91%e3%82%8b%e4%b8%bb%e8%a6%81%e3%81%aalinux%e3%83%87%e3%82%a3%e3%82%b9%e3%83%88%e3%83%aa%e3%83%93%e3%83%a5%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3&#34;&gt;(私がよく見かける)主要なLinuxディストリビューション&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Ubuntu：最も一般的に使用されているLinuxディストリビューションの一つで、ユーザーフレンドリーで安定している。デスクトップ、サーバー、クラウド環境に適している&lt;/li&gt;&#xA;&lt;li&gt;Debian：安定性とセキュリティに重点を置いたディストリビューションで、多くの他のディストリビューション（Ubuntuを含む）のベースとなっている&lt;/li&gt;&#xA;&lt;li&gt;CentOS：エンタープライズクラスのオペレーティングシステムで、Red Hat Enterprise Linux (RHEL)の無料版として広く使用されている（過去人気だった）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;※GitHub Copilotさんの回答をコピペした&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;比較してみる&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/linux-distribution/#%e6%af%94%e8%bc%83%e3%81%97%e3%81%a6%e3%81%bf%e3%82%8b&#34;&gt;比較してみる&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;基本的には、先祖としてDebian系とRedHat系とで分かれてるっぽい&lt;/p&gt;&#xA;&lt;p&gt;Debianは、100％フリーソフトであり続ける宣言をしており、ユーザーフレンドリーなのが特徴。&lt;br&gt;&#xA;昨今のWeb界隈の仕事だと、Debian系であるDebianやUbuntuを見ることが多いと思われる。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Lambdaレイヤー</title>
      <link>http://localhost:1313/posts/lambda-layer/</link>
      <pubDate>Mon, 20 Jan 2025 21:16:52 +0900</pubDate>
      <guid>http://localhost:1313/posts/lambda-layer/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;lambdaレイヤーとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/lambda-layer/#lambda%e3%83%ac%e3%82%a4%e3%83%a4%e3%83%bc%e3%81%a8%e3%81%af&#34;&gt;Lambdaレイヤーとは&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;複数のLambda関数でライブラリを共有できる仕組み&lt;/li&gt;&#xA;&lt;li&gt;ライブラリをLayerとしてアップロードしておくことで、個々の関数はLayerを使えば良くなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;メリット&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/lambda-layer/#%e3%83%a1%e3%83%aa%e3%83%83%e3%83%88&#34;&gt;メリット&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;デプロイメントパッケージのサイズを縮小できる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;依存関係の一部または全てをレイヤーに配置できるので、デプロイメントパッケージのサイズが小さくなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;関数のコアなロジックから依存関係を分離できる&lt;/li&gt;&#xA;&lt;li&gt;複数の関数間で依存関係を共有できる（保守性の向上？）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;goやrustでは推奨されていない&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/lambda-layer/#go%e3%82%84rust%e3%81%a7%e3%81%af%e6%8e%a8%e5%a5%a8%e3%81%95%e3%82%8c%e3%81%a6%e3%81%84%e3%81%aa%e3%81%84&#34;&gt;GoやRustでは推奨されていない&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Go または Rust で Lambda 関数を使用している場合は、レイヤーの使用はお勧めしません。&#xA;o および Rust 関数の場合、関数コードを実行可能ファイルとして提供します。これには、コンパイルされた関数コードとそのすべての依存関係が含まれます。&#xA;依存関係をレイヤーに配置すると、関数は初期化フェーズ中に追加のアセンブリを手動でロードする必要があり、コールド スタート時間が長くなる可能性があります。Go および Rust 関数のパフォーマンスを最適化するには、依存関係をデプロイメント パッケージと一緒に含めます。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/lambda-layer/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/chapter-layers.html&#34;&gt;レイヤーによる Lambda 依存関係の管理 - AWS Lambda&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>VPC Lambda</title>
      <link>http://localhost:1313/posts/vpc-lambda/</link>
      <pubDate>Mon, 20 Jan 2025 21:16:52 +0900</pubDate>
      <guid>http://localhost:1313/posts/vpc-lambda/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;vpc-lambdaとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/vpc-lambda/#vpc-lambda%e3%81%a8%e3%81%af&#34;&gt;VPC Lambdaとは&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPCにアタッチしたLambda関数のこと&#xA;&lt;ul&gt;&#xA;&lt;li&gt;各公式ドキュメントでは「接続」という言葉が使用されているが「アタッチ」と同義だと思っているのと、そっちの方がしっくりくる&lt;/li&gt;&#xA;&lt;li&gt;ちなみにLambda関数は、デフォルトではLambdaマネージドVPCで実行される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;VPC内のリソースへのプライベートアクセスが可能になる点が最大のメリット(だと思われる)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;構築に必要なもの&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/vpc-lambda/#%e6%a7%8b%e7%af%89%e3%81%ab%e5%bf%85%e8%a6%81%e3%81%aa%e3%82%82%e3%81%ae&#34;&gt;構築に必要なもの&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ネットワークインターフェイス&lt;/li&gt;&#xA;&lt;li&gt;実行ロールへのIAMポリシー(AWSLambdaVPCAccessExecutionRole)アタッチ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;上2つはどちらもLambdaがVPC内のリソースへのアクセスするために必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;構築手順&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/vpc-lambda/#%e6%a7%8b%e7%af%89%e6%89%8b%e9%a0%86&#34;&gt;構築手順&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;めちゃくちゃ端折ると..&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Lambda関数作成時に「VPCを有効化」を選択する&lt;/li&gt;&#xA;&lt;li&gt;Lambda関数の設定からVPCを選択し、サブネットを選択する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;注意ポイント&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/vpc-lambda/#%e6%b3%a8%e6%84%8f%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88&#34;&gt;注意ポイント&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Lambda関数からインターネット接続したい場合はNATゲートウェイを経由する必要がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これはサブネットがパブリックであっても同じ&lt;/li&gt;&#xA;&lt;li&gt;公式で記載されている情報を見ると、Lambda関数にはプライベートIPしか割り振られないためだと思われる&lt;/li&gt;&#xA;&lt;li&gt;NATゲートウェイは高いので、代替案を考察している記事&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://tech.briswell.com/entry/2023/10/03/202903&#34;&gt;VPC内のLambdaからインターネット接続する方法 - Briswell Tech Blog&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;結論、VPC Lambda-&amp;gt;VPC外 Lambdaでインターネットにアクセスする(VPCエンドポイント設定が必要)と行けるみたい。面白い。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/vpc-lambda/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/configuration-vpc.html&#34;&gt;Lambda 関数に Amazon VPC 内のリソースへのアクセスを許可する - AWS Lambda&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://dev.classmethod.jp/articles/internet-access-vpc-lambda/&#34;&gt;インターネットアクセス可能な VPC Lambda を作成してみた | DevelopersIO&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://repost.aws/ja/knowledge-center/internet-access-lambda-function&#34;&gt;VPC の Lambda 関数へのインターネットアクセスを許可する | AWS re:Post&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>AWS設計スキルアップガイド</title>
      <link>http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/</link>
      <pubDate>Wed, 15 Jan 2025 21:58:49 +0900</pubDate>
      <guid>http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://gihyo.jp/book/2023/978-4-297-13649-9&#34;&gt;AWS設計スキルアップガイド ――サービスの選定から、システム構成、運用・移行の設計まで：書籍案内｜技術評論社&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;2クラウドのインフラ設計&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#2%e3%82%af%e3%83%a9%e3%82%a6%e3%83%89%e3%81%ae%e3%82%a4%e3%83%b3%e3%83%95%e3%83%a9%e8%a8%ad%e8%a8%88&#34;&gt;2.クラウドのインフラ設計&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;クラウドで考えるセキュリティ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%af%e3%83%a9%e3%82%a6%e3%83%89%e3%81%a7%e8%80%83%e3%81%88%e3%82%8b%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3&#34;&gt;クラウドで考えるセキュリティ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;万が一の事故や障害が発生したときに「責任分界点」を定義しておくことで、責任の所在を明らかにできる&lt;/li&gt;&#xA;&lt;li&gt;AWSでの「責任共有モデル」では、それぞれの責任について以下のように定義されている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWS: サービスを提供するためのインフラストラクチャ&lt;/li&gt;&#xA;&lt;li&gt;利用者: 選択したAWSサービスごとの適切なセキュリティを実装し、システムを保護する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;AWS SecurityHubを使用することで、横断的にセキュリティの問題を検知することができる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;3システムの構成&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#3%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e3%81%ae%e6%a7%8b%e6%88%90&#34;&gt;3.システムの構成&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWSでシステムを構築する時にまず考えるべきは「アカウントをどの単位で発行するか」&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;awsアカウントの運用例&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#aws%e3%82%a2%e3%82%ab%e3%82%a6%e3%83%b3%e3%83%88%e3%81%ae%e9%81%8b%e7%94%a8%e4%be%8b&#34;&gt;AWSアカウントの運用例&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;単一のアカウントで運用するケース&#xA;&lt;ul&gt;&#xA;&lt;li&gt;注意ポイント&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPCをプロジェクトや環境ごとに分離する&lt;/li&gt;&#xA;&lt;li&gt;プロジェクトや環境がわかるようにタグを活用する&lt;/li&gt;&#xA;&lt;li&gt;VPCに関連のないサービスを使用する場合、IAMで権限を設定する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;管理する請求先が1つになるメリットはあるが、誤操作等によるミスや事故リスクが上がるので、&lt;strong&gt;できればアカウントは分けて運用するのが良い&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;複数のアカウントで運用するケース&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アカウントの統制を考慮する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWS ControlTowerで一元管理&lt;/li&gt;&#xA;&lt;li&gt;Organizationで多数のAWSアカウントを管理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ログインIDの統合を検討する(1つのユーザーアカウントで各AWSアカウントにログインできるようにする)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;各環境のIAMロールで行う方法&lt;/li&gt;&#xA;&lt;li&gt;AWS IAM Identity Center (SSO)を活用する方法&lt;/li&gt;&#xA;&lt;li&gt;サードパーティIDaaSを活用する方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;(追記)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWS ControlTowerを利用すると、マルチアカウント環境を一元的に整備してくれる&lt;/li&gt;&#xA;&lt;li&gt;参考: &lt;a href=&#34;https://aws.amazon.com/jp/blogs/startup/multi-accounts-and-control-tower/&#34;&gt;スタートアップにおけるマルチアカウントの考え方と AWS Control Tower のすゝめ | AWS Startup ブログ&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;iam&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#iam&#34;&gt;IAM&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;認証はIAMユーザー、認可はIAMポリシーで設定する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通常、ポリシーはグループもしくはロールに付与する&lt;/li&gt;&#xA;&lt;li&gt;なぜなら、ユーザーにポリシーをアタッチすると、運用工数がかかる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;iamポリシー設計&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#iam%e3%83%9d%e3%83%aa%e3%82%b7%e3%83%bc%e8%a8%ad%e8%a8%88&#34;&gt;IAMポリシー設計&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;デフォルトはすべて拒否なので、明示的に許可していく&#xA;&lt;ul&gt;&#xA;&lt;li&gt;どのリソース(Resource)に対して、どんな条件で(Conditions)、どんな動作(Action)を、許可/拒否する(Effect)かをJSONもしくはGUIで記述(選択)する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ポリシーはいくつか種類がある(使用頻度が高いものを抜粋)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アイデンティティベースのポリシー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アイデンティティ(ユーザー、グループ、ロール)にアタッチする&lt;/li&gt;&#xA;&lt;li&gt;この中にも再利用可能な管理ポリシーとインラインポリシーが存在(管理ポリシー推奨)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;リソースベースのポリシー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;S3などのリソースにアタッチする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;セッションポリシー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一時的にセッション単位でアクセスを許可するポリシー&lt;/li&gt;&#xA;&lt;li&gt;AssumeRoleなどのAPIを利用する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ポリシー評価について&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以下の順番で評価される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;img src=&#34;https://cdn-ak.f.st-hatena.com/images/fotolife/s/swx-yamasaki/20220227/20220227092451.png&#34; alt=&#34;image&#34;&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;画像引用元: &lt;a href=&#34;https://blog.serverworks.co.jp/iam/policy/evaluation-logic&#34;&gt;【入門編】AWSにおけるアクセスポリシーの評価ロジックを整理してみる&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;明示的な拒否があれば、その拒否設定が適用される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;拒否設定の後に、明示的な許可設定があったとしても、拒否設定が優先的に適用される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;明示的な許可があれば許可となるが、なかった場合は暗黙的に拒否される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;4ネットワーク設計&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#4%e3%83%8d%e3%83%83%e3%83%88%e3%83%af%e3%83%bc%e3%82%af%e8%a8%ad%e8%a8%88&#34;&gt;4.ネットワーク設計&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;オンプレミスとの比較&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%aa%e3%83%b3%e3%83%97%e3%83%ac%e3%83%9f%e3%82%b9%e3%81%a8%e3%81%ae%e6%af%94%e8%bc%83&#34;&gt;オンプレミスとの比較&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;オンプレミスと比較すると、AWSにおけるネットワーク設計はある程度ざっくりでOK&#xA;&lt;ul&gt;&#xA;&lt;li&gt;名前解決&#xA;&lt;ul&gt;&#xA;&lt;li&gt;オンプレミス: 内部DNSを立てるか各サーバーのhostsファイルを利用して名前解決を行う&lt;/li&gt;&#xA;&lt;li&gt;AWS: 自動でパブリックのDNS名が割り当てられ、マネージドのDNSで名前解決を行う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;時刻同期&#xA;&lt;ul&gt;&#xA;&lt;li&gt;オンプレミス: システム内の時刻が同期するように同一のNTPサーバーを割り当てる&lt;/li&gt;&#xA;&lt;li&gt;AWS: AmazonTimeSyncServiceで同期する(インターネット接続不要)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;マネージドNTP&lt;/li&gt;&#xA;&lt;li&gt;VPCで実行されているすべてのインスタンスの 169.254.169.123 IPアドレスで NTP を介して利用できる&lt;/li&gt;&#xA;&lt;li&gt;最新バージョンのAmazonLinux2とAmazonLinuxAMIはデフォルトでAmazonTimeSyncServiceと同期してくれている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;LambdaやECS on Fargate等のマネージドサービスではAWS側で時刻同期されているはずとのこと&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://repost.aws/questions/QUvug7LNsXTQacKVF-AFT9lw/aws%E3%83%9E%E3%83%8D%E3%83%BC%E3%82%B8%E3%83%89%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%81%AE%E6%99%82%E5%88%BB%E5%90%8C%E6%9C%9F%E3%81%AFaws%E5%81%B4%E3%81%A7%E8%A1%8C%E3%82%8F%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%81%AE%E3%81%8B&#34;&gt;AWSマネージドサービスの時刻同期はAWS側で行われているのか | AWS re:Post&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;vpcとサブネット&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#vpc%e3%81%a8%e3%82%b5%e3%83%96%e3%83%8d%e3%83%83%e3%83%88&#34;&gt;VPCとサブネット&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPCはリージョンごとのサービスなので、リージョンを跨ぐことはできない&lt;/li&gt;&#xA;&lt;li&gt;サブネットではいくつかのIPアドレスがAWSの予約枠として確保されている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ネットワークアドレス (最初のIPアドレス)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例: 10.0.0.0/24サブネットの場合、10.0.0.0がこのアドレスです。&lt;/li&gt;&#xA;&lt;li&gt;役割: ネットワーク自体を表すためのアドレスであり、ルーティングやネットワーク構成で使用されます。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;VPCルーター (2番目のIPアドレス)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例: 10.0.0.1がこのアドレスとなります（サブネットによって異なる場合もあり）。&lt;/li&gt;&#xA;&lt;li&gt;役割: サブネット内での通信を管理する仮想ルーターです。インスタンス間の通信やインターネットゲートウェイ、VPN接続の経路制御など、サブネット内のルーティングに使用されます。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;DNSサーバー (3番目のIPアドレス)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例: 10.0.0.2です。&lt;/li&gt;&#xA;&lt;li&gt;役割: AWSが提供するDNSリゾルバーのIPアドレスです。VPC内のインスタンスがDNSクエリを行う際に使用します。独自のカスタムDNS設定を行わない限り、このアドレスがデフォルトでDNSリゾルバーとして機能します。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;将来の用途のために予約されたアドレス (4番目のIPアドレス)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;役割: 現時点で特定の用途が明確には指定されていませんが、AWSが今後の機能拡張や内部用途のために予約しています。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ブロードキャストアドレス (最後のIPアドレス)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例: 10.0.0.255/24サブネットの場合、10.0.0.255がこのアドレスです。&lt;/li&gt;&#xA;&lt;li&gt;役割: ブロードキャスト通信のために予約されていますが、AWSのVPCではブロードキャスト通信はサポートされていないため、実際に使用することはありません。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;セキュリティグループネットワークaclaws-network-firewall&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3%e3%82%b0%e3%83%ab%e3%83%bc%e3%83%97%e3%83%8d%e3%83%83%e3%83%88%e3%83%af%e3%83%bc%e3%82%afaclaws-network-firewall&#34;&gt;セキュリティグループ・ネットワークACL・AWS Network Firewall&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWS Network Firewallは有料なのであまり使われない&lt;/li&gt;&#xA;&lt;li&gt;セキュリティグループ(SG)→ネットワークACLと、フィルタの範囲を狭めて、シンプルな構成・運用にする&lt;/li&gt;&#xA;&lt;li&gt;SGは、同一SGに所属しているノード同士の通信でも明示的に許可する必要がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ルートテーブル&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#%e3%83%ab%e3%83%bc%e3%83%88%e3%83%86%e3%83%bc%e3%83%96%e3%83%ab&#34;&gt;ルートテーブル&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ルートテーブルは複数のサブネットで共有可能&lt;/li&gt;&#xA;&lt;li&gt;サブネット作成時にルートテーブルも作成され、追加の設定なくVPC内の通信は可能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;デフォルトで、VPC内の全てのサブネットに向けたローカルルートが設定されているため&lt;/li&gt;&#xA;&lt;li&gt;ということは、同じVPC内のサブネットに存在するリソース間で通信を拒否したい場合は、セキュリティグループで設定する必要がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;vpcエンドポイント&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#vpc%e3%82%a8%e3%83%b3%e3%83%89%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88&#34;&gt;VPCエンドポイント&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;異なるVPCやリージョンに配置されたAWSサービスへインターネットを経由せずに接続するサービス&lt;/li&gt;&#xA;&lt;li&gt;ゲートウェイエンドポイント&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ルートテーブルでAWSサービスへのルートを指定&lt;/li&gt;&#xA;&lt;li&gt;費用かからない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;インターフェイスエンドポイント&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPCのプライベートIPアドレスを使用してアクセスする&lt;/li&gt;&#xA;&lt;li&gt;ENIとしてVPC内に配置され、それがサービスに接続するためのエンドポイントとして動作する&lt;/li&gt;&#xA;&lt;li&gt;処理するデータ量に応じて課金される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;例えばS3は、どちらでも接続可能だが、インターフェイスエンドポイントの方がセキュリティグループでトラフィックを制御できるため、セキュアである&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPC内のリソースがエンドポイントに対して、どのように通信できるかを詳細に制御ができるため、という意味(IPやプロトコル等の制限が可能)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;vpcフローログ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#vpc%e3%83%95%e3%83%ad%e3%83%bc%e3%83%ad%e3%82%b0&#34;&gt;VPCフローログ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPC内のネットワークインターフェースに流れる情報をキャプチャし、ログに記録する&lt;/li&gt;&#xA;&lt;li&gt;監査に必要なログを出力したり、通信がうまく通らない場合はトラブルシューティングとして出力したり&lt;/li&gt;&#xA;&lt;li&gt;フローログは以下の3つの項目を指定する&#xA;&lt;ol&gt;&#xA;&lt;li&gt;フローログを取得するリソース(VPC/サブネット/ENIをもつELBやNATGateway等)&lt;/li&gt;&#xA;&lt;li&gt;どんなトラフィックをキャプチャするか(許可、拒否、全て)&lt;/li&gt;&#xA;&lt;li&gt;フローログの出力先(CloudWatch Logs/S3)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;awsにセキュアに接続する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#aws%e3%81%ab%e3%82%bb%e3%82%ad%e3%83%a5%e3%82%a2%e3%81%ab%e6%8e%a5%e7%b6%9a%e3%81%99%e3%82%8b&#34;&gt;AWSにセキュアに接続する&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWS Client VPN&lt;/li&gt;&#xA;&lt;li&gt;サイト間VPN&lt;/li&gt;&#xA;&lt;li&gt;Direct Connect&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;5コンピューティング&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#5%e3%82%b3%e3%83%b3%e3%83%94%e3%83%a5%e3%83%bc%e3%83%86%e3%82%a3%e3%83%b3%e3%82%b0&#34;&gt;5.コンピューティング&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;lambda&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#lambda&#34;&gt;Lambda&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;イベント駆動型のアプリケーションで使いやすい&lt;/li&gt;&#xA;&lt;li&gt;コールドスタートにかかる時間を短くする方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPC内にアクセスしない(ENI作成に10〜30秒かかるため)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPC Lambdaと呼ばれてるやつ&lt;/li&gt;&#xA;&lt;li&gt;Lambdaをパブリックサブネットに配置するとENIが作成されアタッチされる&lt;/li&gt;&#xA;&lt;li&gt;そのENIに対し、パブリックIPを付与(アドレス関連付け)してやれば、Lambdaからアウトバウンドの通信ができるらしい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;メモリ増やす(メモリ量に比例してCPUも増加する)&lt;/li&gt;&#xA;&lt;li&gt;コード量を短くする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;関数の初期化や依存解決の速度の向上が見込まれるため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;lambdaのセキュリティ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#lambda%e3%81%ae%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3&#34;&gt;Lambdaのセキュリティ&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IAMを最小限にする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;特定の条件下で特定のリソースに対して実行できるアクションのみ定義する&lt;/li&gt;&#xA;&lt;li&gt;基本的には複数のLambda関数でIAMロールで共有しない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;lambdaの監視&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#lambda%e3%81%ae%e7%9b%a3%e8%a6%96&#34;&gt;Lambdaの監視&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Lambda関数をデプロイすると自動でCloudWatch Logsと連携する＋レイテンシやエラー率などのメトリクスも自動で発行する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;エラーを検知できるようにアラートを設定しておくと良い&lt;/li&gt;&#xA;&lt;li&gt;特にDuration(所要時間)やThrottles(同時実行上限を超えて制限した数)は、エラーが発生する前に適切検知できるようにしておく&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ec2&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#ec2&#34;&gt;EC2&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;インスタンスタイプの書式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/ec2/latest/instancetypes/instance-type-names.html&#34;&gt;Amazon EC2 インスタンスタイプの命名規則 - Amazon EC2&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;オプション&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンピューティング最適化: CPU大きめ&lt;/li&gt;&#xA;&lt;li&gt;メモリ最適化: メモリ大きめ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;ami&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#ami&#34;&gt;AMI&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;インスタンス起動するのに必要なOSやボリューム・アプリケーションを含むテンプレート&lt;/li&gt;&#xA;&lt;li&gt;OSのライセンス費用はEC2の利用料金に含まれている(オンプレと異なる点であり、メリットである)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;インスタンスの費用削減&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%a4%e3%83%b3%e3%82%b9%e3%82%bf%e3%83%b3%e3%82%b9%e3%81%ae%e8%b2%bb%e7%94%a8%e5%89%8a%e6%b8%9b&#34;&gt;インスタンスの費用削減&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リザーブドインスタンス&#xA;&lt;ul&gt;&#xA;&lt;li&gt;時間単位の費用を削減できる&lt;/li&gt;&#xA;&lt;li&gt;1年や3年の長期使用を約束する&lt;/li&gt;&#xA;&lt;li&gt;インスタンスクラスの変更しない場合、または負荷増加の際にオンデマンドインスタンスやスポットインスタンスで対応できる場合に検討する&lt;/li&gt;&#xA;&lt;li&gt;実際の使用有無に関わらず、購入した条件に応じた期間の費用が発生する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SavingsPlans&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これも1年や3年の長期使用を約束する&lt;/li&gt;&#xA;&lt;li&gt;リザーブドインスタンスとの違いは、LambdaやFargateでも使用可能である点、インスタンスファミリーやプラットフォームなどを指定しなくて良い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;逆にRDSやElasiCacheでは使用できないので注意&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;3種類がある&lt;/li&gt;&#xA;&lt;li&gt;インスタンスタイプや構成を柔軟に変更する予定がある場合は、SavingsPlansを検討する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;スポットインスタンス&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWSクラウド内の使用されていないEC2キャパシティを活用し、中断される可能性がある&lt;/li&gt;&#xA;&lt;li&gt;なので、本番環境で常時起動するサーバーではなく、ECS実行環境やCICDのビルド環境、バッチに適用する&lt;/li&gt;&#xA;&lt;li&gt;本番環境で適用する場合は、AutoScalingグループでオンデマンドインスタンスとスポットインスタンスの割合を指定する等して、中断が影響しないようにする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;中断の2分前にAWSから警告が来るので、アプリケーションの安全な停止や、ログの退避などは自動で対応できるように実装する&lt;/li&gt;&#xA;&lt;li&gt;インスタンスメタデータで中断対象か確認できる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;インスタンスメタデータを取得できるAPIがあるっぽい&lt;/li&gt;&#xA;&lt;li&gt;そこを定期的に叩くことで確認&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;t系インスタンスの注意点&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#t%e7%b3%bb%e3%82%a4%e3%83%b3%e3%82%b9%e3%82%bf%e3%83%b3%e3%82%b9%e3%81%ae%e6%b3%a8%e6%84%8f%e7%82%b9&#34;&gt;T系インスタンスの注意点&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;汎用のT系はM系よりも安価でありよく選定されるが、バーストパフォーマンスインスタンスであることは十分に理解が必要&lt;/li&gt;&#xA;&lt;li&gt;バーストパフォーマンスインスタンスとは&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ベースラインと呼ばれるCPU使用率がある&lt;/li&gt;&#xA;&lt;li&gt;そのベースラインに対して、下回る間はクレジットを獲得し、超える間は消費する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1CPUクレジット=1vCPU×100%使用率×1分&lt;/li&gt;&#xA;&lt;li&gt;つまり、1vCPUを50%使用率で2分使用すると、1クレジット消費するということ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;24時間の間で、獲得したクレジットよりも消費するクレジットが多い場合に、その分のvCPU費用が発生する&lt;/li&gt;&#xA;&lt;li&gt;T系インスタンスの各タイプで、1時間あたりに受け取るクレジットや蓄積可能なクレジット、ベースライン使用率は決められている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CPUクレジットの消費タイプには以下の2種類がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Standard: 残高が0になると、ベースライン使用率以下でのみ使用可能となる&lt;/li&gt;&#xA;&lt;li&gt;Unlimited: Standardのような制約はない代わりに、CPUクレジットが0になった後は、vCPU時間ごとに均一追加料金が発生する（他のインスタンスタイプの利用料金を超える可能性がある）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;重要なのは、CPU使用率を監視すること&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CloudWatchメトリクスで参照可能&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/AWSEC2/latest/UserGuide/burstable-performance-instances-monitoring-cpu-credits.html&#34;&gt;バーストインスタンスの CPU クレジットをモニタリングする - Amazon Elastic Compute Cloud&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;参考: &lt;a href=&#34;https://aws.amazon.com/jp/blogs/startup/burstable-performance-instances/&#34;&gt;バーストパフォーマンス(T系)インスタンスの特徴を理解して上手に利用しよう | AWS Startup ブログ&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;コンテナ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a&#34;&gt;コンテナ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;仮想化とコンテナの違い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ゲストOSの有無が大きな違い&lt;/li&gt;&#xA;&lt;li&gt;仮想化はホストOSを介して、ハードウェアを制御するため、オーバーヘッドが大きい&lt;/li&gt;&#xA;&lt;li&gt;コンテナは、アプリケーションの動作環境を隔離していて、カーネルはホストOSに依存するため、仮想化のように複数の異なるOSを稼働させることはできないが、逆に言えばOSがない分起動が早く、使用するリソースも少なくて済む&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;コンテナとec2の違い&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e3%81%a8ec2%e3%81%ae%e9%81%95%e3%81%84&#34;&gt;コンテナとEC2の違い&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;EC2上でコンテナを実行するのと、ECSやEKSなどのオーケストレーションツールを使用するのとでどのような違いがあるのかという問いと同義&lt;/li&gt;&#xA;&lt;li&gt;EC2上で動かした場合、デプロイする時は、EC2アプリケーションを更新→AMIを取得→AutoScaling対象のAMIを変更するという、とても面倒な手作業が発生する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;逆にロールバックの作業も面倒..&lt;/li&gt;&#xA;&lt;li&gt;加えて、OS更新等の手作業も発生する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;一方、ECSの場合は、コンテナやOSの障害や更新をAWS側が管理してくれる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CI/CDパイプラインを構築すれば、アプリケーション変更から適用まで迅速に行える&lt;/li&gt;&#xA;&lt;li&gt;コンテナがプロセス落ちを管理し、再度デプロイしてくれる(Serviceがやっていることかな？)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;コンテナを構成するサービスの特徴&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e3%82%92%e6%a7%8b%e6%88%90%e3%81%99%e3%82%8b%e3%82%b5%e3%83%bc%e3%83%93%e3%82%b9%e3%81%ae%e7%89%b9%e5%be%b4&#34;&gt;コンテナを構成するサービスの特徴&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;複数の環境を有するシステム&#xA;&lt;ul&gt;&#xA;&lt;li&gt;再現性が高い特徴を活かせる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;更新頻度が高いシステム&lt;/li&gt;&#xA;&lt;li&gt;アクセス増減の発生が高いシステム&lt;/li&gt;&#xA;&lt;li&gt;もはやこのご時世的にはあえてEC2を選択するケースはないのではと思う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;コンテナサービスを作るときに気をつけること&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e3%82%b5%e3%83%bc%e3%83%93%e3%82%b9%e3%82%92%e4%bd%9c%e3%82%8b%e3%81%a8%e3%81%8d%e3%81%ab%e6%b0%97%e3%82%92%e3%81%a4%e3%81%91%e3%82%8b%e3%81%93%e3%81%a8&#34;&gt;コンテナサービスを作るときに気をつけること&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;障害発生することを前提とする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プロセスが落ちても、すぐに起動できるように&lt;/li&gt;&#xA;&lt;li&gt;ECS Serviceを使えという話だと思う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;環境差異は変数化する&lt;/li&gt;&#xA;&lt;li&gt;ログ出力を1本化する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテナは実行環境であるホストOS上でプロセスとして動作し、他のプロセスから隔離されている&lt;/li&gt;&#xA;&lt;li&gt;コンテナ内部でアプリケーションログを吐いても、プロセス停止した際などにログが残らなくなってしまう&lt;/li&gt;&#xA;&lt;li&gt;ホストOSか別の領域に出力するように設定する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ちょっと調べた感じ、タスク定義でログドライバにawslogsを設定し、ロググループなども設定すれば、1つのロググループに出力されるようになるっぽい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;1コンテナ1プロセスとする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1つのコンテナに複数のプロセスを稼働させることも可能だが、制御が難しいため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;amazon-ecs&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#amazon-ecs&#34;&gt;Amazon ECS&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ECSの構成要素&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クラスター：実行環境&lt;/li&gt;&#xA;&lt;li&gt;タスク定義：指定のコンテナを動かす&lt;/li&gt;&#xA;&lt;li&gt;サービス：全体の構成やデプロイ方法を設定&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;タスク定義&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主な設定項目&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dockerイメージ&lt;/li&gt;&#xA;&lt;li&gt;コンテナのCPUとメモリ&lt;/li&gt;&#xA;&lt;li&gt;データボリューム&lt;/li&gt;&#xA;&lt;li&gt;IAMロール&lt;/li&gt;&#xA;&lt;li&gt;コンピューティング環境(EC2 or Fargate)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サービス&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主な設定項目&#xA;&lt;ul&gt;&#xA;&lt;li&gt;連携するELBを指定&lt;/li&gt;&#xA;&lt;li&gt;指定したタスク定義のタスク数&lt;/li&gt;&#xA;&lt;li&gt;デプロイ方法(Blue/Green,ローリングアップデート)&lt;/li&gt;&#xA;&lt;li&gt;実行環境(EC2,Fargate)で待ち受けるポートや、コンテナ側で待ち受けるポートも指定する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サービスはなくても動くけど、AutoScalingの実装等に必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;クラスター&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主な設定項目&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテナ実行環境のネットワークを指定&lt;/li&gt;&#xA;&lt;li&gt;起動するインスタンスタイプやAMI、その数を指定&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Fargateの場合は、ネットワーク作成とクラスター名のみを設定する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;タスク定義の更新&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%bf%e3%82%b9%e3%82%af%e5%ae%9a%e7%be%a9%e3%81%ae%e6%9b%b4%e6%96%b0&#34;&gt;タスク定義の更新&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテナイメージにつけるタグ名はlatestにするとタスク定義の修正が不要になる一方、コンテナイメージのバージョンがわからないのがで名rっと&lt;/li&gt;&#xA;&lt;li&gt;デプロイ方法「ローリングアップデート」と「Blue/Greenデプロイメント」がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ローリングアップデートの例&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DesiredCountを4に、minimumHealthyPercentを0.5に設定した場合、4 * 0.5の2インスタンスが更新されたタスク定義を元に作成される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Blue/Greenデプロイメントの例&#xA;&lt;ul&gt;&#xA;&lt;li&gt;タスク定義を更新すると、新たにGreen環境が作成あれ、疎通に問題がなければ、LBのレイヤーで切り替えを行う（だからLBが必須）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;データボリューム&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#%e3%83%87%e3%83%bc%e3%82%bf%e3%83%9c%e3%83%aa%e3%83%a5%e3%83%bc%e3%83%a0&#34;&gt;データボリューム&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ログや共通のデータはコンテナ外に領域を確保する&lt;/li&gt;&#xA;&lt;li&gt;ECSで選択可能なデータボリュームは以下になる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;EFS&lt;/li&gt;&#xA;&lt;li&gt;FSx for Windows File Sever&lt;/li&gt;&#xA;&lt;li&gt;Dockerボリューム&#xA;&lt;ul&gt;&#xA;&lt;li&gt;EC2のみ利用可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;バインドマウント&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ホスト上のファイルやディレクトリをコンテナからマウントする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Fargate タスクエフェメラルストレージ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;エフェメラルストレージ=一時的なストレージ&lt;/li&gt;&#xA;&lt;li&gt;プロビジョニング時にECSタスクが受け取るもの&lt;/li&gt;&#xA;&lt;li&gt;これらをマウントし、タスク定義内でvolumes、mountPointsおよびvolumesFromパラメータを使用しているコンテナ間で共有することが可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/AmazonECS/latest/developerguide/using_data_volumes.html&#34;&gt;Amazon ECS タスクのストレージオプション - Amazon Elastic Container Service&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;6データベース&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#6%e3%83%87%e3%83%bc%e3%82%bf%e3%83%99%e3%83%bc%e3%82%b9&#34;&gt;6.データベース&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;データベースの選択&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#%e3%83%87%e3%83%bc%e3%82%bf%e3%83%99%e3%83%bc%e3%82%b9%e3%81%ae%e9%81%b8%e6%8a%9e&#34;&gt;データベースの選択&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;どんな用途なのかと移行か新規なのか、複数の観点からの検討が必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;rds&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#rds&#34;&gt;RDS&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;EC2同様に仮想サーバー上で実行される&lt;/li&gt;&#xA;&lt;li&gt;EC2でもDBの構築は可能だが、RDSと異なり自動スケーリングや高可用性、OS・DBソフトウェアのパッチ適用などはユーザーが設計・実装・運用する必要がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;逆に、その辺りを自前で管理したい・RDSでサポートされていないパラメータをチューニングしたい・開発環境などで費用削減をしたいという場合はEC2でのDB構築が選択肢になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;リクエストのI/Oサイズやアクセスパターンにより、パフォーマンスが大きく変わる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;シーケンシャルなアクセスでは、最大I/Oサイズに達するまで、単一のI/O操作に含められる&lt;/li&gt;&#xA;&lt;li&gt;ランダムなアクセスでは、最大I/Oサイズに達しない小さいサイズでも、IOPSに個別カウントする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;つまりランダムアクセスの場合はIOPSの消費が多いので、それを考慮してインスタンスクラスなどを決めようという話&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;パフォーマンスは、DBで最も重要な非機能要件になるので、机上確認だけでなく、実際に検証したり、CloudWatchメトリクスで確認したりして、ストレージタイプを選ぶと良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;マルチaz構成&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#%e3%83%9e%e3%83%ab%e3%83%81az%e6%a7%8b%e6%88%90&#34;&gt;マルチAZ構成&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サポートされている機能は、リージョンやデータベースエンジンによって異なる&lt;/li&gt;&#xA;&lt;li&gt;マルチAZデプロイすると、Read/WriteできるプライマリDBインスタンスとフェイルオーバー先となるスタンバイレプリカ(読み取り書き込みはできない)が別AZへデプロイされる&lt;/li&gt;&#xA;&lt;li&gt;スタンバイレプリカは通常時は動作せず、プライマリに障害が発生した時にレプリカが昇格する&lt;/li&gt;&#xA;&lt;li&gt;フェイルオーバーは60〜120秒&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;マルチazdbクラスタ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#%e3%83%9e%e3%83%ab%e3%83%81azdb%e3%82%af%e3%83%a9%e3%82%b9%e3%82%bf&#34;&gt;マルチAZ DBクラスタ&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1つの読み取り/書き込みインスタンスと、2つ以上の読み取り専用スタンバイDBインスタンスで構成&lt;/li&gt;&#xA;&lt;li&gt;読み取り/書き込みインスタンスに障害が発生したら、読み取り専用スタンバイDBインスタンスが昇格&lt;/li&gt;&#xA;&lt;li&gt;書き込み専用DBインスタンス接続するクラスタエンドポイントと、読み取り専用に接続するリーダーエンドポイントがある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;エンドポイントは、クラスタ内の対象インスタンスに接続できない場合に自動的に接続先を変更する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;フェイルオーバーは35秒未満&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;rds-proxy&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#rds-proxy&#34;&gt;RDS Proxy&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RDSでは、アプリケーションからの接続を処理する際にメモリやCPUを消費する&lt;/li&gt;&#xA;&lt;li&gt;頻繁に短時間でDB接続を繰り返すアプリケーションでは、DBの処理負荷を下げるためRDS Proxyを導入すると良い&lt;/li&gt;&#xA;&lt;li&gt;RDSの最大接続数はパラメータグループのmax_connectionsで定義されており、手動変更は推奨されていない&lt;/li&gt;&#xA;&lt;li&gt;そのため、同時接続数が上限に達しそうな場合は、上位のインスタンスクラスorRDS Proxyを検討する&lt;/li&gt;&#xA;&lt;li&gt;RDS Proxyの特徴&#xA;&lt;ul&gt;&#xA;&lt;li&gt;フルマネージドサービス&lt;/li&gt;&#xA;&lt;li&gt;アプリケーションとRDSの間に設置&lt;/li&gt;&#xA;&lt;li&gt;VPC内の異なるAZにある2サブネットを選択して作成&lt;/li&gt;&#xA;&lt;li&gt;RDS Proxyを間に配置することによる遅延は5ミリ秒程度&lt;/li&gt;&#xA;&lt;li&gt;RDSのインスタンスレベルを上げずに済むので、コストや運用工数を抑えられる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;RDS Proxyを採用するメリット&#xA;&lt;ul&gt;&#xA;&lt;li&gt;フェイルオーバーにかかる時間を短縮できる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数秒レベルでフェイルオーバーが完了する&lt;/li&gt;&#xA;&lt;li&gt;RDS Proxyがない場合は、スタンバイの昇格とクラスタエンドポイントの更新後にアプリケーションが再接続するのに比べて、RDS Proxyがある場合はアプリケーションからの接続をプールし、RDS ProxyからRDSへの接続は処理中であったものを除いて保持・再利用するため&#xA;&lt;ul&gt;&#xA;&lt;li&gt;この箇所ちょっと引っかかったので調べてみた。&lt;/li&gt;&#xA;&lt;li&gt;RDS Proxyの使用有無で、RDS側のフェイルオーバーにかかる時間は変わらないと思う&lt;/li&gt;&#xA;&lt;li&gt;ただし、アプリケーションの視点で見た時に、RDS Proxyへのコネクションを再確立する必要がない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RDS ProxyーRDS間のコネクションの再確立のみで不要&lt;/li&gt;&#xA;&lt;li&gt;なので、アプリケーション側からすると、再接続するオーバーヘッドがかからないので、フェイルオーバーにかかる時間を短縮できると表現されていると思われる(RDS側のDNS更新も待つ必要もない)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;RDS Proxyを利用する際の注意点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IPアドレスの枯渇&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IPアドレスを消費するのは、RDS Proxy-RDSの接続&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RDS Proxy-RDSは、同じVPC内で通信するため、プライベートIPアドレスを使用する&lt;/li&gt;&#xA;&lt;li&gt;RDS Proxyは、接続先RDSのインスタンスクラスと台数に応じて自動的に容量を増減し、場合によっては多くのIPアドレスを利用する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;IPアドレスが枯渇するとうまくスケールができず、クエリ遅延やコネクション失敗が発生することがある&lt;/li&gt;&#xA;&lt;li&gt;インスタンスクラスごとに確保すべき最小IPアドレス数が定められている&lt;/li&gt;&#xA;&lt;li&gt;回避する方法としては、サブネットのIPアドレス範囲を広くすることが推奨される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;セッション固定（ピン止め）による影響&#xA;&lt;ul&gt;&#xA;&lt;li&gt;特定のトランザクションやセッションが接続プール内の特定のバックエンド(DB)接続に固定される状態を指す&lt;/li&gt;&#xA;&lt;li&gt;この状態になってしまうと、通常共有可能な接続が他のリクエストに再利用されなくなり、DBへの同時接続数が増え続け、最終的にはDB接続が行えなくなる可能性がある&lt;/li&gt;&#xA;&lt;li&gt;CloudWatchメトリクスの「DatabaseConnectionsCurrentlySessionPinned」を監視すると良い&lt;/li&gt;&#xA;&lt;li&gt;ピン留め発生が想定されるケース&#xA;&lt;blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;ステートフルなリクエスト&#xA;ユーザーセッションに依存する処理が行われる場合、同じバックエンド接続を使用し続ける必要があります。&#xA;例: 一時テーブルやユーザー固有の設定を使用したクエリ。&lt;/li&gt;&#xA;&lt;li&gt;特定のSQL機能の使用&#xA;以下のような機能を使用すると、接続が固定されることがあります：&#xA;セッション変数: SET SESSION を使用してカスタム設定を適用。&#xA;一時テーブル: セッション固有のデータを保持。&#xA;ユーザー定義関数（UDF）: セッションスコープで動作する関数。&#xA;ロック操作: セッションスコープのロック（例: GET_LOCK()）。&lt;/li&gt;&#xA;&lt;li&gt;トランザクション管理&#xA;トランザクション内で複数のクエリが実行される場合、トランザクションの一貫性を保つため、同じ接続を使い続ける必要があります。&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/blockquote&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;逆に、接続と破棄を繰り返すLambda関数等の使用であれば、この問題は発生しないも？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;目を通した導入事例とか&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://bftnagoya.hateblo.jp/entry/2022/03/28/094806&#34;&gt;【AWS】RDSのインスタンスタイプを上げたらRDS ProxyのENIがDBサブネットのIPを食い尽くした話 - BFT名古屋 TECH BLOG&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://devblog.thebase.in/entry/2022/05/26/180000&#34;&gt;Amazon RDS Proxy が BASE にもたらした期待以上の導入メリット - BASEプロダクトチームブログ&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;aurora&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#aurora&#34;&gt;Aurora&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Auroraを利用すると、簡単にレプリケーションやクラスタの設定が可能&lt;/li&gt;&#xA;&lt;li&gt;Auroraの構成&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1つ以上のインスタンスと1つのクラスタボリューム&lt;/li&gt;&#xA;&lt;li&gt;インスタンスには読み取り/書き込みを行うプライマリと読み取りのみをサポートするレプリカ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;RDSでAurora以外のエンジンを使用している場合との比較&#xA;&lt;ul&gt;&#xA;&lt;li&gt;インスタンスとストレージが分離している点が大きく異なる&lt;/li&gt;&#xA;&lt;li&gt;AuroraはRDSにまたがる分散ストレージにより、バックアップや復旧がRDSより高速&lt;/li&gt;&#xA;&lt;li&gt;RDSより割高なイメージがあるが、構成と運用次第でRDSよりも費用を抑えられる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Auroraのバージョン&#xA;&lt;ul&gt;&#xA;&lt;li&gt;MySQLやPostgreSQLのコミュニティバージョンに対応した独自のAuroraバージョン&lt;/li&gt;&#xA;&lt;li&gt;major.minor.patchの構成&lt;/li&gt;&#xA;&lt;li&gt;マイナーとパッチは自動アップグレードも可能&lt;/li&gt;&#xA;&lt;li&gt;アップグレードにはDBの停止を伴うことを想定する&lt;/li&gt;&#xA;&lt;li&gt;コミュニティサポート期限が切れると現行以降のメジャーバージョンに自動アップグレードされてしまうので注意&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;レプリケーションとフェイルオーバー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;レプリケーション&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プライマリインスタンスに書き込みが発生すると、通常100ミリ秒以下の遅延でレプリカ側でも書き込まれたデータを参照可能になる&lt;/li&gt;&#xA;&lt;li&gt;レプリカは最大15台をクラスタに組み込めるので、読み込み負荷の高いアプリケーションはAuroraを検討すると良い&lt;/li&gt;&#xA;&lt;li&gt;複数リージョンにまたがるグローバルデータベースでも、レプリケーションが1秒以内&lt;/li&gt;&#xA;&lt;li&gt;レプリケーション先にDBインスタンスは不要(クラスタボリュームがあるため)&lt;/li&gt;&#xA;&lt;li&gt;DR対策としてもAuroraは優位性がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;フェイルオーバー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プライマリに障害が発生すると、レプリカが昇格する&lt;/li&gt;&#xA;&lt;li&gt;フェイルオーバーの開始から終了までは通常30秒以内&lt;/li&gt;&#xA;&lt;li&gt;なおシングルインスタンス構成の場合は、障害が発生したAZにDBインスタンスを作成しようとする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;スケーリング&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最大128TiBまで容量を自動拡張する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;拡張時にパフォーマンス影響なし&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;手動でインスタンスクラスを変更すると、容量だけでなくCPUやメモリもスペックアップ可能だが、サービス停止が発生するので注意&lt;/li&gt;&#xA;&lt;li&gt;無停止でインスタンスクラスが自動スケールするAuroraServerlessもある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;auroraserverless&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#auroraserverless&#34;&gt;AuroraServerless&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ユーザーが事前に設定した範囲で自動スケールアップ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;dynamodb&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#dynamodb&#34;&gt;DynamoDB&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;フルマネージド型のNoSQLデータベース&lt;/li&gt;&#xA;&lt;li&gt;DynamoDBの特徴&#xA;&lt;ul&gt;&#xA;&lt;li&gt;高信頼性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リージョン内3AZに同期されるので、高い可用性と耐障害性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;高スループット&#xA;&lt;ul&gt;&#xA;&lt;li&gt;テーブルごとのRead/Writeそれぞれにスループットキャパシティを柔軟に割り当てられる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サーバーレス&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPCの設計が不要&lt;/li&gt;&#xA;&lt;li&gt;事前に設定するキャパシティに基づいて自動スケーリングできる&lt;/li&gt;&#xA;&lt;li&gt;容量無制限&lt;/li&gt;&#xA;&lt;li&gt;データのパーティショニングも自動で行われる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;整合性モデル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DynamoDBはデフォルトで「結果整合性のある読み込み」を行う&lt;/li&gt;&#xA;&lt;li&gt;DynamoDBでは少なくとも2AZで書き込み完了後、およそ1秒以内にAck(確認応答)を返す&lt;/li&gt;&#xA;&lt;li&gt;書き込み後1秒の間にアクセスした際のデータ不整合を許容できる場合はデフォルトのままで良い&lt;/li&gt;&#xA;&lt;li&gt;「強力な整合性のある読み込み」をするには、DynamoDBへのリクエスト時に「ConsistentReadパラメータ」を付与する(追加でコストがかかる点に注意)&lt;/li&gt;&#xA;&lt;li&gt;トランザクション読み込み/書き込みAPIもある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;モード&#xA;&lt;ul&gt;&#xA;&lt;li&gt;実際に使用した分にかかる「オンデマンドキャパシティ」と事前に予測可能な場合に有用な「プロビジョンドキャパシティ」がある&lt;/li&gt;&#xA;&lt;li&gt;単位や請求内容が異なるので注意&lt;/li&gt;&#xA;&lt;li&gt;インスタンスを用いるRDSよりは、多くの場合で費用を削減できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;dynamodbの設計&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#dynamodb%e3%81%ae%e8%a8%ad%e8%a8%88&#34;&gt;DynamoDBの設計&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以下のプライマリキーが必要&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パーティションキー(必須)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;テーブルのアイテムはパーティションという領域に配置される&lt;/li&gt;&#xA;&lt;li&gt;このパーティションキーの値を元に配置先のパーティションが決定される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ソートキー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パーティションキーが同一であるアイテムに対し、並び順を保証するために使用される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;この辺り理解甘いから公式ドキュメントを読み込みたい&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/amazondynamodb/latest/developerguide/best-practices.html&#34;&gt;DynamoDB を使用した設計とアーキテクチャの設計に関するベストプラクティス - Amazon DynamoDB&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;7ストレージ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#7%e3%82%b9%e3%83%88%e3%83%ac%e3%83%bc%e3%82%b8&#34;&gt;7.ストレージ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;大量のデータを保存したい場合：S3&lt;/li&gt;&#xA;&lt;li&gt;Lambdaや複数のLinux系EC2インスタンスからデータを利用したい場合：EFS&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ebs&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#ebs&#34;&gt;EBS&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;オンプレミスサーバに例えると、搭載する物理ディスクにあたる&lt;/li&gt;&#xA;&lt;li&gt;費用は、プロビジョニングされた容量に対して発生するので、インスタンスが停止していても課金されるので注意&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;s3&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#s3&#34;&gt;S3&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;オブジェクトストレージ&lt;/li&gt;&#xA;&lt;li&gt;インターネットからアクセスを受け付けるS3には適切なセキュリティ対策が必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;セキュリティ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3&#34;&gt;セキュリティ&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;データ保護&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2023年1月より、S3に追加される全てのオブジェクトにはSSE-S3での暗号化が自動適用されるようになった&#xA;&lt;ul&gt;&#xA;&lt;li&gt;監査や鍵の一元管理が不要であれば、追加費用かからず管理の手間もないSSE-S3を利用すると良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;アクセスポリシーの全体像&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リソースベースのポリシーとユーザーベースのポリシーを利用して、リソースへのアクセスを管理できる&lt;/li&gt;&#xA;&lt;li&gt;リソースベースのポリシー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;バケットポリシー&lt;/li&gt;&#xA;&lt;li&gt;バケットアクセスコントロールリスト(ACL)&lt;/li&gt;&#xA;&lt;li&gt;オブジェクトACL&#xA;&lt;ul&gt;&#xA;&lt;li&gt;バケットアクセスコントロールリスト(ACL)とオブジェクトACLは、使用する必要がないケースが多い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;バケットポリシーとユーザーポリシーで同じ対象に異なるアクセス制限(拒否と許可など)がされている場合は、より厳しい制限が適用されるので注意&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;8アプリーション統合&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#8%e3%82%a2%e3%83%97%e3%83%aa%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%e7%b5%b1%e5%90%88&#34;&gt;8.アプリーション統合&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;amazon-api-gateway&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#amazon-api-gateway&#34;&gt;Amazon API Gateway&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2種類のAPIが用意されており、RestfulAPIとチャットなどのリアルタイム双方向通信を行うステートフルなWebSocketAPIがある&lt;/li&gt;&#xA;&lt;li&gt;RestfulAPIには、WAF統合やクライアントごとのスロットリングなどの多機能なREST APIと、機能を絞り費用を抑えたHTTP APIが存在する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以下を参考に、要件に対して必要な機能を検討してどちらかを選ぶようにする&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/apigateway/latest/developerguide/http-api-vs-rest.html&#34;&gt;REST API と HTTP API のどちらかを選択する - Amazon API Gateway&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;マッピングテンプレートを使用すると、リクエストやレスポンスの整形が可能&lt;/li&gt;&#xA;&lt;li&gt;トークンバケットアルゴリズムを使用したスロットリング&lt;/li&gt;&#xA;&lt;li&gt;公式が出しているベストプラクティスもある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/apigateway/latest/developerguide/security-best-practices.html&#34;&gt;Amazon API Gateway のセキュリティのベストプラクティス - Amazon API Gateway&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;書かれているのは、最小権限やアクセスログの記録・アラート設定、CloudTrailの有効化など&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;eventbridge&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#eventbridge&#34;&gt;EventBridge&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;EventBridgeの特徴&#xA;&lt;ul&gt;&#xA;&lt;li&gt;EventBridgeは、様々なAWS内やSaaSアプリケーションのイベントを受信・処理し、ターゲットであるAWSサービスへ渡すイベント駆動型のマネージドサービス&lt;/li&gt;&#xA;&lt;li&gt;スケジュールをトリガーとしたルール実行も可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;イベントバスの種類&#xA;&lt;ul&gt;&#xA;&lt;li&gt;イベントバスと呼ばれるパイプラインでイベントを受信する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;アクセス制御&#xA;&lt;ul&gt;&#xA;&lt;li&gt;デフォルトのイベントバスは、操作しているAWSアカウントからのイベントを許可する&lt;/li&gt;&#xA;&lt;li&gt;各サービスのアクセス制御は、ターゲット側のポリシーで許可するorEventBridgeのルールのIAMロールでポリシーを設定する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;eventbridgeのルールと入力トランスフォーマー&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#eventbridge%e3%81%ae%e3%83%ab%e3%83%bc%e3%83%ab%e3%81%a8%e5%85%a5%e5%8a%9b%e3%83%88%e3%83%a9%e3%83%b3%e3%82%b9%e3%83%95%e3%82%a9%e3%83%bc%e3%83%9e%e3%83%bc&#34;&gt;EventBridgeのルールと入力トランスフォーマー&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ターゲットは5つまで指定できる&lt;/li&gt;&#xA;&lt;li&gt;並列実行が可能&lt;/li&gt;&#xA;&lt;li&gt;DatadogやNewRelic等のサードパーティツールにも統合可能&lt;/li&gt;&#xA;&lt;li&gt;入力トランスフォーマーでターゲットに渡す情報を編集できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;snsやsqsとの使い分け&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#sns%e3%82%84sqs%e3%81%a8%e3%81%ae%e4%bd%bf%e3%81%84%e5%88%86%e3%81%91&#34;&gt;SNSやSQSとの使い分け&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同じイベント駆動型アプリケーションであるSNSやSQSとの使い分けについて&lt;/li&gt;&#xA;&lt;li&gt;SNSやSQSを使用するケースは以下の通り&#xA;&lt;ul&gt;&#xA;&lt;li&gt;低レイテンシが求められる&lt;/li&gt;&#xA;&lt;li&gt;多数のエンドポイントが必要&lt;/li&gt;&#xA;&lt;li&gt;対人メッセージングに利用(SNSを使うべし)&lt;/li&gt;&#xA;&lt;li&gt;順序保証が必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SNS&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プッシュ方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プロデューサー == ブローカー == コンシューマーという構成でブローカーからコンシューマーへジョブがプッシュされる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SQS&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プル方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンシューマー側が能動的にブローカー(キュー)からメッセージを取得する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;P2P方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プロデューサーとコンシューマが1：1で連携する方式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;EventBridge&#xA;&lt;ul&gt;&#xA;&lt;li&gt;スケジュール実行・SaaSサービスとの連携・メッセージの加工はEventBridgeにしかない機能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;要件に合わせて使い分けることが大切&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;9可用性&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#9%e5%8f%af%e7%94%a8%e6%80%a7&#34;&gt;9.可用性&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;疎結合化の文脈で、システムのつなぎ目に拡張性・耐障害性に優れた機能を配置すると良い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えば、ロードバランサやDNS・メッセージキュー&lt;/li&gt;&#xA;&lt;li&gt;つなぎ目にはできるだけ非同期処理を行うコンポーネントを配置する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;EventBridge,SQS,Kinesisシリーズ群,Step Functions&lt;/li&gt;&#xA;&lt;li&gt;SQS(スタンダードキュー)は、1秒間にほぼ無限にAPIコールを受け付けられるため、可用性は問題にならない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;疎結合には、スケールアウトした時に他のコンポーネントへの影響が少ないことや障害発生時の切り分けもしやすいことがメリットになる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;sla&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#sla&#34;&gt;SLA&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWSはSLAを満たせなかった場合、サービスクレジットとして還元される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;キャッシュバックではなく、今後請求される支払いに対して利用できるもの&lt;/li&gt;&#xA;&lt;li&gt;契約者は、いくつかの情報を揃えてAWSに提出する必要がある(自動で適用されるものではない点に注意)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;10セキュリティ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#10%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3&#34;&gt;10.セキュリティ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クラウド事業者の選定&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ISMAPのクラウドサービスリスト: &lt;a href=&#34;https://www.ismap.go.jp/csm?id=cloud_service_list&#34;&gt;https://www.ismap.go.jp/csm?id=cloud_service_list&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Amazon Inspector&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CIS Benchmarksに沿って、EC2やECRのOSやミドルウェア設定を確認・可視化できる&lt;/li&gt;&#xA;&lt;li&gt;ベストプラクティスに準拠していない場合はレポート出力される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;リスク検出を支援するAWSサービス&#xA;&lt;ul&gt;&#xA;&lt;li&gt;無料で手軽に：TrustedAdvisor, IAM Access Analyzer&lt;/li&gt;&#xA;&lt;li&gt;ルールをカスタマイズもできる：AWS Config&lt;/li&gt;&#xA;&lt;li&gt;それほど料金かからない：SecurityHub&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;11ジョブ管理&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#11%e3%82%b8%e3%83%a7%e3%83%96%e7%ae%a1%e7%90%86&#34;&gt;11.ジョブ管理&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;バッチ処理を行うシステムをジョブ管理システムという&lt;/li&gt;&#xA;&lt;li&gt;AWSのジョブ実行に関連するサービスはいくつかある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;15分以内ならLambdaで実装するのが良い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ECS Scheduled TaskやBatchと比較して安価&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ECS Scheduled Taskは、EventBridgeでのトリガを元にECSを実行するというもの&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;batch&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#batch&#34;&gt;Batch&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;長時間、高負荷な処理はBatchでの実装を検討すると良い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;逆に短時間で終わるものや即時実行が必要なジョブには向いていない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Batchはコンテナ環境を使って処理を行うので、注意すべきポイントがいくつかある&lt;/li&gt;&#xA;&lt;li&gt;Batchの特徴&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンポーネント&#xA;&lt;ul&gt;&#xA;&lt;li&gt;BatchのジョブはECSやEKSのコンテナ上で実行される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;スポットインスタンスの活用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コストを安くできる反面、発生しうる中断に対してのケアが必要&#xA;&lt;ul&gt;&#xA;&lt;li&gt;冪等性を考慮したジョブ設計にし、リトライできるようにする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ジョブを短時間で終わるように設計する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定期的に結果をS3やEFSに出力するチェックポイント方式にする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ジョブの再試行回数を設定する&lt;/li&gt;&#xA;&lt;li&gt;実際の設計例では、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;優先度の高いジョブはオンデマンドに処理させて、そうではないジョブはスポットインスタンスにするとか&lt;/li&gt;&#xA;&lt;li&gt;スポットインスタンスで失敗したジョブをSNSに通知→Lambdaを経由して、オンデマンド用キュー→オンデマンドインスタンスでジョブを再実行とか方法がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;step-functions&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#step-functions&#34;&gt;Step Functions&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWSサービスやAPIを組み合わせ、ワークフローを視覚的に作成・実行できるサービス&lt;/li&gt;&#xA;&lt;li&gt;ワークフロータイプ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;StandardとExpressがある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;実行頻度の高い処理を短時間で処理させる場合はExpressを選択する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;料金&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Lambdaよりは割高&lt;/li&gt;&#xA;&lt;li&gt;状態遷移の回数で課金される&lt;/li&gt;&#xA;&lt;li&gt;EventBridgeーLambdaの構成であれば無料利用枠内に収まるなんてこともあるので、見積もりを慎重に行う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;StepFunctionsはデバッグがしやすい&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ステートごとに入出力やイベントが見やすかったり&lt;/li&gt;&#xA;&lt;li&gt;ステートごとにログが時系列でわかりやすく並んでいたりする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;12バックアップ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#12%e3%83%90%e3%83%83%e3%82%af%e3%82%a2%e3%83%83%e3%83%97&#34;&gt;12.バックアップ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;オンプレでもクラウドでもバックアップの重要性は変わらない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;awsのバックアップ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#aws%e3%81%ae%e3%83%90%e3%83%83%e3%82%af%e3%82%a2%e3%83%83%e3%83%97&#34;&gt;AWSのバックアップ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;EC2&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Amazon Data Lifecycle Managerで定期的にスナップショットを取得&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;RDS&#xA;&lt;ul&gt;&#xA;&lt;li&gt;自動バックアップの有効化、手動バックアップの実行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;S3&#xA;&lt;ul&gt;&#xA;&lt;li&gt;バージョニング有効、ライフサイクル管理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;aws-backup&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#aws-backup&#34;&gt;AWS Backup&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;フルマネージドなバックアップサービス&lt;/li&gt;&#xA;&lt;li&gt;最低料金や初期費用が発生しない&lt;/li&gt;&#xA;&lt;li&gt;バックアップの自動化や保存期間が過ぎたデータなどバックアップに関する一元管理が可能&lt;/li&gt;&#xA;&lt;li&gt;対象は、AWSリソースのみ&lt;/li&gt;&#xA;&lt;li&gt;概要&#xA;&lt;ul&gt;&#xA;&lt;li&gt;バックアッププランを作成し、ルールで指定したスケジュールでバックアップを行う&lt;/li&gt;&#xA;&lt;li&gt;バックアッププランで、AWSリソースを指定する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;想定外にかかる費用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;簡単に設定できてしまう反面、想定より費用がかかるケースがある&lt;/li&gt;&#xA;&lt;li&gt;バックアップを一定期間運用した後は、定期的に適切な範囲に収まっているかを確認した方が良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;13監視&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/003_aws%E8%A8%AD%E8%A8%88%E3%82%B9%E3%82%AD%E3%83%AB%E3%82%A2%E3%83%83%E3%83%97%E3%82%AC%E3%82%A4%E3%83%89/#13%e7%9b%a3%e8%a6%96&#34;&gt;13.監視&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RDS&#xA;&lt;ul&gt;&#xA;&lt;li&gt;スロークエリなどを出力したい場合は、パラメータグループのlog_outputをFILEにする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;VPC&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPC内のトラフィック情報をCloudWatch Logsに出力するには、VPCフローログが必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>TIL(Today I Learned)</title>
      <link>http://localhost:1313/posts/readme/</link>
      <pubDate>Sat, 11 Jan 2025 23:50:13 +0900</pubDate>
      <guid>http://localhost:1313/posts/readme/</guid>
      <description>&lt;p&gt;個人用の雑な学習メモです。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>ElasticCache 入門</title>
      <link>http://localhost:1313/posts/elasticache/</link>
      <pubDate>Thu, 09 Jan 2025 10:38:46 +0900</pubDate>
      <guid>http://localhost:1313/posts/elasticache/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;elasticache-とは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/elasticache/#elasticache-%e3%81%a8%e3%81%af&#34;&gt;ElastiCache とは&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一言で表すと「フルマネージドのインメモリキャッシングサービス」&lt;/li&gt;&#xA;&lt;li&gt;Memcached または Redis プロトコルに互換性がある&lt;/li&gt;&#xA;&lt;li&gt;特にリアルタイム性が必要な読み込み量が多いユースケースで活躍する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;端的にいうと高速なデータストア（キャッシュ）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;あくまでインメモリなので、ノードが落ちるとデータが消失するのでそこは注意が必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;構成要素&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/elasticache/#%e6%a7%8b%e6%88%90%e8%a6%81%e7%b4%a0&#34;&gt;構成要素&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ノード：最小構成要素でありインスタンス&lt;/li&gt;&#xA;&lt;li&gt;シャード：ノードのグループ(レプリケーション機能を使用する時に使うやつ)&lt;/li&gt;&#xA;&lt;li&gt;クラスタ：複数のシャードを束ねる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クラスタがあることで、例えばあるノードが落ちてしまっても、アプリケーション側からは1つのエンドポイントでアクセスできる(Redisの場合は)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;料金&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/elasticache/#%e6%96%99%e9%87%91&#34;&gt;料金&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;前提として、ElasticCache にはいくつかの種類がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;オンデマンド、リザーブド、サーバレス..&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;オンデマンドの場合は、キャッシュノードタイプ(cache.t4g.micro)に応じて、時間あたりの料金が発生する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;詳細: &lt;a href=&#34;https://aws.amazon.com/jp/elasticache/pricing/&#34;&gt;料金 - Amazon ElastiCache | AWS&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ユースケース&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/elasticache/#%e3%83%a6%e3%83%bc%e3%82%b9%e3%82%b1%e3%83%bc%e3%82%b9&#34;&gt;ユースケース&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;セッションストア&lt;/li&gt;&#xA;&lt;li&gt;レコメンデーション&lt;/li&gt;&#xA;&lt;li&gt;マルチプレイヤーゲームのランキングなどなど..&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;設計実装のポイントどころ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/elasticache/#%e8%a8%ad%e8%a8%88%e5%ae%9f%e8%a3%85%e3%81%ae%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88%e3%81%a9%e3%81%93%e3%82%8d&#34;&gt;設計・実装のポイントどころ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本的にはアプリケーションからキャッシュを確認し、なければデータストアへ確認、そしてキャッシュへの格納みたいな設計になることが多い&lt;/li&gt;&#xA;&lt;li&gt;結果整合性を前提とする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プライマリからレプリカにデータをシャードしている場合、読み込むを行うレプリカ側にはすぐに反映されない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これは、書き込みも読み込むも同じノードで行ってしまうとコネクション枯渇や CPU 使用率の逼迫を避けるためにそのように設計されてしまう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;そもそも結果整合性とは、データが分散されている環境でデータ更新が行われた場合、一定時間経過後に最終的な一貫性が担保されるという考え方(マイクロサービスの文脈でよく登場するイメージ)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;TTL に適切な値をセットする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;データ量が増えるとノードのメモリが溢れてしまう問題がある&lt;/li&gt;&#xA;&lt;li&gt;それを避けるために、一定時間経過後にデータが揮発するように設計すべき&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;memcached-と-redis&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/elasticache/#memcached-%e3%81%a8-redis&#34;&gt;Memcached と Redis&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;シンプルな Memcached と高機能な Redis&lt;/li&gt;&#xA;&lt;li&gt;結論としては安全性でも機能面でも全てにおいてRedisを使用するのが良いと思われる&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://dev.classmethod.jp/articles/which-choice-redis-memcached/&#34;&gt;ElastiCacheはMemcachedとRedisのどっちを選ぶ？ | DevelopersIO&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;memcached&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/elasticache/#memcached&#34;&gt;Memcached&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クラスタはノードの追加や削除が可能(水平スケーリング)&lt;/li&gt;&#xA;&lt;li&gt;アプリケーション側で定期的にノードの状態をチェックする必要がある&lt;/li&gt;&#xA;&lt;li&gt;マルチスレッド(スペック上げると性能もその分上がる)&lt;/li&gt;&#xA;&lt;li&gt;格納できるデータはstring型のみ&lt;/li&gt;&#xA;&lt;li&gt;扱えるコマンドが少なく、基本はデータ追加と削除のみを使用する想定&lt;/li&gt;&#xA;&lt;li&gt;バックアップのサポートがされていない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;redis&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/elasticache/#redis&#34;&gt;Redis&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クラスタにエンドポイントを持っている(Memcachedとの大きな違い)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;なのでアプリケーション側で定期的にポーリングする必要ある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;レプリケーションをサポートしている&lt;/li&gt;&#xA;&lt;li&gt;シングルスレッド(スペックを上げてもMemcachedほど性能は上がらない)&lt;/li&gt;&#xA;&lt;li&gt;格納できるデータ型は、stringに加え、List、Set、Sorted Set、Hash、Bit Array、HyperLogLogがある&lt;/li&gt;&#xA;&lt;li&gt;機能が豊富で、正規表現を用いた曖昧検索などもある&lt;/li&gt;&#xA;&lt;li&gt;クラスターごとにスナップショットを取ることが可能。スナップショットから復元も可能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;dynamodbとの比較&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/elasticache/#dynamodb%e3%81%a8%e3%81%ae%e6%af%94%e8%bc%83&#34;&gt;DynamoDBとの比較&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;以下の記事に比較しているセクションがあるので、少し考えてみる&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://dev.classmethod.jp/articles/elasticache-is-very-good-lets-review/&#34;&gt;ElastiCacheは良いサービス！！特徴や使い方をおさらいしましょ！ | DevelopersIO&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;ElastiCacheはノードやクラスターの管理をユーザ側でしなければなりませんが、DynamoDBはその辺りの管理をしなくて良いのが便利&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;→セキュリティやエンジンのアップデート(サービスの更新)をユーザー側で行う必要があるという意味かな？&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;DynamoDBは可用性担保のために書き込まれたデータを複数のAZに保存したり、接続にはSSLを用いるのでElastiCacheに比べるとやや書き込みが遅くなります。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;ElastiCacheは構成もユーザが選べるので通信元（クライアント）とノードを同一AZに寄せればより通信を早くするということも可能ですね&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;また例えばセッション情報のような頻繁に書き/読み込みされるようなデータの場合にはリクエストの度に課金されていくDynamoDBだとElastiCacheに比べて料金が割高になる可能性があります。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;→なるほど〜&lt;/p&gt;&#xA;&lt;p&gt;まとめると、&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最悪消失しても良いデータであり、書き込みと読み込みが頻繁に行われ、何より高速な通信したい→ElastiCache&lt;/li&gt;&#xA;&lt;li&gt;データを永続化したい→DynamoDB&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/elasticache/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://dev.classmethod.jp/articles/re-introduction-2022-amazon-elasticache/&#34;&gt;AWS 再入門 2022 AWS ElastiCache について | DevelopersIO&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://dev.classmethod.jp/articles/elasticache-is-very-good-lets-review/&#34;&gt;ElastiCache は良いサービス！！特徴や使い方をおさらいしましょ！ | DevelopersIO&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>AWSで始めるインフラ構築入門</title>
      <link>http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/</link>
      <pubDate>Wed, 08 Jan 2025 23:43:51 +0900</pubDate>
      <guid>http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;4vpc&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#4vpc&#34;&gt;4.VPC&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;基本&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#%e5%9f%ba%e6%9c%ac&#34;&gt;基本&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPC内には1つ以上のサブネットを構成する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サブネットはプライベート/パブリックがある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;AZごとにサブネットを構成すると、可用性が向上する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPC(AZ1(PublicSubnet&amp;amp;PrivateSubnet)AZ2(PublicSubnet&amp;amp;PrivateSubnet))みたいな構成&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;VPCは、AZを跨げるが、リージョンはまたげない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ある1リージョンの中で論理的な仮想ネットワーク&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ipv4-cidrの設計方法&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#ipv4-cidr%e3%81%ae%e8%a8%ad%e8%a8%88%e6%96%b9%e6%b3%95&#34;&gt;IPv4 CIDRの設計方法&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サブネットを一度作成すると、サブネットが利用するCIDRブロックは変更不可&lt;/li&gt;&#xA;&lt;li&gt;CIDR設計する際に、以下の2点をまずは考える必要がある&#xA;&lt;ol&gt;&#xA;&lt;li&gt;作成するサブネット数&lt;/li&gt;&#xA;&lt;li&gt;サブネット内に作成するリソース数&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これらはトレードオフの関係にあり、サブネットの数を増やすと、サブネット内のリソース数は減る&lt;/li&gt;&#xA;&lt;li&gt;例えば、10.0.0.0/16というCIDRブロックを持つVPCを仮定する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;/16なので、第3・4オクテッド(16ビット分)がホスト部になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;16ビットの中で、サブネットとリソースを割り当てることになる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サブネット8ビット(256)とした場合は、リソースも8ビット(256-5=251)となる&lt;/li&gt;&#xA;&lt;li&gt;※リソース数は理論的な最大値から5つを引いた数になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;書籍では/20で設定しており、/20だと4091個のリソースを作成できるので十分&#xA;&lt;ul&gt;&#xA;&lt;li&gt;実務でもこのくらいで割り当てるのが良いのかなと思った&lt;/li&gt;&#xA;&lt;li&gt;追記: いくつか記事を読むとVPCには/16、サブネットには/24を割り当てるケースが多そう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;まとめると、&lt;strong&gt;まずVPCのCIDRブロックを決定した後に、その範囲の中でサブネットのCIDRブロックを決定する&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;インターネットゲートウェイ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#%e3%82%a4%e3%83%b3%e3%82%bf%e3%83%bc%e3%83%8d%e3%83%83%e3%83%88%e3%82%b2%e3%83%bc%e3%83%88%e3%82%a6%e3%82%a7%e3%82%a4&#34;&gt;インターネットゲートウェイ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPCで作成されたネットワークとインターネット間を通信を可能にするためのもの&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;VPCに存在する(サブネットではない)&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;IGW作成した後にVPCにアタッチする必要がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;natゲートウェイ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#nat%e3%82%b2%e3%83%bc%e3%83%88%e3%82%a6%e3%82%a7%e3%82%a4&#34;&gt;NATゲートウェイ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;前提として、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IGWはVPCとインターネットが通信可能にするためのもの&lt;/li&gt;&#xA;&lt;li&gt;インターネットとの通信にはパブリックIPを持っている必要がある&lt;/li&gt;&#xA;&lt;li&gt;「パブリックIPを持つ＝インターネットに公開されている」であるため、プライベートサブネットで外部通信をどのように実現するかという話になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;上記を解決するものとして、NATゲートウェイがある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;NATゲートウェイは、パブリックサブネットに配置し、プライベートサブネット内のリソースを外部に通信できるようにする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;プライベートサブネットにあるリソース→NATゲートウェイ→インターネットゲートウェイという順で外部に通信を行う&#xA;&lt;ul&gt;&#xA;&lt;li&gt;この通信制御は、ルートテーブルで行う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;natの仕組み&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#nat%e3%81%ae%e4%bb%95%e7%b5%84%e3%81%bf&#34;&gt;NATの仕組み&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アパートを例にすると、アパートの中では部屋番号のみで特定できるが、アパートの外と郵便物をやり取りする場合は、住所＋部屋番号が必要になる&lt;/li&gt;&#xA;&lt;li&gt;これをNATの仕組みに割り当てると、NATゲートウェイにパブリックIPを割り当て(住所)、内部ではプライベートIP(部屋番号)で判別する仕組み&lt;/li&gt;&#xA;&lt;li&gt;この時の送信元IPは、パブリックIP＋プライベートIPになるのか？どのように特定するのか？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;外部から見た時の送信元IPは、パブリックIPになる&lt;/li&gt;&#xA;&lt;li&gt;内部的には、プライベートIP＋ポート番号とパブリックIP＋ポート番号のペアを一時的に保存し、特定している&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;natゲートウェイの構築&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#nat%e3%82%b2%e3%83%bc%e3%83%88%e3%82%a6%e3%82%a7%e3%82%a4%e3%81%ae%e6%a7%8b%e7%af%89&#34;&gt;NATゲートウェイの構築&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;NATゲートウェイを配置するサブネットを設定する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ここはインターネットと通信する場合はパブリックなサブネットを指定する必要がある&lt;/li&gt;&#xA;&lt;li&gt;むしろプライベートなサブネットを指定することってあるの？と思った(調べてもそのような使い方は見つからず&amp;hellip;)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ElasticIP割り当てIDを指定する(自動生成)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これが外部と通信するときに、外部から見えるIPアドレスになるのだと思われる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;補足-elasticip&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#%e8%a3%9c%e8%b6%b3-elasticip&#34;&gt;補足: ElasticIP&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWSでは、リソースにIPアドレスを直接持たせることができない(そうなんだ&amp;hellip;)&lt;/li&gt;&#xA;&lt;li&gt;パブリックIPを管理するElasticIPをリソースに割り当てることで、リソースに&lt;strong&gt;間接的に&lt;/strong&gt;パブリックIPを割り当てることができている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ルートテーブル&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#%e3%83%ab%e3%83%bc%e3%83%88%e3%83%86%e3%83%bc%e3%83%96%e3%83%ab&#34;&gt;ルートテーブル&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サブネット同士やサブネットと各ゲートウェイの間の通信経路を定義するためにルートテーブルが必要になる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これがないとサブネット内からサブネット外に通信を行うことができない&lt;/li&gt;&#xA;&lt;li&gt;具体的には「ネットワークトラフィックがどの宛先に対してどの経路を通るかを決定するための設定」を定義する&lt;/li&gt;&#xA;&lt;li&gt;もっと具体的には「トラフィックが、インターネットや他のVPC、プライベートネットワーク内のリソースにどのように到達するか」を定義する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ルートテーブルはサブネットごとに存在する&lt;/li&gt;&#xA;&lt;li&gt;一般的な設定例&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例1: パブリックサブネット用のルートテーブル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;送信先: 0.0.0.0/0 -&amp;gt; ターゲット: インターネットゲートウェイ (igw-xxxxxxx)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;意味: インターネット通信&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;例2: プライベートサブネット用のルートテーブル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;送信先: 0.0.0.0/0 -&amp;gt; ターゲット: NATゲートウェイ (nat-xxxxxxx)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;例3: 同一VPC内のリソース&#xA;&lt;ul&gt;&#xA;&lt;li&gt;送信先: 10.0.0.0/16 -&amp;gt; ターゲット: Local&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;送信先: どこに接続するかをIPアドレス(特定のIPでもCIDR形式でも可)&lt;/li&gt;&#xA;&lt;li&gt;ターゲット: どこを経由するか&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指定できる値は決まっている(ローカル/IGW/NAT GW/VPN GW/VPCピアリング/VPCエンドポイント)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;余談-00000とは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#%e4%bd%99%e8%ab%87-00000%e3%81%a8%e3%81%af&#34;&gt;余談: 0.0.0.0/0とは？&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;すべてのIPv4アドレスの範囲をCIDR表記&lt;/li&gt;&#xA;&lt;li&gt;インターネット上の全てのアドレスが対象となる&lt;/li&gt;&#xA;&lt;li&gt;ルートテーブルには大抵複数のルートが定義され、どれにも当てはまらかったルートは0.0.0.0/0として扱われるのだと思われる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;余談-ルートテーブルに複数ルートが定義されている時の優先順位は&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#%e4%bd%99%e8%ab%87-%e3%83%ab%e3%83%bc%e3%83%88%e3%83%86%e3%83%bc%e3%83%96%e3%83%ab%e3%81%ab%e8%a4%87%e6%95%b0%e3%83%ab%e3%83%bc%e3%83%88%e3%81%8c%e5%ae%9a%e7%be%a9%e3%81%95%e3%82%8c%e3%81%a6%e3%81%84%e3%82%8b%e6%99%82%e3%81%ae%e5%84%aa%e5%85%88%e9%a0%86%e4%bd%8d%e3%81%af&#34;&gt;余談: ルートテーブルに複数ルートが定義されている時の優先順位は？&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;宛先CIDR範囲の具体性に基づいて決まる&lt;/li&gt;&#xA;&lt;li&gt;より具体性の高い(範囲が狭い＝詳細な)ルートが適用される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;セキュリティグループ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3%e3%82%b0%e3%83%ab%e3%83%bc%e3%83%97&#34;&gt;セキュリティグループ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;外部からのアクセス制限を設けるために使用する&lt;/li&gt;&#xA;&lt;li&gt;外部からのアクセスを以下2つの要素で制御ができる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ポート番号&lt;/li&gt;&#xA;&lt;li&gt;IPアドレス&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;セキュリティグループの作成&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3%e3%82%b0%e3%83%ab%e3%83%bc%e3%83%97%e3%81%ae%e4%bd%9c%e6%88%90&#34;&gt;セキュリティグループの作成&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;セキュリティグループ作成時にVPCを指定する必要がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPCを跨いで同じセキュリティグループを使用することは不可&#xA;&lt;ul&gt;&#xA;&lt;li&gt;この理由を推察すると以下のような理由が考えられる(私の持論)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;セキュリティグループはVPC内リソースに対する通信を制御するため、VPC内の他のリソースを指定する。&lt;/li&gt;&#xA;&lt;li&gt;つまり、他のVPCのリソースを参照したり、プライベートIPの重複考慮したりすると、VPCを跨いで同じセキュリティグループを設定することは事実不可である(多分)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;余談-ネットワークaclとの違い&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#%e4%bd%99%e8%ab%87-%e3%83%8d%e3%83%83%e3%83%88%e3%83%af%e3%83%bc%e3%82%afacl%e3%81%a8%e3%81%ae%e9%81%95%e3%81%84&#34;&gt;余談: ネットワークACLとの違い&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;設定範囲が異なる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;セキュリティグループ: リソース&lt;/li&gt;&#xA;&lt;li&gt;ネットワークACL: サブネット&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;2段構えで設定することにより、設定漏れを防ぐことができる&lt;/li&gt;&#xA;&lt;li&gt;一方で、アクセス制御を2箇所で管理することになるので運用コストが増える&#xA;&lt;ul&gt;&#xA;&lt;li&gt;筆者は、セキュリティグループのみ設定しているらしい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;7ロードバランサー&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#7%e3%83%ad%e3%83%bc%e3%83%89%e3%83%90%e3%83%a9%e3%83%b3%e3%82%b5%e3%83%bc&#34;&gt;7.ロードバランサー&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;LBでTLS復号を行うことでWebサーバーの負荷を軽減できる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クライアントからLBはHTTPS通信・LBとWebサーバー間はHTTP通信&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;LBで80(HTTP)or443(HTTPS)ポートを公開するが、内側のWebサーバーは必ずしも同ポートに設定を合わせる必要はない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これをやるメリットとしてはWebサーバーのセキュリティ向上が挙げられる&lt;/li&gt;&#xA;&lt;li&gt;具体的にはLinuxOSでは0~1023番ポートで待ち受けするためには、強力な権限(root権限)を持ったユーザーでプログラムを動作させる必要がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;そのプログラムが悪意あるユーザーに乗っ取られてしまった場合、強力な権限が悪意あるユーザーに渡ってしまう&lt;/li&gt;&#xA;&lt;li&gt;どの番号が使用されるかは慣習により、Java言語をベースとしたものは8080、Ruby言語をベースとしたものは3000(Node.jsも3000が多い)が使われることが多い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;8rds&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#8rds&#34;&gt;8.RDS&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RDSは以下の4つで構成される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;データベースエンジン&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DB本体&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;パラメータグループ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DBエンジン固有の設定&lt;/li&gt;&#xA;&lt;li&gt;使用する言語やDBのチューニングの設定&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;データベースエンジンそのものの基本動作やパフォーマンスを制御するための設定&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;オプショングループ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RDS固有の設定&lt;/li&gt;&#xA;&lt;li&gt;AWSによるDB監視設定とか&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;データベースエンジンにプラグインや追加機能を付加するための設定&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サブネットグループ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DBサーバーを複数のAZに分散させて配置する時に使用する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;データベースサーバー構築&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#%e3%83%87%e3%83%bc%e3%82%bf%e3%83%99%e3%83%bc%e3%82%b9%e3%82%b5%e3%83%bc%e3%83%90%e3%83%bc%e6%a7%8b%e7%af%89&#34;&gt;データベースサーバー構築&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以下の流れで作成する&#xA;&lt;ol&gt;&#xA;&lt;li&gt;パラメータグループ作成&lt;/li&gt;&#xA;&lt;li&gt;オプショングループ作成&lt;/li&gt;&#xA;&lt;li&gt;サブネットグループ作成&lt;/li&gt;&#xA;&lt;li&gt;データベース作成&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;1パラメータグループ作成&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#1%e3%83%91%e3%83%a9%e3%83%a1%e3%83%bc%e3%82%bf%e3%82%b0%e3%83%ab%e3%83%bc%e3%83%97%e4%bd%9c%e6%88%90&#34;&gt;1.パラメータグループ作成&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パラメータグループファミリー: mysql8.0等&lt;/li&gt;&#xA;&lt;li&gt;タイプ: 通常のRDS用かクラスタリングRDS用か&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;2-オプショングループ作成&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#2-%e3%82%aa%e3%83%97%e3%82%b7%e3%83%a7%e3%83%b3%e3%82%b0%e3%83%ab%e3%83%bc%e3%83%97%e4%bd%9c%e6%88%90&#34;&gt;2. オプショングループ作成&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;エンジン: mysql&lt;/li&gt;&#xA;&lt;li&gt;メジャーエンジンバージョン: 8.0&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;3-サブネットグループ作成&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#3-%e3%82%b5%e3%83%96%e3%83%8d%e3%83%83%e3%83%88%e3%82%b0%e3%83%ab%e3%83%bc%e3%83%97%e4%bd%9c%e6%88%90&#34;&gt;3. サブネットグループ作成&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RDSを作成する時はサブネットグループを指定し、どのサブネットに作成されるかはAWSに任せることになる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;理由: RDSはマネージドサービスとして、耐障害性や自動フェイルオーバーなどを考慮して配置を決定するため(AWS側で最適な配置が自動的に行われる仕組みになっている)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;4-データベース作成&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#4-%e3%83%87%e3%83%bc%e3%82%bf%e3%83%99%e3%83%bc%e3%82%b9%e4%bd%9c%e6%88%90&#34;&gt;4. データベース作成&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;エンジンのタイプ&lt;/li&gt;&#xA;&lt;li&gt;マスターユーザー名やパスワード&lt;/li&gt;&#xA;&lt;li&gt;DBインスタンスクラス&lt;/li&gt;&#xA;&lt;li&gt;上で設定した各グループ識別子を指定する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;9s3&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#9s3&#34;&gt;9.S3&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;S3は、OS・スケーリング・監視の部分を運用側が意識せずにデータ管理のみに集中できる&lt;/li&gt;&#xA;&lt;li&gt;S3にアクセスするリソースに対しては、それを許可するIAMロールを割り当てる必要がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;10route53&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#10route53&#34;&gt;10.Route53&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ホストゾーンを作成する時に「プライベート」を選択することができる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プライベートDNSで登録するドメインは、パブリックも含めてユニークにする必要がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;理由: 名前解決する時に意図しないリソースへのアクセスが行われてしまう可能性があるため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;RDSには固定されたIPアドレスが参照できなくなっている代わりに、エンドポイントが用意されている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;そのエンドポイントを値に持つCNAMEレコードを登録することで、ドメインの名前解決ができるようになる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;11メールサーバー&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#11%e3%83%a1%e3%83%bc%e3%83%ab%e3%82%b5%e3%83%bc%e3%83%90%e3%83%bc&#34;&gt;11.メールサーバー&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;メールが届く仕組み&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#%e3%83%a1%e3%83%bc%e3%83%ab%e3%81%8c%e5%b1%8a%e3%81%8f%e4%bb%95%e7%b5%84%e3%81%bf&#34;&gt;メールが届く仕組み&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;送信者が自分が所属する組織のメールサーバーに送信を依頼する&lt;/li&gt;&#xA;&lt;li&gt;受信者側のメールサーバーにメールが届く&lt;/li&gt;&#xA;&lt;li&gt;受信者が自身のメールサーバーのメールを閲覧する&lt;/li&gt;&#xA;&lt;li&gt;補足&#xA;&lt;ul&gt;&#xA;&lt;li&gt;送信にはSMTPプロトコルが使用され、受信にはPOP3・IMAP4が使用される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;補足-httpでメール送れるようにすれば良いのではなぜsmtp&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#%e8%a3%9c%e8%b6%b3-http%e3%81%a7%e3%83%a1%e3%83%bc%e3%83%ab%e9%80%81%e3%82%8c%e3%82%8b%e3%82%88%e3%81%86%e3%81%ab%e3%81%99%e3%82%8c%e3%81%b0%e8%89%af%e3%81%84%e3%81%ae%e3%81%a7%e3%81%af%e3%81%aa%e3%81%9csmtp&#34;&gt;補足: HTTPでメール送れるようにすれば良いのでは？なぜSMTP？&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SMTPにはメール通信に必要不可欠な以下の機能(特長)を有している&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リトライ機能(HTTPのリトライはクライアント依存)&lt;/li&gt;&#xA;&lt;li&gt;多段階転送 クライアント→メールサーバー→受信サーバー(HTTPはクライアント→サーバー)&lt;/li&gt;&#xA;&lt;li&gt;メールの特殊なデータ構造 ファイル添付や複雑なヘッダー情報&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;設計思想的に、HTTPは即時性みたいなものが重視され、SMTPは信頼性が重視されている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;sesamazon-simple-email-service&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#sesamazon-simple-email-service&#34;&gt;SES(Amazon Simple Email Service)&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;メールの送受信を行う機能を提供するマネージドサービス&lt;/li&gt;&#xA;&lt;li&gt;通常のメールサーバーとは異なり、人ではなくアプリからメールを送受信を行うのに都合が良い機能が用意されている&lt;/li&gt;&#xA;&lt;li&gt;送信&#xA;&lt;ul&gt;&#xA;&lt;li&gt;システム(ex:no-reply@example.com)からメールを送る場合、そのユーザーをIAMユーザーとして登録し、IAMユーザーを使って、メール送信ができる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;受信&#xA;&lt;ul&gt;&#xA;&lt;li&gt;POP3やIMAP4は使用しない(通常のメール受信と大きく異なる)&lt;/li&gt;&#xA;&lt;li&gt;代わりにメールを受信した時にアクションと呼ばれる処理が実行される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;S3に保存する、SNSトピックに公開する、Lambda関数を実行する等&lt;/li&gt;&#xA;&lt;li&gt;SNSアクションに登録しておくと、管理者のメールや携帯にプッシュ通知を送ることができる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;つまり、ユーザーからのメールを管理者が手動で対応する運用が行えないということになる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;代わりに用意されているアクションの機能を考慮すると、CRMシステムとの連携を想定している&lt;/li&gt;&#xA;&lt;li&gt;その辺りを考慮して、SESを使うのか他のメールサーバーを使うのかを考える必要がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;12キャッシュサーバー&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#12%e3%82%ad%e3%83%a3%e3%83%83%e3%82%b7%e3%83%a5%e3%82%b5%e3%83%bc%e3%83%90%e3%83%bc&#34;&gt;12.キャッシュサーバー&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RedisとMemcachedというOSS(ミドルウェア)がある&lt;/li&gt;&#xA;&lt;li&gt;これをEC2で作成したLinuxサーバーにインストールしてサーバーとして動作させることが可能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ただこれは運用やコスト面で課題がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Redis/Memcachedと互換性のあるElastiCacheというマネージドサービスがある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;elasticache&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/002_aws%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%89%E5%85%A5%E9%96%80/#elasticache&#34;&gt;ElastiCache&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本的にはあるキーに対してキャッシュされたデータを返す、キーバリュー型の仕組みを提供する&lt;/li&gt;&#xA;&lt;li&gt;ElastiCacheは以下の階層構造を持つ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ノード: 最小単位。実際のデータが保存される。&lt;/li&gt;&#xA;&lt;li&gt;シャード: ノードを束ねるグループ。1つのプライマリノードと複数のレプリカノードで構成される。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プライマリノードに障害が発生したら、レプリカノードで処理継続できるので、耐障害性が上がる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;クラスター: シャードを束ねるグループ。複数のシャードで構成される。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;マルチAZ構成にできる。フェイルオーバーで耐障害性アップ。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;redis-cliで、クラスターのエンドポイント向けに動作確認を行うことができる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>RDSのAuroraをアップデートする</title>
      <link>http://localhost:1313/posts/update-aurora/</link>
      <pubDate>Thu, 26 Dec 2024 16:14:54 +0900</pubDate>
      <guid>http://localhost:1313/posts/update-aurora/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/update-aurora/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;業務で必要になったので、調べたことを雑にメモ。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;アップデート方法&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/update-aurora/#%e3%82%a2%e3%83%83%e3%83%97%e3%83%87%e3%83%bc%e3%83%88%e6%96%b9%e6%b3%95&#34;&gt;アップデート方法&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;1インプレースin-place&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/update-aurora/#1%e3%82%a4%e3%83%b3%e3%83%97%e3%83%ac%e3%83%bc%e3%82%b9in-place&#34;&gt;1.インプレース(In-Place)&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;現行クラスターをそのままアップグレードする&lt;/li&gt;&#xA;&lt;li&gt;マネコンから1クリックで実行可能であり、エンドポイントも変わらないので作業工数が最もかからない&lt;/li&gt;&#xA;&lt;li&gt;他の方法に比べダウンタイムが長い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;データベース再起動が発生するため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;切り戻しは、アップグレード前のスナップショットを用いて行う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;2ダンプリストア&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/update-aurora/#2%e3%83%80%e3%83%b3%e3%83%97%e3%83%aa%e3%82%b9%e3%83%88%e3%82%a2&#34;&gt;2.ダンプ&amp;amp;リストア&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;移行先のDBクラスターを作成し、mysqldump等を利用してクラスター間でデータ移行させる&lt;/li&gt;&#xA;&lt;li&gt;データ量に応じて、ダンプにかかるエクスポート・インポート時間が発生する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;3レプリケーション&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/update-aurora/#3%e3%83%ac%e3%83%97%e3%83%aa%e3%82%b1%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3&#34;&gt;3.レプリケーション&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;移行先のDBクラスターを作成し、binlogレプリケーションでクラスター間でデータ同期させた後、スイッチオーバーする&lt;/li&gt;&#xA;&lt;li&gt;データ量に関係なくダウンタイムが発生しない&lt;/li&gt;&#xA;&lt;li&gt;手順が複雑&#xA;&lt;ul&gt;&#xA;&lt;li&gt;現在では、RDSでBlue/Greenデプロイに対応しているので前よりは簡単にできるらしい&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/jp/about-aws/whats-new/2022/11/amazon-rds-blue-green-deployments-safer-simpler-faster-updates/&#34;&gt;より安全、簡単、迅速な更新のための Amazon RDS ブルー/グリーンデプロイを発表&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://dev.classmethod.jp/articles/rds-bg-deploy/&#34;&gt;【衝撃】AWSのRDSがデータを失わないBlue/Greenデプロイに対応しました #reinvent | DevelopersIO&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;4ブルーグリーンデプロイ機能&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/update-aurora/#4%e3%83%96%e3%83%ab%e3%83%bc%e3%82%b0%e3%83%aa%e3%83%bc%e3%83%b3%e3%83%87%e3%83%97%e3%83%ad%e3%82%a4%e6%a9%9f%e8%83%bd&#34;&gt;4.ブルー/グリーンデプロイ機能&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;エンドポイント変わらない&lt;/li&gt;&#xA;&lt;li&gt;グリーンへの切り替え後に、ブルーへの逆方向レプリケーションが可能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;切り戻しが必要な時に迅速に対応が可能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;補足-binlogとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/update-aurora/#%e8%a3%9c%e8%b6%b3-binlog%e3%81%a8%e3%81%af&#34;&gt;補足: binlogとは&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;バイナリログのこと&lt;/li&gt;&#xA;&lt;li&gt;バイナリログには、テーブルやデータ変更等のイベントが記述される&lt;/li&gt;&#xA;&lt;li&gt;バイナリログをレプリカに転送することで、レプリカ側でトランザクションを再現して、同様のデータ変更が可能&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/ja/binary-log.html&#34;&gt;MySQL :: MySQL 8.0 リファレンスマニュアル :: 5.4.4 バイナリログ&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;注意点等&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/update-aurora/#%e6%b3%a8%e6%84%8f%e7%82%b9%e7%ad%89&#34;&gt;注意点等&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;更新にはDBの再起動が必要であるため、採用するアップデート方式によるが、通常20-30秒のダウンタイムが発生する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;再起動に必要な時間は、クラッシュ回復プロセス、再起動時のデータベースアクティビティ、および特定の DB エンジンの動作によって異なる&lt;/li&gt;&#xA;&lt;li&gt;データベースアクティビティをできるだけ減らすこと(未完了のトランザクションのロールバックアクティビティを減らすことに繋がる)で短くできる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コミットされていないトランザクションがあると、それらをロールバックする処理が発生するからということだと思われる&lt;/li&gt;&#xA;&lt;li&gt;つまり、システムをメンテナンスモードにしておく等しておき、トランザクションが滞留していない状態を作るのが良さげ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/update-aurora/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/AmazonRDS/latest/AuroraUserGuide/Aurora.Updates.html&#34;&gt;Amazon Aurora の更新 - Amazon Aurora&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://dev.classmethod.jp/articles/upgrade-aurora-mysql-5-6-to-8-0-simple-stupid/&#34;&gt;Amazon Aurora MySQL 5.6を頑張らずに8.0へメジャーアップグレードしてみた | DevelopersIO&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;他社事例&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/update-aurora/#%e4%bb%96%e7%a4%be%e4%ba%8b%e4%be%8b&#34;&gt;他社事例&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ユーザベース様&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/update-aurora/#%e3%83%a6%e3%83%bc%e3%82%b6%e3%83%99%e3%83%bc%e3%82%b9%e6%a7%98&#34;&gt;ユーザベース様&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;記事: &lt;a href=&#34;https://tech.uzabase.com/entry/2024/12/15/090000&#34;&gt;Aurora MySQL 2から3へのアップグレード - 安全性とコストを考慮した移行プロセス - Uzabase for Engineers&lt;/a&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;影響調査として、更新系クエリの動作確認はバイナリログレプリケーションを利用した&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Auroraのブルーグリーンデプロイメントは、ブルー環境のブルー環境のクラスタに存在するDBインスタンスと同台数作成されてしまうのでコストが高いため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;アップグレード自体は、ブルー/グリーンデプロイ機能を利用した&#xA;&lt;ul&gt;&#xA;&lt;li&gt;逆方向レプリケーションで切り戻しがしやすいため&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;レプリケーションの方法が気になったので調べた&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Replication.MySQL.SettingUp.html#AuroraMySQL.Replication.MySQL.RetainBinlogs&#34;&gt;Aurora MySQL のバイナリログレプリケーションの設定 - Amazon Aurora&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>作りながら学ぶWebシステムの教科書</title>
      <link>http://localhost:1313/posts/001_%E4%BD%9C%E3%82%8A%E3%81%AA%E3%81%8C%E3%82%89%E5%AD%A6%E3%81%B6web%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AE%E6%95%99%E7%A7%91%E6%9B%B8/</link>
      <pubDate>Thu, 12 Dec 2024 15:07:51 +0900</pubDate>
      <guid>http://localhost:1313/posts/001_%E4%BD%9C%E3%82%8A%E3%81%AA%E3%81%8C%E3%82%89%E5%AD%A6%E3%81%B6web%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AE%E6%95%99%E7%A7%91%E6%9B%B8/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;概要&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/001_%E4%BD%9C%E3%82%8A%E3%81%AA%E3%81%8C%E3%82%89%E5%AD%A6%E3%81%B6web%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AE%E6%95%99%E7%A7%91%E6%9B%B8/#%e6%a6%82%e8%a6%81&#34;&gt;概要&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://info.nikkeibp.co.jp/media/LIN/atcl/books/081600038/&#34;&gt;作りながら学ぶWebシステムの教科書&lt;/a&gt;の読書メモ。気づきや調べたことをまとめていく。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;chapter2-webシステムの基本httphttpsプロトコルを理解する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/001_%E4%BD%9C%E3%82%8A%E3%81%AA%E3%81%8C%E3%82%89%E5%AD%A6%E3%81%B6web%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AE%E6%95%99%E7%A7%91%E6%9B%B8/#chapter2-web%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e3%81%ae%e5%9f%ba%e6%9c%achttphttps%e3%83%97%e3%83%ad%e3%83%88%e3%82%b3%e3%83%ab%e3%82%92%e7%90%86%e8%a7%a3%e3%81%99%e3%82%8b&#34;&gt;Chapter2 Webシステムの基本、HTTP／HTTPSプロトコルを理解する&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HTTP/1.1はテキストベースプロトコル(ASCII文字), HTTP/2はバイナリベースプロトコル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;それ以外にも1つのTCP接続で複数のリクエスト/レスポンスをやり取りできるようになったり、&lt;/li&gt;&#xA;&lt;li&gt;ヘッダの圧縮等がより、高速で効率的な通信を実現できるようになった&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://qiita.com/mogamin3/items/7698ee3336c70a482843#1%E3%81%A4%E3%81%AEtcp%E6%8E%A5%E7%B6%9A&#34;&gt;そろそろ知っておきたいHTTP/2の話 #http2 - Qiita&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;HTTP/3で特徴的なのはQUICと呼ばれるUDPベースの伝送制御上でHTTP通信を行い、高効率や通信を実現している&#xA;&lt;ul&gt;&#xA;&lt;li&gt;現在ALBではHTTP/3に対応しておらず、 HTTP/3に対応するにはCloudFrontを経由させる必要がある(?)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Webサーバー側の設定により、HTTPの使用可能なバージョンが定められている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;異なるバージョンでHTTPリクエストを送るとリダイレクトされたり、エラーが返されたりする&lt;/li&gt;&#xA;&lt;li&gt;普段ブラウザでWebページにアクセスする時はHTTPのバージョンを意識することがない理由はブラウザがよしなにやってくれている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;具体的には、ブラウザはデフォルトで多くのサーバーからサポートしているHTTP1.1を使用し、接続を確立する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;chapter3-linux&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/001_%E4%BD%9C%E3%82%8A%E3%81%AA%E3%81%8C%E3%82%89%E5%AD%A6%E3%81%B6web%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AE%E6%95%99%E7%A7%91%E6%9B%B8/#chapter3-linux&#34;&gt;Chapter3 Linux&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Linuxディストリビューション&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OSコアのLinuxカーネルに、UIを構成するデスクトップ環境やコマンド等のユーザーランドソフトウェアを組み合わせてコンピューターにインストールできるようにパッケージングされたもののこと&lt;/li&gt;&#xA;&lt;li&gt;サーバー向けのものも含め、現在は250種類以上も存在する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;代表的なのがRedHat系とDebian系&lt;/li&gt;&#xA;&lt;li&gt;RedHat自体は有償サポートがあるため、官公庁や比較的大きめの企業(お堅い金融機関等)で採用される傾向&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RedHatのソースコードを元にしたCentOSもかつては高いシェアを占めていたが、2021年の開発体制変更を境に多くはUbuntu Serverに移行した&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Debian系で有名なのがUbuntuであり、現在人気がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;シェルスクリプト&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コマンド結果をファイル出力: コマンド &amp;gt; ファイル&lt;/li&gt;&#xA;&lt;li&gt;コマンド結果をファイルに追記: コマンド &amp;raquo; ファイル&lt;/li&gt;&#xA;&lt;li&gt;コマンド結果を次の標準入力に使用: コマンド1 | コマンド2&lt;/li&gt;&#xA;&lt;li&gt;コマンドを続けて実行: コマンド1 ; コマンド2&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;chapter4-仮想化&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/001_%E4%BD%9C%E3%82%8A%E3%81%AA%E3%81%8C%E3%82%89%E5%AD%A6%E3%81%B6web%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AE%E6%95%99%E7%A7%91%E6%9B%B8/#chapter4-%e4%bb%ae%e6%83%b3%e5%8c%96&#34;&gt;Chapter4 仮想化&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;LXD: システムコンテナマネージャー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dockerがアプリケーション指向であるのに対し、LXDはシステム指向&lt;/li&gt;&#xA;&lt;li&gt;よりVMに近い動きをする&lt;/li&gt;&#xA;&lt;li&gt;サービス管理システムのsystemdに対応しているため、複数のプロセスやサービスを1コンテナで実行可能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dockerとは異なり、1つのコンテナでWebサーバーとDBサーバー等の複数のサービスを起動することができる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;コンテナ技術とLinuxのかかわり&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテナ型仮想化技術のように、ハイパーバイザーを使用しない仮想化プラットフォームの多くが、LinuxをホストOSとしている&lt;/li&gt;&#xA;&lt;li&gt;これにはLinuxはマルチユーザーOSであるがために、他のプロセスやリソースを厳密に管理する必要があったという背景がある&lt;/li&gt;&#xA;&lt;li&gt;Linuxカーネル機能の名前空間によって、ホストのリソースからコンテナのリソースを隔離して、安全にプロセスを実行できるようになっている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;具体的には、名前空間がコンテナAでプロセス(PID:1)とコンテナBでプロセス(PID:1)というのを可能にしている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;つまりまとめると、LinuxはマルチユーザーOSであること故に、1OSの中で複数のリソースやプロセスを管理したいという要求があり、カーネルの名前空間を良い感じに使用し、仮想化技術を実現している&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;chapter6-https&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/001_%E4%BD%9C%E3%82%8A%E3%81%AA%E3%81%8C%E3%82%89%E5%AD%A6%E3%81%B6web%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AE%E6%95%99%E7%A7%91%E6%9B%B8/#chapter6-https&#34;&gt;Chapter6 HTTPS&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SSL/TLSは、インターネット上の通信を暗号化するプロトコル&lt;/li&gt;&#xA;&lt;li&gt;SSLを新しい企画として再設計されたのがTLS&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ただしSSLが歴史的に長く使われている＋広く認知されているため、現在でもSSLとだけ表記されることがある&lt;/li&gt;&#xA;&lt;li&gt;最新はTLS1.3&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SSL/TLSの暗号化方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;共通鍵暗号方式と公開鍵暗号方式を同時に使用する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;HTTPS通信の流れ（技術詳細）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;登場人物と役割&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;認証局（CA: Certificate Authority）&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;信頼された第三者機関。サーバーの公開鍵が本物であることを証明し、証明書にデジタル署名を行う。&lt;/li&gt;&#xA;&lt;li&gt;CAはその証明書を発行する際に、RSAやECDSAなどのアルゴリズムを使ってサーバーの公開鍵やその他の情報にデジタル署名を施す。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;サーバー証明書&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバーの公開鍵、ドメイン名、証明書の有効期限、およびCAのデジタル署名が含まれた証明書。通常はX.509フォーマットで表現される。&lt;/li&gt;&#xA;&lt;li&gt;証明書には「Subject Public Key Info」というフィールドがあり、サーバーの公開鍵が格納されている。&lt;/li&gt;&#xA;&lt;li&gt;CAが発行した証明書であり、サーバーが信頼できることをクライアントに証明するために使用される。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;サーバー&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;自身の&lt;strong&gt;秘密鍵&lt;/strong&gt;を安全に管理し、&lt;strong&gt;公開鍵&lt;/strong&gt;を提供する。&lt;/li&gt;&#xA;&lt;li&gt;クライアントからの要求に対し、X.509フォーマットで表現されたサーバー証明書を送信する。&lt;/li&gt;&#xA;&lt;li&gt;クライアントから送信された共通鍵を秘密鍵を使って復号し、暗号化通信を確立する。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;クライアント（ブラウザなど）&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバーに対してHTTPS接続を要求し、サーバー証明書を受け取る。&lt;/li&gt;&#xA;&lt;li&gt;サーバー証明書のデジタル署名を、CAの公開鍵を使って検証し、証明書が改ざんされていないか確認する。&lt;/li&gt;&#xA;&lt;li&gt;証明書から公開鍵を取り出し、一時的な&lt;strong&gt;共通鍵&lt;/strong&gt;を生成してサーバーの公開鍵で暗号化する。&lt;/li&gt;&#xA;&lt;li&gt;共通鍵をサーバーに送信し、安全な通信を確立する。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;HTTPS通信の時系列&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;クライアントがサーバーに接続要求を送信&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クライアント（例：ブラウザ）は、HTTPSリクエストを送信し、サーバーに接続要求を行う。&lt;/li&gt;&#xA;&lt;li&gt;このとき、クライアントはサーバーにSSL/TLSハンドシェイクを開始します。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;サーバーがサーバー証明書を送信&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバーは自身のサーバー証明書（X.509形式）をクライアントに送信する。&lt;/li&gt;&#xA;&lt;li&gt;サーバー証明書には、サーバーの公開鍵、ドメイン名、有効期限、認証局（CA）の署名が含まれている。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;クライアントが証明書を検証&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クライアントは、証明書に含まれる署名をCAの公開鍵で検証する。ここでは次のステップが行われる：&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;証明書の署名検証&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;証明書に含まれているデータを使ってハッシュ値を再計算する。&lt;/li&gt;&#xA;&lt;li&gt;証明書に付与されたデジタル署名をCAの公開鍵を使って復号し、署名から得られたハッシュ値と再計算されたハッシュ値を比較する。&lt;/li&gt;&#xA;&lt;li&gt;一致すれば、署名が正当であり、証明書が改ざんされていないと判断される。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;証明書の有効期限確認&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;証明書の有効期限を確認し、現在の日付がその範囲内かを確認する。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ドメイン名の一致確認&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;証明書に含まれるドメイン名が、クライアントがアクセスしているドメインと一致するかを確認する。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;証明書の失効確認&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クライアントはCRL（証明書失効リスト）またはOCSP（Online Certificate Status Protocol）を使って、証明書が失効していないか確認する。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;クライアントが共通鍵を生成し、サーバーに送信&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クライアントは一時的な共通鍵（対称鍵暗号方式で使用される鍵）を生成する。共通鍵は通常AESなどの対称鍵アルゴリズムで利用される。&lt;/li&gt;&#xA;&lt;li&gt;生成した共通鍵をサーバーの公開鍵で暗号化し、サーバーに送信する。このプロセスにより、共通鍵はサーバーの秘密鍵を持つサーバーだけが復号できる。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;サーバーが共通鍵を復号&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバーは秘密鍵を使ってクライアントから送信された共通鍵を復号する。&lt;/li&gt;&#xA;&lt;li&gt;復号に成功した時点で、クライアントとサーバーは共通鍵を共有し、以降の通信はこの共通鍵を使って暗号化される。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;暗号化された通信の開始&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これで、クライアントとサーバーの間に安全な通信チャネルが確立され、以降のデータは共通鍵を使って暗号化されて送受信される。&lt;/li&gt;&#xA;&lt;li&gt;暗号化方式にはAESなどの対称鍵暗号方式が使われ、これにより通信内容が第三者に漏洩するリスクが低減される。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;サーバー証明書&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/001_%E4%BD%9C%E3%82%8A%E3%81%AA%E3%81%8C%E3%82%89%E5%AD%A6%E3%81%B6web%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AE%E6%95%99%E7%A7%91%E6%9B%B8/#%e3%82%b5%e3%83%bc%e3%83%90%e3%83%bc%e8%a8%bc%e6%98%8e%e6%9b%b8&#34;&gt;サーバー証明書&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバー証明書は通信の暗号化/なりすまし防止/改ざん防止の役割を担う&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通信データを暗号化する鍵としての役割だけでなく、Webサイトを運営する個人や企業が実際に存在するという実在性の証明するのにも使用される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;実在性の証明&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバー証明書を入手する時に、運営者の住所や連絡先（企業なら法人登記簿）を認証局に提出する必要がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サーバー証明書の取得&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバー証明書は、認証局（CA）と呼ばれる第三者機関により発行される&lt;/li&gt;&#xA;&lt;li&gt;Webブラウザには、認証局の正当性を証明するルート証明書が組み込まれていて、正規の認証局によって発行されたサーバー証明書なら、ルート証明書で正当性を確認できる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プライベートな認証局を立ち上げて、自前でサーバー証明書を発行することもできる&lt;/li&gt;&#xA;&lt;li&gt;Webブラウザにプライベートな認証局の証明書をインポートすることで、信頼されたルート証明機関として偽装できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;サーバー証明書の発行と署名からクライアントによる検証までの流れを整理する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/001_%E4%BD%9C%E3%82%8A%E3%81%AA%E3%81%8C%E3%82%89%E5%AD%A6%E3%81%B6web%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AE%E6%95%99%E7%A7%91%E6%9B%B8/#%e3%82%b5%e3%83%bc%e3%83%90%e3%83%bc%e8%a8%bc%e6%98%8e%e6%9b%b8%e3%81%ae%e7%99%ba%e8%a1%8c%e3%81%a8%e7%bd%b2%e5%90%8d%e3%81%8b%e3%82%89%e3%82%af%e3%83%a9%e3%82%a4%e3%82%a2%e3%83%b3%e3%83%88%e3%81%ab%e3%82%88%e3%82%8b%e6%a4%9c%e8%a8%bc%e3%81%be%e3%81%a7%e3%81%ae%e6%b5%81%e3%82%8c%e3%82%92%e6%95%b4%e7%90%86%e3%81%99%e3%82%8b&#34;&gt;サーバー証明書の発行と署名からクライアントによる検証までの流れを整理する&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;証明書発行までの流れ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;(サーバー)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;秘密鍵の作成&lt;/li&gt;&#xA;&lt;li&gt;CSRの作成&#xA;&lt;ul&gt;&#xA;&lt;li&gt;秘密鍵を元に作成した公開鍵&lt;/li&gt;&#xA;&lt;li&gt;ドメイン情報&lt;/li&gt;&#xA;&lt;li&gt;所有者情報(会社情報等)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CSRの送付(toCA)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;(CA)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CSRの検証&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ドメインの所有者が本当か？の確認&lt;/li&gt;&#xA;&lt;li&gt;所有者自体が正しく存在するか？の確認&lt;/li&gt;&#xA;&lt;li&gt;公開鍵で復号&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;証明書の発行&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CA側でも秘密鍵を作成し、それを用いて署名する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;署名＝秘密鍵を用いたハッシュ計算&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サーバーに証明書を送付&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;補足:証明書の仕組み&#xA;&lt;ul&gt;&#xA;&lt;li&gt;X.509という公開鍵インフラストラクチャの証明書形式の標準規格(フォーマット)&lt;/li&gt;&#xA;&lt;li&gt;CA側の公開鍵・所有者の識別情報・CAの署名・シリアル番号・有効期限等の情報が含まれている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;(サーバー)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;証明書をサーバーにインストール&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;証明書の検証&#xA;&lt;ul&gt;&#xA;&lt;li&gt;(クライアント)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバーにリクエスト&lt;/li&gt;&#xA;&lt;li&gt;TLSハンドシェイクを開始&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;(サーバー)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クライアントに証明書を送付&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;(クライアント)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;自身のシステム(OSやブラウザ)に信頼できるルート証明書として登録されているかを確認&lt;/li&gt;&#xA;&lt;li&gt;証明書に含まれるCAの署名を検証(CAによって正しく発行された証明書かどうかを確認するため)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CAの公開鍵を使って解読可能かを確認&lt;/li&gt;&#xA;&lt;li&gt;解読結果がサーバー証明書と一致するかを確認&#xA;&lt;ul&gt;&#xA;&lt;li&gt;復号して得たハッシュ値とクライアント側で計算したハッシュ値が同じであるかを確認するという意味&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;証明書の内容を検証&#xA;&lt;ul&gt;&#xA;&lt;li&gt;証明書に記載されたドメインとアクセスしようとしているドメインが一致するかを確認&lt;/li&gt;&#xA;&lt;li&gt;証明書に記載された有効期限を過ぎていないかを確認&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;TLSハンドシェイクの続行&#xA;&lt;ul&gt;&#xA;&lt;li&gt;暗号化されたセッションを開始&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ワークショップ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/001_%E4%BD%9C%E3%82%8A%E3%81%AA%E3%81%8C%E3%82%89%E5%AD%A6%E3%81%B6web%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AE%E6%95%99%E7%A7%91%E6%9B%B8/#%e3%83%af%e3%83%bc%e3%82%af%e3%82%b7%e3%83%a7%e3%83%83%e3%83%97&#34;&gt;ワークショップ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;EC2(UbuntuServer)を立てて、実際にHTTPSサーバーを立ててみた&#xA;&lt;ul&gt;&#xA;&lt;li&gt;詳細：https://github.com/nyuusen/web-system-textbook/tree/main/aws/web-server&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;chapter7-http2http3対応のhttpsサーバー&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/001_%E4%BD%9C%E3%82%8A%E3%81%AA%E3%81%8C%E3%82%89%E5%AD%A6%E3%81%B6web%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AE%E6%95%99%E7%A7%91%E6%9B%B8/#chapter7-http2http3%e5%af%be%e5%bf%9c%e3%81%aehttps%e3%82%b5%e3%83%bc%e3%83%90%e3%83%bc&#34;&gt;Chapter7 HTTP/2,HTTP/3対応のHTTPSサーバー&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HTTP1.1の課題&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一度に複数の画像等を読み込めるように多重リクエストが機能が導入されたものの、初めのリクエストに時間がかかると、後のリクエストが待機状態になる&lt;/li&gt;&#xA;&lt;li&gt;ヘッダー等の目に見えないデータの肥大化&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;HTTP/2の主要な機能とその改善ポイント&#xA;&lt;ul&gt;&#xA;&lt;li&gt;TLS上でHTTPセッションが確立されるため、安全性向上&lt;/li&gt;&#xA;&lt;li&gt;1つのTCPコネクション内で複数のHTTPリクエストとレスポンスを同時に送受信可能となり、通信の効率性向上&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;HTTP/2化する方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;非常に簡単で、Nginx設定ファイルを書き換えるだけ(使用しているNginxのバージョンがHTTP/2に対応している必要あり)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;chapter8-大規模webシステム&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/001_%E4%BD%9C%E3%82%8A%E3%81%AA%E3%81%8C%E3%82%89%E5%AD%A6%E3%81%B6web%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AE%E6%95%99%E7%A7%91%E6%9B%B8/#chapter8-%e5%a4%a7%e8%a6%8f%e6%a8%a1web%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0&#34;&gt;Chapter8 大規模Webシステム&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プロキシサーバー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クライアント側のネットワークで動作：フォワードプロキシサーバー&lt;/li&gt;&#xA;&lt;li&gt;サーバー側のネットワークで動作：リバースプロキシサーバー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ロードバランサーやCDNはリバースプロキシサーバーに該当する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;キャッシュ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ブラウザキャッシュとサーバーキャッシュ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ロードバランサー(LB)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;暗号化通信をLBが担うことでWebサーバーの負荷を軽減する&lt;/li&gt;&#xA;&lt;li&gt;LBはネットワークのゲートウェイ側に設置するので、セキュリティ管理を集約できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CDN&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CDNの仕組み&#xA;&lt;ul&gt;&#xA;&lt;li&gt;近い場所にあるキャッシュサーバーにアクセスする仕組みとしては、DNSを用いた方法が一般的&lt;/li&gt;&#xA;&lt;li&gt;専用のDNSサーバーがIPアドレスからどの地域のISPなのかを調べ、あらかじめ用意されているデータベースと照合し、地理的に一番近いキャッシュサーバーのIPアドレスを返している&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>GitHubActions上におけるAWSの認証認可</title>
      <link>http://localhost:1313/posts/authenticate-aws/</link>
      <pubDate>Fri, 06 Dec 2024 21:56:17 +0900</pubDate>
      <guid>http://localhost:1313/posts/authenticate-aws/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;どのようにするのが良いか&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/authenticate-aws/#%e3%81%a9%e3%81%ae%e3%82%88%e3%81%86%e3%81%ab%e3%81%99%e3%82%8b%e3%81%ae%e3%81%8c%e8%89%af%e3%81%84%e3%81%8b&#34;&gt;どのようにするのが良いか？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;AWS への API 呼び出しは認証情報で署名する必要があるため、AWS SDK または AWS ツールのいずれかを使用する場合は、AWS 認証情報と AWS リージョンを提供する必要があります。GitHub Actions でこれを行う 1 つの方法は、IAM 認証情報でリポジトリシークレットを使用することですが、これは長期認証情報の使用に関するAWS セキュリティガイドラインに準拠していません 。代わりに、長期認証情報または JWT を使用して一時的な認証情報を取得し、それをツールで使用することをお勧めします。この GitHub Action はまさにそれを実現します。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;AWS公式が運用・公開しているGitHubActionsワークフローには、上記のように記載がある。&#xA;参考: &lt;a href=&#34;https://github.com/aws-actions/configure-aws-credentials?tab=readme-ov-file&#34;&gt;aws-actions/configure-aws-credentials&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;つまり、GitHubのSecretsに長期的なアクセス情報を保持するのは適切ではないので、&lt;strong&gt;一時的な認証情報をやり取りするのが良い&lt;/strong&gt;というようなことが書かれている。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;一時的な認証情報はどうやって&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/authenticate-aws/#%e4%b8%80%e6%99%82%e7%9a%84%e3%81%aa%e8%aa%8d%e8%a8%bc%e6%83%85%e5%a0%b1%e3%81%af%e3%81%a9%e3%81%86%e3%82%84%e3%81%a3%e3%81%a6&#34;&gt;一時的な認証情報はどうやって？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;結論、AssumeRoleを使用してやり取りする。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ざっくりな手順理解用&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/authenticate-aws/#%e3%81%96%e3%81%a3%e3%81%8f%e3%82%8a%e3%81%aa%e6%89%8b%e9%a0%86%e7%90%86%e8%a7%a3%e7%94%a8&#34;&gt;ざっくりな手順(理解用)&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GitHubとAWSが認証情報をやり取りできるように設定&#xA;&lt;ul&gt;&#xA;&lt;li&gt;具体的にはOpenID Connect&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;AWS側でIAMロールを作成する&lt;/li&gt;&#xA;&lt;li&gt;GitHubActions側でIAMロールを指定してAssumeRoleを実行する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWS CLIを実行してとかではなく、[aws-actions/configure-aws-credentials]という便利なワークフローを使用する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;具体的な手順&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/authenticate-aws/#%e5%85%b7%e4%bd%93%e7%9a%84%e3%81%aa%e6%89%8b%e9%a0%86&#34;&gt;具体的な手順&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;基本的なことは以下に書かれている。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.github.com/ja/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services#adding-the-identity-provider-to-aws&#34;&gt;アマゾン ウェブ サービスでの OpenID Connect の構成 - GitHub Docs&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;少し補足すると、AWS側では以下の設定が必要になる。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IDプロバイダとしてGitHubを登録する(OpenID Connect)&lt;/li&gt;&#xA;&lt;li&gt;GitHubActionsが引き受けるIAMロール(それに紐付けるIAMポリシーも)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;信頼関係の条件には、&lt;code&gt;&amp;quot;token.actions.githubusercontent.com:sub&amp;quot;: &amp;quot;repo:octo-org/octo-repo:ref:refs/heads/octo-branch&amp;quot;&lt;/code&gt;のように指定することで、GitHubActionsからの引き受けを制限できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/authenticate-aws/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.github.com/ja/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services#prerequisites&#34;&gt;アマゾン ウェブ サービスでの OpenID Connect の構成 - GitHub Docs&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/aws-actions/configure-aws-credentials?tab=readme-ov-file&#34;&gt;aws-actions/configure-aws-credentials&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.github.com/ja/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect&#34;&gt;OpenID Connect を使ったセキュリティ強化について - GitHub Docs&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OpenID Connectについて詳しく書かれている。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>VPCピアリング</title>
      <link>http://localhost:1313/posts/vpc-peering/</link>
      <pubDate>Wed, 04 Dec 2024 19:30:17 +0900</pubDate>
      <guid>http://localhost:1313/posts/vpc-peering/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;vpcピアリングとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/vpc-peering/#vpc%e3%83%94%e3%82%a2%e3%83%aa%e3%83%b3%e3%82%b0%e3%81%a8%e3%81%af&#34;&gt;VPCピアリングとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;プライベート IPv4 アドレスまたは IPv6 アドレスを使用して 2 つの VPC 間でトラフィックをルーティングすることを可能にするネットワーク接続です。&#xA;どちらの VPC のインスタンスも、同じネットワーク内に存在しているかのように、相互に通信できます。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/vpc/latest/peering/what-is-vpc-peering.html&#34;&gt;VPC ピア機能とは - Amazon Virtual Private Cloud&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;料金&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/vpc-peering/#%e6%96%99%e9%87%91&#34;&gt;料金&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接続の確立には料金かからない&lt;/li&gt;&#xA;&lt;li&gt;AZ内での接続でのデータ通信も料金かからない&lt;/li&gt;&#xA;&lt;li&gt;ただし、異なるAZやリージョン間でのデータ通信には料金が発生する&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/vpc/latest/peering/what-is-vpc-peering.html&#34;&gt;VPC ピア機能とは - Amazon Virtual Private Cloud&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;vpcピアリング接続の構築手順&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/vpc-peering/#vpc%e3%83%94%e3%82%a2%e3%83%aa%e3%83%b3%e3%82%b0%e6%8e%a5%e7%b6%9a%e3%81%ae%e6%a7%8b%e7%af%89%e6%89%8b%e9%a0%86&#34;&gt;VPCピアリング接続の構築手順&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;詳細は&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/vpc/latest/peering/vpc-peering-basics.html&#34;&gt;VPC ピアリングのプロセス、ライフサイクル、制限 - Amazon Virtual Private Cloud&lt;/a&gt;に記載されている。&lt;/p&gt;&#xA;&lt;p&gt;アカウントAのVPCからアカウントBにVPCに接続する前提だと、ざっくりと以下の流れ。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アカウントAでVPCピアリングを作成&#xA;&lt;ul&gt;&#xA;&lt;li&gt;この時に接続先としてアカウントBのVPCを選択する&lt;/li&gt;&#xA;&lt;li&gt;作成したら「承諾の保留中」というステータスになる&lt;/li&gt;&#xA;&lt;li&gt;アカウントAのVPCはリクエスタという扱いになる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;アカウントBで該当のピアリング接続を選択し「リクエストを承諾」を選択する&lt;/li&gt;&#xA;&lt;li&gt;アカウントAの対象VPCのルートテーブルを更新する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ターゲットには「ピアリング接続」を選択し、送信先には接続先VPCのCIDRを指定する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;アカウントBの対象VPCのルートテーブルを更新する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アカウントAでの設定の逆を設定する&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/vpc/latest/peering/vpc-peering-routing.html&#34;&gt;VPC ピアリング接続のルートテーブルを更新する - Amazon Virtual Private Cloud&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;アカウントBで対象リソースのセキュリティグループを変更する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アカウントA側のリソースにアタッチしているセキュリティグループorアカウントAのVPCのCIDR&#xA;&lt;ul&gt;&#xA;&lt;li&gt;前者の方が狭く絞れる分、セキュリティ性は高い&lt;/li&gt;&#xA;&lt;li&gt;ちなみに、両方のVPCが同じリージョンにある場合のみ、相手のVPCのセキュリティグループを参照できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;アカウントAのVPCのリソースから、アカウントBのリソースへ接続する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ルートテーブルに従って、ピアリング接続で接続できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;注意点&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/vpc-peering/#%e6%b3%a8%e6%84%8f%e7%82%b9&#34;&gt;注意点&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;複数のVPCピアリング接続はできない(必ず1対1である必要がある/&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/vpc/latest/peering/vpc-peering-basics.html#vpc-peering-basics-multiple&#34;&gt;参考&lt;/a&gt;)&lt;/li&gt;&#xA;&lt;li&gt;プライベートIPで名前解決を行うので、それぞれのVPCでCIDRが重複してはいけない(&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/vpc/latest/peering/vpc-peering-basics.html#:~:text=%E3%82%A2%E3%82%AF%E3%82%BB%E3%83%97%E3%82%BF%20VPC%20%E3%81%AF%E3%83%AA%E3%82%AF%E3%82%A8%E3%82%B9%E3%82%BF%20VPC%20%E3%81%AE%20CIDR%20%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%81%A8%E9%87%8D%E8%A4%87%E3%81%99%E3%82%8B%20CIDR%20%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%82%92%E4%BF%9D%E6%8C%81%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%AF%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93%E3%80%82&#34;&gt;参考&lt;/a&gt;)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;役立つシーン&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/vpc-peering/#%e5%bd%b9%e7%ab%8b%e3%81%a4%e3%82%b7%e3%83%bc%e3%83%b3&#34;&gt;役立つシーン&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPC跨ぎのデータ取得や移行など&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>プレフィックスリスト</title>
      <link>http://localhost:1313/posts/prefix-list/</link>
      <pubDate>Mon, 02 Dec 2024 11:36:10 +0900</pubDate>
      <guid>http://localhost:1313/posts/prefix-list/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;プレフィックスリストとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/prefix-list/#%e3%83%97%e3%83%ac%e3%83%95%e3%82%a3%e3%83%83%e3%82%af%e3%82%b9%e3%83%aa%e3%82%b9%e3%83%88%e3%81%a8%e3%81%af&#34;&gt;プレフィックスリストとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;複数のIPアドレス範囲をまとめて管理できる&lt;/li&gt;&#xA;&lt;li&gt;AWSが提供する「AWSマネージドプレフィックスリスト」と、ユーザー側が作成する「カスタマーマネージドプレフィックスリスト」が存在する&lt;/li&gt;&#xA;&lt;li&gt;作成されたリージョンのみで利用可能&lt;/li&gt;&#xA;&lt;li&gt;セキュリティグループ等でIPアドレス単位で設定をする際に有用&lt;/li&gt;&#xA;&lt;li&gt;IPアドレスリストを手動で管理する際のオーバーヘッド発生を防ぐ&lt;/li&gt;&#xA;&lt;li&gt;AWS側が提供するIPアドレス情報に依存することで、設定ミス等を防ぐこともでき、セキュリティ的にも良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;awsが自動作成するプレフィックスリスト&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/prefix-list/#aws%e3%81%8c%e8%87%aa%e5%8b%95%e4%bd%9c%e6%88%90%e3%81%99%e3%82%8b%e3%83%97%e3%83%ac%e3%83%95%e3%82%a3%e3%83%83%e3%82%af%e3%82%b9%e3%83%aa%e3%82%b9%e3%83%88&#34;&gt;AWSが自動作成するプレフィックスリスト&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;S3 VPCエンドポイント(ゲートウェイ型)&lt;/li&gt;&#xA;&lt;li&gt;Dynamo DB VPCエンドポイント(ゲートウェイ型)&lt;/li&gt;&#xA;&lt;li&gt;EC2 Instance Connect&lt;/li&gt;&#xA;&lt;li&gt;VPC Lattice&#xA;※よく見かけるものを抜粋&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;実際にどのような場面で役立つか&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/prefix-list/#%e5%ae%9f%e9%9a%9b%e3%81%ab%e3%81%a9%e3%81%ae%e3%82%88%e3%81%86%e3%81%aa%e5%a0%b4%e9%9d%a2%e3%81%a7%e5%bd%b9%e7%ab%8b%e3%81%a4%e3%81%8b&#34;&gt;実際にどのような場面で役立つか？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;同じ内容を持つ複数のセキュリティグループを作成したい場合&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/prefix-list/#%e5%90%8c%e3%81%98%e5%86%85%e5%ae%b9%e3%82%92%e6%8c%81%e3%81%a4%e8%a4%87%e6%95%b0%e3%81%ae%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3%e3%82%b0%e3%83%ab%e3%83%bc%e3%83%97%e3%82%92%e4%bd%9c%e6%88%90%e3%81%97%e3%81%9f%e3%81%84%e5%a0%b4%e5%90%88&#34;&gt;同じ内容を持つ複数のセキュリティグループを作成したい場合&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えば、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;セキュリティグループを用いてインバウンドルールの送信元IPアドレスを制御したい&lt;/li&gt;&#xA;&lt;li&gt;同様の内容を制御するセキュリティグループをいくつか作成したい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;各セキュリティグループにIPアドレスを手打ちしていくのは手間がかかる＋設定ミスの恐れがある&lt;/li&gt;&#xA;&lt;li&gt;プレフィックスリストを使用することで、IPアドレスの設定を1箇所にまとめることができ、複数のセキュリティグループからそれを参照させることができる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;s3のvpcエンドポイントゲートウェイ型を利用する時&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/prefix-list/#s3%e3%81%aevpc%e3%82%a8%e3%83%b3%e3%83%89%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88%e3%82%b2%e3%83%bc%e3%83%88%e3%82%a6%e3%82%a7%e3%82%a4%e5%9e%8b%e3%82%92%e5%88%a9%e7%94%a8%e3%81%99%e3%82%8b%e6%99%82&#34;&gt;S3のVPCエンドポイント(ゲートウェイ型)を利用する時&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接続元の方のルートテーブルに自動で生成される&lt;/li&gt;&#xA;&lt;li&gt;以下のような内容&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ターゲット: vpce-xxxxx&lt;/li&gt;&#xA;&lt;li&gt;送信先: pl-xxxx(自動生成されたプレフィックスリスト)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/prefix-list/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/vpc/latest/userguide/working-with-aws-managed-prefix-lists.html&#34;&gt;AWS マネージドプレフィックスリスト - Amazon Virtual Private Cloud&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>KMS</title>
      <link>http://localhost:1313/posts/kms/</link>
      <pubDate>Fri, 29 Nov 2024 21:55:12 +0900</pubDate>
      <guid>http://localhost:1313/posts/kms/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;kmsとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/kms/#kms%e3%81%a8%e3%81%af&#34;&gt;KMSとは&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;暗号化キーの作成と管理機能を提供するマネージドサービス&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/kms/latest/developerguide/overview.html&#34;&gt;AWS Key Management Service - AWS Key Management Service&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;kmsの必要性&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/kms/#kms%e3%81%ae%e5%bf%85%e8%a6%81%e6%80%a7&#34;&gt;KMSの必要性&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;データの暗号化に必要な暗号化キーを保護する必要がある&lt;/li&gt;&#xA;&lt;li&gt;キーの作成・管理・使用・削除がAWS KMS内でのみで行われるので、安全性が高い&#xA;&lt;ul&gt;&#xA;&lt;li&gt;自前でこの辺りやるのは大変だけど、KMSで楽に安全にできるよということ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;kmsの料金&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/kms/#kms%e3%81%ae%e6%96%99%e9%87%91&#34;&gt;KMSの料金&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;作成したキーに対して、1USD/月&lt;/li&gt;&#xA;&lt;li&gt;ローテーションすると2回目までは1USD/月&lt;/li&gt;&#xA;&lt;li&gt;APIリクエストあたり0.0x$&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/jp/kms/pricing/&#34;&gt;料金 - AWS Key Management Service | AWS&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;エイリアス&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/kms/#%e3%82%a8%e3%82%a4%e3%83%aa%e3%82%a2%e3%82%b9&#34;&gt;エイリアス&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;自動で生成される識別子は判別しづらいので、エイリアスを付与することで判別しやすくなる&lt;/li&gt;&#xA;&lt;li&gt;エイリアスを使用することで、キーをノーテーションしてもアプリケーション側での変更が不要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;kmsのポリシー&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/kms/#kms%e3%81%ae%e3%83%9d%e3%83%aa%e3%82%b7%e3%83%bc&#34;&gt;KMSのポリシー&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;KMS側にはキーポリシーがある&lt;/li&gt;&#xA;&lt;li&gt;キーポリシーでは暗号キーに対して、どのリソースに対して何をできるかを定義することで、特定のサービスからのみアクセスさせるという制御が可能&lt;/li&gt;&#xA;&lt;li&gt;例えば、ECSタスクに割り当てるロールに、特定のKMSに対する暗号復号のアクションを許可するみたいなことができる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>AWS Certificate Manager</title>
      <link>http://localhost:1313/posts/acm/</link>
      <pubDate>Wed, 27 Nov 2024 22:55:34 +0900</pubDate>
      <guid>http://localhost:1313/posts/acm/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;acmとリージョンの関係&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/acm/#acm%e3%81%a8%e3%83%aa%e3%83%bc%e3%82%b8%e3%83%a7%e3%83%b3%e3%81%ae%e9%96%a2%e4%bf%82&#34;&gt;ACMとリージョンの関係&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ACM証明書はリージョナルリソースであるため、作成する際に適用するリソースに合わせ、リージョンを意識する必要がある。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CloudFront&#xA;&lt;ul&gt;&#xA;&lt;li&gt;グローバルサービスなので、&lt;strong&gt;米国東部 (バージニア北部, us-east-1) リージョン&lt;/strong&gt;に作成する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ALB&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リージョンサービスなので、&lt;strong&gt;ALBが配置されているリージョン&lt;/strong&gt;に作成する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;通信が暗号化する流れおさらい&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/acm/#%e9%80%9a%e4%bf%a1%e3%81%8c%e6%9a%97%e5%8f%b7%e5%8c%96%e3%81%99%e3%82%8b%e6%b5%81%e3%82%8c%e3%81%8a%e3%81%95%e3%82%89%e3%81%84&#34;&gt;通信が暗号化する流れ(おさらい)&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバー側に証明書と秘密鍵をインストールする(証明書発行前の手続き等は省略)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これを担うのがACM証明書&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;クライアントからのHTTPS通信に対し、証明書を返却する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クライアント側でCAやドメインの検証が行われる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;クライアントからの通信が公開鍵で暗号化される&lt;/li&gt;&#xA;&lt;li&gt;サーバー側で保持している秘密鍵で通信を復号する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;この辺り(というか証明書発行・認証周りを)を抽象化、マネージドに提供してくれているのがACMとなる&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;acmの認証について&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/acm/#acm%e3%81%ae%e8%aa%8d%e8%a8%bc%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6&#34;&gt;ACMの認証について&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ACMに限らない話だが、証明書を発行する際に、証明書を発行した者が問題ないか？ドメインに対する権限を持っているか？等を検証する必要がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;この確認がないと、好き勝手に証明書作り放題になる&lt;/li&gt;&#xA;&lt;li&gt;ここを実施しているのがCA(認証局)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;その検証の部分を「認証」と呼ぶ&lt;/li&gt;&#xA;&lt;li&gt;認証には、DV・OV・EV認証という種類がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;参考: &lt;a href=&#34;https://www.digicert.com/jp/difference-between-dv-ov-and-ev-ssl-certificates&#34;&gt;DV、OV、EV の各 SSL 証明書の違いとは | DigiCert&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;右に行くほど厳格な認証方法となる&lt;/li&gt;&#xA;&lt;li&gt;ACMはDV認証(ドメイン認証＝該当ドメインに対する権限を保持しているかどうかのみを確認する)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ACMはDV認証をどうやっているのか？という話になるが、以下の手順で確認する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ACM証明書を発行すると、CNAME名とCNAME値が発行される(この段階ではACM証明書は未承認状態)&lt;/li&gt;&#xA;&lt;li&gt;該当ドメインのホストゾーンにCNAME名とCNAME値をCNAMEレコードとして登録する&lt;/li&gt;&#xA;&lt;li&gt;ACM証明書が認証状態になる 🎉&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>WebアプリケーションをECSからLambdaに移行する</title>
      <link>http://localhost:1313/posts/ecs-migrate-to-lambda/</link>
      <pubDate>Wed, 06 Nov 2024 18:18:40 +0900</pubDate>
      <guid>http://localhost:1313/posts/ecs-migrate-to-lambda/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考資料&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/ecs-migrate-to-lambda/#%e5%8f%82%e8%80%83%e8%b3%87%e6%96%99&#34;&gt;参考資料&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/fujiwara3/yapc-hakodate2024&#34;&gt;https://speakerdeck.com/fujiwara3/yapc-hakodate2024&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;要約&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/ecs-migrate-to-lambda/#%e8%a6%81%e7%b4%84&#34;&gt;要約&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;元はECSで動いていたWebアプリケーションだが、負荷予測を外した時に障害もしくはインフラコスト過剰にかかる課題があった&lt;/li&gt;&#xA;&lt;li&gt;AWS Lambda Web Adapterを使って、Lambdaで Webアプリケーションを動かす&lt;/li&gt;&#xA;&lt;li&gt;結果として、実際の負荷に応じてスケーリングしてくれて課題が解消された&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;感想&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/ecs-migrate-to-lambda/#%e6%84%9f%e6%83%b3&#34;&gt;感想&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Lambdaはシンプルな関数を配置するイメージがあったが、Adapterを使うことでWebアプリケーションも配置できることを知れた&lt;/li&gt;&#xA;&lt;li&gt;Lambdaであれば、実行時間等の制約があるものの、実際に負荷に応じたスケーリングをしてくれるのがとても良いなと思った&lt;/li&gt;&#xA;&lt;li&gt;最後のスライドでも言及されているが、向き不向きもある。アーキテクチャ選定の選択肢の1つとして頭に入れておきたい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Dependabot</title>
      <link>http://localhost:1313/posts/dependabot/</link>
      <pubDate>Wed, 30 Oct 2024 23:36:19 +0900</pubDate>
      <guid>http://localhost:1313/posts/dependabot/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;dependabotとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/dependabot/#dependabot%e3%81%a8%e3%81%af&#34;&gt;Dependabotとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GitHubによって提供される、プロジェクトの依存関係を自動的に管理・更新するツール&lt;/li&gt;&#xA;&lt;li&gt;依存関係の脆弱性アップデートを通知してくれたり、自動的に提案するプルリクエストを作成してくれたりする&lt;/li&gt;&#xA;&lt;li&gt;詳細は：&lt;a href=&#34;https://docs.github.com/ja/code-security/supply-chain-security/understanding-your-software-supply-chain/about-supply-chain-security#what-is-dependabot&#34;&gt;Dependabotとは&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;使い方&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/dependabot/#%e4%bd%bf%e3%81%84%e6%96%b9&#34;&gt;使い方&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GitHubリポジトリの設定から有効化できる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Security &amp;gt; Code security and analysis&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;.github/dependabot.ymlにチェック頻度や対象範囲を定義できる&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.github.com/ja/code-security/dependabot/working-with-dependabot&#34;&gt;Dependabot を使う - GitHub Docs&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;githubactionsワークフローを用いて効率的に運用する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/dependabot/#githubactions%e3%83%af%e3%83%bc%e3%82%af%e3%83%95%e3%83%ad%e3%83%bc%e3%82%92%e7%94%a8%e3%81%84%e3%81%a6%e5%8a%b9%e7%8e%87%e7%9a%84%e3%81%ab%e9%81%8b%e7%94%a8%e3%81%99%e3%82%8b&#34;&gt;GitHubActionsワークフローを用いて効率的に運用する&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えば、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プルリクエスト作成時に自動でテスト実行する等のワークフローを組み込んでおく&lt;/li&gt;&#xA;&lt;li&gt;dependabot/fetch-metadata アクションを用いてアップデート情報を取得する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;取得した結果をPRにコメントとしてぶら下げるみたいなこともできそう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ただし、プルリクエストは人間の目で見て、マージすることが推奨されている(そりゃそう)&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.github.com/ja/code-security/dependabot/working-with-dependabot/automating-dependabot-with-github-actions&#34;&gt;GitHub ActionsでのDependabotの自動化 - GitHub Docs&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;注意点&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/dependabot/#%e6%b3%a8%e6%84%8f%e7%82%b9&#34;&gt;注意点&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;docker&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/dependabot/#docker&#34;&gt;Docker&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;DependabotにはDockerfileのベースイメージ(FROMフィールド)に記述されたバージョンアップの対象とすることができるが、&lt;br&gt;&#xA;DockerComposeファイル(compose.yaml)に記述されたイメージ指定(imageフィールド)を対象とすることは現状できない。&lt;/p&gt;&#xA;&lt;p&gt;対策としては、DockerComposeにイメージをベタ書きせずにDockerfileに切り出すとかRenovateにするかとか&amp;hellip;&lt;/p&gt;&#xA;&lt;p&gt;参考：&lt;a href=&#34;https://github.com/dependabot/dependabot-core/issues/390&#34;&gt;Docker Compose files対応が待ち望まれているIssue&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>AWSにおけるコスト削減対応</title>
      <link>http://localhost:1313/posts/cost-reduction/</link>
      <pubDate>Mon, 28 Oct 2024 22:57:29 +0900</pubDate>
      <guid>http://localhost:1313/posts/cost-reduction/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cost-reduction/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;業務や参加した勉強会でコスト削減についての学びがあったのでメモ&lt;/p&gt;&#xA;&lt;p&gt;勉強会URL: &lt;a href=&#34;https://www.youtube.com/live/WOsD-Rk3SVg?si=El_AK4863iGt8L42&#34;&gt;https://www.youtube.com/live/WOsD-Rk3SVg?si=El_AK4863iGt8L42&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;大前提としての心構え&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cost-reduction/#%e5%a4%a7%e5%89%8d%e6%8f%90%e3%81%a8%e3%81%97%e3%81%a6%e3%81%ae%e5%bf%83%e6%a7%8b%e3%81%88&#34;&gt;大前提としての心構え&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コスト削減対応で浮いた分は単純な利益増につながる&lt;/li&gt;&#xA;&lt;li&gt;つまり後回しにせず、早くやろうぜという気持ちで&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;やり方&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cost-reduction/#%e3%82%84%e3%82%8a%e6%96%b9&#34;&gt;やり方&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;モブでやってあーだこーだ言ってみる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;職能を絞らないでやるのも視野が広がって良いアイディアが生まれたりする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;具体的なコストカットポイント&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/cost-reduction/#%e5%85%b7%e4%bd%93%e7%9a%84%e3%81%aa%e3%82%b3%e3%82%b9%e3%83%88%e3%82%ab%e3%83%83%e3%83%88%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88&#34;&gt;具体的なコストカットポイント&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;NATゲートウェイ→VPC Endpoint&#xA;&lt;ul&gt;&#xA;&lt;li&gt;やはりNATゲートウェイは高い！&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ECRからのイメージプルをECR pull through cacheでキャッシュ化&lt;/li&gt;&#xA;&lt;li&gt;コンテナイメージのサイズダウン&lt;/li&gt;&#xA;&lt;li&gt;各インスタンスのサイジングやスペック見直し&lt;/li&gt;&#xA;&lt;li&gt;テスト環境のサーバーを夜間休日は停止する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例: Amazon EventBridge Schedulerで平日夜間になったらECSのタスク数を0にする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;リザーブドインスタンスやSavingsPlansの活用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>IPv4 VPC CIDRブロック</title>
      <link>http://localhost:1313/posts/vpc-ipv4-cidr-block/</link>
      <pubDate>Mon, 28 Oct 2024 22:57:29 +0900</pubDate>
      <guid>http://localhost:1313/posts/vpc-ipv4-cidr-block/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;概要&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/vpc-ipv4-cidr-block/#%e6%a6%82%e8%a6%81&#34;&gt;概要&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;VPCを作成するときに、そのVPCのIPv4 CIDRブロックを指定する必要がある。&lt;br&gt;&#xA;許可されるブロックは、/16ネットマスク（65,536個のIPアドレス）から/28ネットマスク（16個のIPアドレス）になる。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;cidrブロックについて簡単に整理&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/vpc-ipv4-cidr-block/#cidr%e3%83%96%e3%83%ad%e3%83%83%e3%82%af%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6%e7%b0%a1%e5%8d%98%e3%81%ab%e6%95%b4%e7%90%86&#34;&gt;CIDRブロックについて簡単に整理&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;/数字の数字に当たる部分がネットワークアドレスとして固定化される&lt;/li&gt;&#xA;&lt;li&gt;IPアドレスは32ビットで表現される例えば/16の場合は、前半16ビットがネットワーク部・後半16ビットがホスト部になる&lt;/li&gt;&#xA;&lt;li&gt;従来のクラスに縛られない効率的なIPアドレス管理を目的とした方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;プライベートipアドレスに指定する範囲&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/vpc-ipv4-cidr-block/#%e3%83%97%e3%83%a9%e3%82%a4%e3%83%99%e3%83%bc%e3%83%88ip%e3%82%a2%e3%83%89%e3%83%ac%e3%82%b9%e3%81%ab%e6%8c%87%e5%ae%9a%e3%81%99%e3%82%8b%e7%af%84%e5%9b%b2&#34;&gt;プライベートIPアドレスに指定する範囲&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以下で設定されることが推奨されている&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;10.0.0.0/8 – 範囲：10.0.0.0 ～ 10.255.255.255&#xA;172.16.0.0/12 – 範囲：172.16.0.0 ～ 172.31.255.255&#xA;192.168.0.0/16 – 範囲：192.168.0.0 ～ 192.168.255.255&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これはRFC1918で指定されているもの&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ネットワーク部が固定数値である理由&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/vpc-ipv4-cidr-block/#%e3%83%8d%e3%83%83%e3%83%88%e3%83%af%e3%83%bc%e3%82%af%e9%83%a8%e3%81%8c%e5%9b%ba%e5%ae%9a%e6%95%b0%e5%80%a4%e3%81%a7%e3%81%82%e3%82%8b%e7%90%86%e7%94%b1&#34;&gt;ネットワーク部が固定数値である理由&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;例えば、/8(10.0.0.0/8)の場合の第1オクテッドがなぜ「10」であるのかが気になった。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;結論：インターネット上の実際のパブリックIPアドレスと競合を防ぐため&lt;/li&gt;&#xA;&lt;li&gt;RFC1918で定義された範囲以外のIPアドレスをプライベートネットワークで使用すると、インターネット上のパブリックIPアドレスと競合する可能性がある&lt;/li&gt;&#xA;&lt;li&gt;そのため、インターネット上でユニークであることが保証されないプライベートネットワークでは、RFC1918で指定された「10.0.0.0/8」「172.16.0.0/12」「192.168.0.0/16」の範囲のみが使用されることが推奨されている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;rfc1918定義外のcidrブロックは指定できるのか&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/vpc-ipv4-cidr-block/#rfc1918%e5%ae%9a%e7%be%a9%e5%a4%96%e3%81%aecidr%e3%83%96%e3%83%ad%e3%83%83%e3%82%af%e3%81%af%e6%8c%87%e5%ae%9a%e3%81%a7%e3%81%8d%e3%82%8b%e3%81%ae%e3%81%8b&#34;&gt;RFC1918定義外のCIDRブロックは指定できるのか？&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;それを検証している面白い記事を発見&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://dev.classmethod.jp/articles/assign-ip-addresses-outside-the-rfc-1918-definition-to-the-cidr-block-of-the-vpc/#toc-2&#34;&gt;RFC 1918定義外のIPアドレスをVPCのCIDRブロックに指定してみた | DevelopersIO&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;設定はできるが、ALBターゲットに設定できなかったりと、色々な不具合があるらしい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/vpc-ipv4-cidr-block/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/vpc/latest/userguide/vpc-cidr-blocks.html&#34;&gt;VPC CIDR ブロック - Amazon Virtual Private Cloud&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>DNS</title>
      <link>http://localhost:1313/posts/dns/</link>
      <pubDate>Thu, 24 Oct 2024 22:57:11 +0900</pubDate>
      <guid>http://localhost:1313/posts/dns/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;名前解決の流れ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/dns/#%e5%90%8d%e5%89%8d%e8%a7%a3%e6%b1%ba%e3%81%ae%e6%b5%81%e3%82%8c&#34;&gt;名前解決の流れ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クライアントがドメイン(example.com)へのアクセスを試行する&lt;/li&gt;&#xA;&lt;li&gt;クライアントが設定されたDNSリゾルバにドメイン名を問い合わせを行う&lt;/li&gt;&#xA;&lt;li&gt;DNSリゾルバがルートネームサーバ(.com)にネームサーバー(NS)情報を取得する&lt;/li&gt;&#xA;&lt;li&gt;DNSリゾルバがセカンドレベルドメイン(example.com)からIPアドレスを取得する&lt;/li&gt;&#xA;&lt;li&gt;DNSリゾルバがクライアントにIPアドレスを返す&lt;/li&gt;&#xA;&lt;li&gt;クライアントが名前解決されたドメインにアクセスする&lt;/li&gt;&#xA;&lt;li&gt;参考: &lt;a href=&#34;https://zenn.dev/msy/articles/e1e5aed46a3e49&#34;&gt;新入社員「DNSってなんですか？」→ これ、どこまで答えられますか？？？？？？？？？&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ドメイン移管の流れ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/dns/#%e3%83%89%e3%83%a1%e3%82%a4%e3%83%b3%e7%a7%bb%e7%ae%a1%e3%81%ae%e6%b5%81%e3%82%8c&#34;&gt;ドメイン移管の流れ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;業務でAWSアカウントを跨いだドメイン移管を行ったので、流れをまとめておく。&lt;br&gt;&#xA;AWSのRoute53を用いてドメイン管理を行なっているものとする。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;移管先に対象ドメインのホストゾーンを作成(NSレコードが生成される)&lt;/li&gt;&#xA;&lt;li&gt;親ドメインを管理しているホストゾーンの対象ドメインのNSレコードを更新する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;注意ポイント&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/dns/#%e6%b3%a8%e6%84%8f%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88&#34;&gt;注意ポイント&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;対象ドメインの向き先(Aレコード)はCloudFrontディストリビューション(CFD)であったが、代替ドメイン名(CNAMEs)はユニークである必要があった&#xA;&lt;ul&gt;&#xA;&lt;li&gt;そのため、旧アカウントと新アカウントのそれぞれのCFDの代替ドメイン名に今回のドメインを同時に設定しておくことができなかった&lt;/li&gt;&#xA;&lt;li&gt;以下の公式で紹介されている通り、ワイルドカードを使用する方法を採用したかったが、親ドメインの管理権限が自分たちになかったため、仕方なしに、旧の代替ドメイン名を一旦空にしてから、新の代替ドメイン名を設定するようにした。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/AmazonCloudFront/latest/DeveloperGuide/alternate-domain-names-move.html&#34;&gt;代替ドメイン名を別のディストリビューションに移動する - Amazon CloudFront&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;この方法では、一時的に証明書エラー(HTTPS接続エラー)が発生することに注意は必要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ちなみにこの代替ドメイン名は、ACM証明書の認証に使用されているらしい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;acm認証用cnameレコードを登録するゾーンについて&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/dns/#acm%e8%aa%8d%e8%a8%bc%e7%94%a8cname%e3%83%ac%e3%82%b3%e3%83%bc%e3%83%89%e3%82%92%e7%99%bb%e9%8c%b2%e3%81%99%e3%82%8b%e3%82%be%e3%83%bc%e3%83%b3%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6&#34;&gt;ACM認証用CNAMEレコードを登録するゾーンについて&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ACMで発行した証明書のDV認証にはCNAMEレコードの登録が必要になる。&lt;br&gt;&#xA;その際に、Route53のどのホストゾーン(親？子？)にCNAMEレコードを登録すべきかという件について、ちょっと調べた。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;結論：移譲されている子のホストゾーンに登録する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ちなみに移譲元である親のホストゾーンに登録しても認証は通らない(digコマンドとかでCNAMEレコードの名前解決がそもそもできない)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;そもそもDV認証というのは「該当ドメインの所有者であるか？」の確認するための目的で、ACM証明書作成時に発行されるCNAMEレコードをそのドメインに登録させるという手段を取っている&lt;/li&gt;&#xA;&lt;li&gt;そしてこの認証が&lt;strong&gt;対象ドメインのDNSゾーン&lt;/strong&gt;に対して行われるため、権限を移譲してしまっている親ドメインでは認証が通らないためと思われる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;対象ドメイン名のネームサーバーを問い合わせる→指定されたCNAMEレコードがそのドメインのDNSに存在するかを定期的に確認している&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;結局、AレコードやCNAMEレコード等のレコード種別に関係なく、ネームサーバーを辿っていき、対象ドメインのDNSゾーンの何らかのレコードを解決するという方法になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;そもそもdnsゾーンとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/dns/#%e3%81%9d%e3%82%82%e3%81%9d%e3%82%82dns%e3%82%be%e3%83%bc%e3%83%b3%e3%81%a8%e3%81%af&#34;&gt;そもそもDNSゾーンとは？&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;あるドメインに関連するDNSレコードを管理するための領域(namespace)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>HTTPS</title>
      <link>http://localhost:1313/posts/https/</link>
      <pubDate>Wed, 23 Oct 2024 23:12:52 +0900</pubDate>
      <guid>http://localhost:1313/posts/https/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ssl証明書の種類&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/https/#ssl%e8%a8%bc%e6%98%8e%e6%9b%b8%e3%81%ae%e7%a8%ae%e9%a1%9e&#34;&gt;SSL証明書の種類&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ドメイン認証(DV)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CAが申請者がドメイン管理者であることのみを確認する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ACMでのCNAMEレコードを用いた認証はこれに該当する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;組織認証(OV)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CAは合法的な存在であることを確認する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;拡張検証(EV)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CAは厳格な検証プロセスを通じて組織を確認する&lt;/li&gt;&#xA;&lt;li&gt;ブラウザのアドレスバーが緑色になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>ubuntu server(EC2)のデフォルトシェルをdashからbashに変更する</title>
      <link>http://localhost:1313/posts/ubuntu-dash-to-bash/</link>
      <pubDate>Mon, 07 Oct 2024 22:09:49 +0900</pubDate>
      <guid>http://localhost:1313/posts/ubuntu-dash-to-bash/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;変更方法&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/ubuntu-dash-to-bash/#%e5%a4%89%e6%9b%b4%e6%96%b9%e6%b3%95&#34;&gt;変更方法&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;以下の**設定変更可能なシェルのプロファイルを有効化する(コンソール)**の方法で変更できた。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://repost.aws/ja/knowledge-center/ssm-session-manager-change-shell&#34;&gt;https://repost.aws/ja/knowledge-center/ssm-session-manager-change-shell&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>LambdaのログをS3に保存する.md</title>
      <link>http://localhost:1313/posts/transfer-log-to-s3/</link>
      <pubDate>Fri, 04 Oct 2024 22:32:31 +0900</pubDate>
      <guid>http://localhost:1313/posts/transfer-log-to-s3/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;概要&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/transfer-log-to-s3/#%e6%a6%82%e8%a6%81&#34;&gt;概要&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Webhookを受け付けるAWS Lambda関数で出力するログをS3に保存(転送)したい&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;目的と要件&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/transfer-log-to-s3/#%e7%9b%ae%e7%9a%84%e3%81%a8%e8%a6%81%e4%bb%b6&#34;&gt;目的と要件&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ログを永続化し、簡易分析したい&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分析時はなるべく手をかけずにログを取得したい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;実装工数をあまりかけたくない(一時的に必要な機能であるため)&lt;/li&gt;&#xA;&lt;li&gt;コストを安く抑えたい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;実現方法&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/transfer-log-to-s3/#%e5%ae%9f%e7%8f%be%e6%96%b9%e6%b3%95&#34;&gt;実現方法&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;cloudwatch-logsからs3にエクスポート&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/transfer-log-to-s3/#cloudwatch-logs%e3%81%8b%e3%82%89s3%e3%81%ab%e3%82%a8%e3%82%af%e3%82%b9%e3%83%9d%e3%83%bc%e3%83%88&#34;&gt;CloudWatch LogsからS3にエクスポート&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWSマネージドコンソールのCloudWatch　Logsのアクションメニューからログデータのエクスポートを選択する&lt;/li&gt;&#xA;&lt;li&gt;対象日時等でフィルターをかけた上で指定するS3バケットにログファイルを出力する&lt;/li&gt;&#xA;&lt;li&gt;フィルター条件や対象範囲にカスタマイズ性を持たせたい場合は有効そう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;cloudwatch-logsからs3にエクスポート自動実行&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/transfer-log-to-s3/#cloudwatch-logs%e3%81%8b%e3%82%89s3%e3%81%ab%e3%82%a8%e3%82%af%e3%82%b9%e3%83%9d%e3%83%bc%e3%83%88%e8%87%aa%e5%8b%95%e5%ae%9f%e8%a1%8c&#34;&gt;CloudWatch LogsからS3にエクスポート(自動実行)&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;上記の一連の流れをEventBridge Schedulerで自動実行させる&lt;/li&gt;&#xA;&lt;li&gt;手順がとても簡単そう&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zenn.dev/fy0323/articles/0c2b5b556d5a0a&#34;&gt;CloudWatch LogsをS3に転送するためにEventBridge Schedulerを使用する&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;今回の安く簡単にという要件に最もマッチしそう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;lambda関数からリアルタイムにログをs3に転送&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/transfer-log-to-s3/#lambda%e9%96%a2%e6%95%b0%e3%81%8b%e3%82%89%e3%83%aa%e3%82%a2%e3%83%ab%e3%82%bf%e3%82%a4%e3%83%a0%e3%81%ab%e3%83%ad%e3%82%b0%e3%82%92s3%e3%81%ab%e8%bb%a2%e9%80%81&#34;&gt;Lambda関数からリアルタイムにログをS3に転送&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Lambda関数の処理の中でログの出力先(保存先)をS3に保存する&lt;/li&gt;&#xA;&lt;li&gt;プログラム内でAWS SDKを使ってPutObjectメソッドを実行するイメージ&lt;/li&gt;&#xA;&lt;li&gt;Lambdaでリクエストを受け付ける度にS3アクセスが発生するため、レイテンシが懸念になる&lt;/li&gt;&#xA;&lt;li&gt;ログ毎にファイル生成するのでは検索性が悪いので、1つのファイルに蓄積させる方法は(？)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ちょっと調べたが、GetObjectした後に更新したコンテントを新たにPutObjectするしかなさそう..？&lt;/li&gt;&#xA;&lt;li&gt;S3はオブジェクトストレージなので、ファイルに追記とかはできなそう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Lambdaのみで処理が完結するのはメリット(?)ではあるが、上記の懸念があるためあまり有効な選択肢にはならなそう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;その他&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/transfer-log-to-s3/#%e3%81%9d%e3%81%ae%e4%bb%96&#34;&gt;その他&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CloudWatchLogsのサブスクリプションフィルターにて、KinesisDataFirehoseを指定し、KinesisDataFirehose側ではターゲットとなるS3を指定するKinesis Data Firehoseを使用してログをストリームさせる方法もあるっぽい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/transfer-log-to-s3/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://qiita.com/Regryp/items/031141f8930c94378d5f&#34;&gt;CloudWatchLogsのログをS3に転送する方法の比較 #AWS - Qiita&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Language Server Protocol(LSP)</title>
      <link>http://localhost:1313/posts/lsp/</link>
      <pubDate>Fri, 04 Oct 2024 22:32:31 +0900</pubDate>
      <guid>http://localhost:1313/posts/lsp/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/lsp/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;職場の方が語っていたので興味本位で調べてみる。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;language-server-protocollspとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/lsp/#language-server-protocollsp%e3%81%a8%e3%81%af&#34;&gt;Language Server Protocol(LSP)とは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;テキストエディタやIDE（統合開発環境）とプログラミング言語のサーバー（言語サーバー）との間で通信を行うためのプロトコルのこと&lt;/li&gt;&#xA;&lt;li&gt;コード補完やシンタックスハイライト等の機能提供してくれる&lt;/li&gt;&#xA;&lt;li&gt;Microsoftが提唱した&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;lspの必要性&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/lsp/#lsp%e3%81%ae%e5%bf%85%e8%a6%81%e6%80%a7&#34;&gt;LSPの必要性&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;エディタに関係なく一貫した開発体験を得られる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;言語ごとに専用のプラグインやサポートを作成するのは手間がかかる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;技術的な構成&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/lsp/#%e6%8a%80%e8%a1%93%e7%9a%84%e3%81%aa%e6%a7%8b%e6%88%90&#34;&gt;技術的な構成&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;エディタやIDEと言語サーバーがLSPを通じて通信する&lt;/li&gt;&#xA;&lt;li&gt;言語サーバー&#xA;&lt;ul&gt;&#xA;&lt;li&gt;実体はプログラミング言語環境&lt;/li&gt;&#xA;&lt;li&gt;VSCodeではGoという拡張機能をインストールするとgoplsというGoの言語サーバーがローカルにインストールされるっぽい(?)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;vscode--goだと&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/lsp/#vscode--go%e3%81%a0%e3%81%a8&#34;&gt;VSCode + Goだと..？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Goの言語サーバーの実装がgoplsである&lt;/li&gt;&#xA;&lt;li&gt;VSCodeのsettings.jsonの&lt;code&gt;&amp;quot;go.useLanguageServer&amp;quot;: true&lt;/code&gt;でLSP設定をONにできる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>NewRelic</title>
      <link>http://localhost:1313/posts/newrelic/</link>
      <pubDate>Fri, 04 Oct 2024 22:32:31 +0900</pubDate>
      <guid>http://localhost:1313/posts/newrelic/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/newrelic/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;業務でNewRelicを使用しているが基礎的な部分も含めてあまりわかっていないので調べる&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;進め方&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/newrelic/#%e9%80%b2%e3%82%81%e6%96%b9&#34;&gt;進め方&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;とりあえずNewRelicドキュメントを眺める&lt;br&gt;&#xA;&lt;a href=&#34;https://docs.newrelic.com/jp/&#34;&gt;New Relic Documentation&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;newrelicを使い始める&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/newrelic/#newrelic%e3%82%92%e4%bd%bf%e3%81%84%e5%a7%8b%e3%82%81%e3%82%8b&#34;&gt;NewRelicを使い始める&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.newrelic.com/jp/docs/new-relic-solutions/get-started/intro-new-relic/#how-it-works&#34;&gt;New Relicを使い始める | New Relic Documentation&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;用語の定義&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/newrelic/#%e7%94%a8%e8%aa%9e%e3%81%ae%e5%ae%9a%e7%be%a9&#34;&gt;用語の定義&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;NewRelic One: 管理画面&lt;/li&gt;&#xA;&lt;li&gt;テレメトリデータ：パフォーマンスデータ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;機能群&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/newrelic/#%e6%a9%9f%e8%83%bd%e7%be%a4&#34;&gt;機能群&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アラート&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アプリケーション異常発生時にSlack等に通知する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;APM&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アプリケーションパフォーマンス監視のこと&lt;/li&gt;&#xA;&lt;li&gt;アプリケーションにエージェントを導入し、NewRelicデータベースに保存する&lt;/li&gt;&#xA;&lt;li&gt;様々な種類のデータを収集・監視できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ブラウザ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ウェブサイトのパフォーマンスを監視する&lt;/li&gt;&#xA;&lt;li&gt;具体的には、ページロードタイムやJavaScriptエラー、ユーザーインタラクションの追跡&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ブラウザ側でのユーザーアクションやランタイムエラー、性能が監視できるという理解&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ダッシュボード&#xA;&lt;ul&gt;&#xA;&lt;li&gt;運用者側でデータを好きなように整理できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;エラーインボックス&#xA;&lt;ul&gt;&#xA;&lt;li&gt;エラー追跡ソリューション&#xA;&lt;ul&gt;&#xA;&lt;li&gt;あまりわかっていないが、エラーの種類ごとにエラーカウントを出してくれたりする？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;インフラストラクチャモニタリング&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンテナ等のクラウドインフラのCPUやメモリ、ネットワークトラフィック、ディスク使用量をカバーする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ログ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ログプロバイダーからログを転送する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;OpenTelemetry&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アプリケーションやホストからデータを収集し、NewRelicに送信する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;データのクエリ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;NRQL(NewRelicクエリ言語)で詳細な条件でデータを収できる&lt;/li&gt;&#xA;&lt;li&gt;SQLに似ている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サービスレベル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アプリケーションのサービスレベル指標(SLI)と目標(SLO)を設定して測定できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;合成のモニタリング(Synthetics)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;　外形監視機能&lt;/li&gt;&#xA;&lt;li&gt;ユーザーがフロントエンドのアプリやサービスをどのように使用するかをシュミレートできる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;脆弱性管理(Vulnerability)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ソフトウェアの脆弱性を管理する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;チュートリアル&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/newrelic/#%e3%83%81%e3%83%a5%e3%83%bc%e3%83%88%e3%83%aa%e3%82%a2%e3%83%ab&#34;&gt;チュートリアル&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;アラートの作成と管理&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/newrelic/#%e3%82%a2%e3%83%a9%e3%83%bc%e3%83%88%e3%81%ae%e4%bd%9c%e6%88%90%e3%81%a8%e7%ae%a1%e7%90%86&#34;&gt;アラートの作成と管理&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Incidents: 条件閾値に違反するイベント&lt;/li&gt;&#xA;&lt;li&gt;Issues: 通知の送信の原因となる1つ以上のインシデントの集合&#xA;&lt;ul&gt;&#xA;&lt;li&gt;この2つの違いがあまりわからない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;アラートを管理するためには、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通知方法をPoliciesとして設定する&lt;/li&gt;&#xA;&lt;li&gt;通知条件をConditionsとして設定する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えば、ALBが5xx系のエラーが全体の80%を超えたら、設定済みPoliciesにある「SLack通知する」みたいな条件を作っていく&lt;/li&gt;&#xA;&lt;li&gt;条件自体は、NRQLでクエリを書く形になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;どのようにnewrelicを活用するか&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/newrelic/#%e3%81%a9%e3%81%ae%e3%82%88%e3%81%86%e3%81%abnewrelic%e3%82%92%e6%b4%bb%e7%94%a8%e3%81%99%e3%82%8b%e3%81%8b&#34;&gt;どのようにNewRelicを活用するか&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;どのようにデータを転送するか&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/newrelic/#%e3%81%a9%e3%81%ae%e3%82%88%e3%81%86%e3%81%ab%e3%83%87%e3%83%bc%e3%82%bf%e3%82%92%e8%bb%a2%e9%80%81%e3%81%99%e3%82%8b%e3%81%8b&#34;&gt;どのようにデータを転送するか&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;newrelicを見る時のポイント&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/newrelic/#newrelic%e3%82%92%e8%a6%8b%e3%82%8b%e6%99%82%e3%81%ae%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88&#34;&gt;NewRelicを見る時のポイント&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;</description>
    </item>
    <item>
      <title>UUIDやULID</title>
      <link>http://localhost:1313/posts/uuid-ulid/</link>
      <pubDate>Fri, 04 Oct 2024 22:32:31 +0900</pubDate>
      <guid>http://localhost:1313/posts/uuid-ulid/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;概要&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/uuid-ulid/#%e6%a6%82%e8%a6%81&#34;&gt;概要&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;データベース設計において、AutoIncrementな純粋な番号(連番)の他にUUIDやULIDがあるけど、それらの違いと結局どれ使えば良いのかという話。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;連番の欠点&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/uuid-ulid/#%e9%80%a3%e7%95%aa%e3%81%ae%e6%ac%a0%e7%82%b9&#34;&gt;連番の欠点&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;まず最初に脳死で設計する時に選択肢となる連番の欠点について理解してみる。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リソースの特定の容易になる&lt;/li&gt;&#xA;&lt;li&gt;システム規模(会員数)が推測されやすい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;この辺りが挙げられる。セキュリティ面(悪意あるユーザーに攻撃される)以外においても、競合他社から容易にシステムのことを推測されやすくなり、優位にビジネスを進められてしまうみたいなこともあるかもしれない。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;uuid&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/uuid-ulid/#uuid&#34;&gt;UUID&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;UUIDとは何か？特徴を列挙する。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Universally Unique Identifier&lt;/li&gt;&#xA;&lt;li&gt;128bit&lt;/li&gt;&#xA;&lt;li&gt;複数のバージョンが存在する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;v4: 全てのビットをランダム値にする（生成が簡単で、一意性が高い）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;128ビットのうち、特定の4ビット（バージョンフィールド）を0100に設定する&lt;/li&gt;&#xA;&lt;li&gt;次に、特定の2ビット（バリアントフィールド）を10に設定する（これにより、UUIDがRFC 4122に準拠していることを示す）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;v7: v4をソート可能にしたもの&#xA;&lt;ul&gt;&#xA;&lt;li&gt;現在のタイムスタンプをミリ秒単位で取得し、48ビットのビット列に変換する&lt;/li&gt;&#xA;&lt;li&gt;残りの80ビットを暗号学的に安全な乱数で埋める&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ulid&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/uuid-ulid/#ulid&#34;&gt;ULID&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;続いて、ULIDとは何か？特徴を列挙する。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Universally Unique Lexicographically Sortable Identifier&lt;/li&gt;&#xA;&lt;li&gt;UUIDの欠点を補う形で設計された一意識別子&lt;/li&gt;&#xA;&lt;li&gt;時系列順にソート可能で、データの管理や検索が容易&lt;/li&gt;&#xA;&lt;li&gt;UUIDと比べて短く、URLなどで使用する際に便利&lt;/li&gt;&#xA;&lt;li&gt;生成方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;タイムスタンプの取得：現在のタイムスタンプをミリ秒単位で取得し、48ビットのビット列に変換&lt;/li&gt;&#xA;&lt;li&gt;残りの80ビットをランダムな値で埋める&lt;/li&gt;&#xA;&lt;li&gt;生成されたビット列をCrockford&amp;rsquo;s Base32でエンコード&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;uuid-v7とulidの違い&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/uuid-ulid/#uuid-v7%e3%81%a8ulid%e3%81%ae%e9%81%95%e3%81%84&#34;&gt;UUID v7とULIDの違い&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;UUID v7とULIDの違いをまとめる。基本的にはULIDの方が優れているように感じる。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;文字数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;UUIDv7：ハイフンを含む36字&lt;/li&gt;&#xA;&lt;li&gt;ULID：特殊文字を含まない26文字&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ランダム部&#xA;&lt;ul&gt;&#xA;&lt;li&gt;UUIDv7：12bit + 62bit&lt;/li&gt;&#xA;&lt;li&gt;ULID：80bit&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;特殊文字の使用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;UUIDv7：ハイフンを含む&lt;/li&gt;&#xA;&lt;li&gt;ULID：特殊文字を含まない）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;uuidやulidの欠点&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/uuid-ulid/#uuid%e3%82%84ulid%e3%81%ae%e6%ac%a0%e7%82%b9&#34;&gt;UUIDやULIDの欠点&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;連番より優れていそうなUUIDやULIDだが、以下のような欠点もある。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;インデックスには不都合があり、クエリパフォーマンスが低下する&lt;/li&gt;&#xA;&lt;li&gt;UUID v4はソートができない&lt;/li&gt;&#xA;&lt;li&gt;UUID v7とULIDは生成時間が漏洩するリスクがある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;クエリパフォーマンスが低下するについて深堀りする&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/uuid-ulid/#%e3%82%af%e3%82%a8%e3%83%aa%e3%83%91%e3%83%95%e3%82%a9%e3%83%bc%e3%83%9e%e3%83%b3%e3%82%b9%e3%81%8c%e4%bd%8e%e4%b8%8b%e3%81%99%e3%82%8b%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6%e6%b7%b1%e5%a0%80%e3%82%8a%e3%81%99%e3%82%8b&#34;&gt;クエリパフォーマンスが低下するについて深堀りする&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;「インデックスには不都合があり、クエリパフォーマンスが低下する」というだけでは納得できないので、ちょっと深堀りしてみる。&lt;/p&gt;&#xA;&lt;p&gt;MySQL(InnoDB)の話になるが、主キーのインデックスとしてクラスタインデックスがある。&lt;br&gt;&#xA;これはキーの値を比較した順序が近いほど物理的に近接した場所にレコードのデータが配置されるため、連番の場合は、連続して投入されたデータはディスク上に近い場所にあり、キャッシュの恩恵が受けられる。&lt;br&gt;&#xA;UUID(v4)は、書き込み先がランダムになるので、キャッシュヒットの割合が下がり、パフォーマンスが低下する。&lt;/p&gt;&#xA;&lt;p&gt;一方、UUID v7やULIDは先頭48bitがタイムスタンプであり、クラスタインデックス上でも投入順に隣接して格納される。&lt;/p&gt;&#xA;&lt;p&gt;PostgreSQLは、主キーインデックスとは別の領域にレコードデータが保存されるため、このような制約がない。何なら標準でUUID型も用意されている。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;結論&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/uuid-ulid/#%e7%b5%90%e8%ab%96&#34;&gt;結論&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;結論としては、その時のケースによって使い分ければ良いのかなと思う。&lt;br&gt;&#xA;完全な個人的な意見ではあるが、ユーザーに露出するデータはUUID v7 or ULIDにして、それ以外は連番で良いのかなと思った。&lt;br&gt;&#xA;UUID v4はあえて使うシーンはなさそうかなという印象。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/uuid-ulid/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zenn.dev/kazu1/articles/e8a668d1d27d6b&#34;&gt;UUIDとULIDを理解していない方は見た方がいい記事&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/UUID&#34;&gt;UUID - Wikipedia&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>システムリプレイス</title>
      <link>http://localhost:1313/posts/system-replace/</link>
      <pubDate>Fri, 04 Oct 2024 22:32:31 +0900</pubDate>
      <guid>http://localhost:1313/posts/system-replace/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/system-replace/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;あるtoCサービスのリプレイスの話&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;システム構成&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/system-replace/#%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e6%a7%8b%e6%88%90&#34;&gt;システム構成&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;フロントエンド: HTML/JavaScript&#xA;&lt;ul&gt;&#xA;&lt;li&gt;S3に静的ホスティング&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;バックエンド: TypeScript/Fastify&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ECS on Fargate&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;データベース: RDS&lt;/li&gt;&#xA;&lt;li&gt;キャッシュ: CloudFront&lt;/li&gt;&#xA;&lt;li&gt;Firewall: AWS WAF&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;リプレイスの概要&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/system-replace/#%e3%83%aa%e3%83%97%e3%83%ac%e3%82%a4%e3%82%b9%e3%81%ae%e6%a6%82%e8%a6%81&#34;&gt;リプレイスの概要&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;現在稼働しているシステムの運用会社の変更に伴うリプレイス&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AWSアカウント自体も変更になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サービス自体は、別の外部サービスへの送客するだけの小さいサービス&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;進め方&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/system-replace/#%e9%80%b2%e3%82%81%e6%96%b9&#34;&gt;進め方&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;(事前)新環境の開発&amp;amp;デプロイ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;非公開状態&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;現環境をメンテナンスモード&#xA;&lt;ul&gt;&#xA;&lt;li&gt;誤って旧環境でデータ作成等が行われないようにする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;現環境→新環境にデータ移行&#xA;&lt;ul&gt;&#xA;&lt;li&gt;事前にデータ移行用のバッチを作成&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;新環境の動作が問題ないかをテスト&#xA;&lt;ul&gt;&#xA;&lt;li&gt;社内ネットワークのみに公開する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;新環境のIP制限を解除し、外部に公開&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;勉強になったポイント&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/system-replace/#%e5%8b%89%e5%bc%b7%e3%81%ab%e3%81%aa%e3%81%a3%e3%81%9f%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88&#34;&gt;勉強になったポイント&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;データ移行バッチで扱うデータ量が多く、移行時にAWSマネージドサービスを使用する場合は、スロットリング制限を考慮して実装を行う&#xA;&lt;ul&gt;&#xA;&lt;li&gt;今回はAWS KMSを使用して一部データを暗号化していたので、何も考えずに実装したらスロットリング制限に引っかかってしまった&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;データ移行前に、現環境はメンテナンスモードにする&#xA;&lt;ul&gt;&#xA;&lt;li&gt;万が一、データ移行中等に現環境の方にデータが作成されてしまったら、移行対象外となり、障害発生の可能性がある&lt;/li&gt;&#xA;&lt;li&gt;メンテナンスモードに切り替える際にCloud Frontのオリジンを変更する場合は、キャッシュ保持期間に気を付ける&#xA;&lt;ul&gt;&#xA;&lt;li&gt;キャッシュのInvalidateを行わないと、普通のページにアクセスできてしまう恐れがある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;(新環境リリース後)現環境メンテナンスモード内に配置するリンク等は新環境のものにしておく&#xA;&lt;ul&gt;&#xA;&lt;li&gt;オートリダイレクトにするのもあり&#xA;&lt;ul&gt;&#xA;&lt;li&gt;HTMLならmeta refreshでできる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;refresh&amp;quot; content=&amp;quot;リダイレクトするまでの秒数; URL=新URL&amp;quot;&amp;gt;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;APIなら、HeaderのLocationフィールドに新URLをセットして30x系のリダイレクトのHTTPステータスコードを返す&lt;/li&gt;&#xA;&lt;li&gt;JavaScriptを使用するのも可能だが、SEO的に微妙らしい&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>リダイレクトについて</title>
      <link>http://localhost:1313/posts/redirect/</link>
      <pubDate>Fri, 04 Oct 2024 22:32:31 +0900</pubDate>
      <guid>http://localhost:1313/posts/redirect/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/redirect/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;リダイレクト3xx系のHTTPステータスコードについて調べた。&#xA;歴史的背景とかが絡んで、仕様と実態の乖離等が発生し、わかりづらいものになっているらしいので整理。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;301-moved-permanently&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/redirect/#301-moved-permanently&#34;&gt;301 Moved Permanently&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リクエストされたリソースが&lt;strong&gt;完全&lt;/strong&gt;にHTTPヘッダーのLocationで示されたURLに移動したことを示す&lt;/li&gt;&#xA;&lt;li&gt;ブラウザはこのURLにリダイレクトするが、検索エンジンはリソースへのリンクを更新&lt;strong&gt;する&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;一部の古いクライアントでは、不正にメソッドがGETに書き換えられる恐れがあるので、GETリクエストのみで使用する&lt;/li&gt;&#xA;&lt;li&gt;SEO的には最も優れている？&lt;/li&gt;&#xA;&lt;li&gt;参考: &lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/HTTP/Status/301&#34;&gt;301 Moved Permanently - HTTP | MDN&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;302-found&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/redirect/#302-found&#34;&gt;302 Found&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リクエストされたリソースが&lt;strong&gt;一時的&lt;/strong&gt;にHTTPヘッダーのLocationで示されたURLに移動したことを示す&lt;/li&gt;&#xA;&lt;li&gt;ブラウザはこのURLにリダイレクトするが、検索エンジンはリソースへのリンクを更新&lt;strong&gt;しない&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;一部の古いクライアントでは、不正にメソッドがGETに書き換えられる恐れがあるので、GETリクエストのみで使用する&lt;/li&gt;&#xA;&lt;li&gt;参考: &lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/HTTP/Status/302&#34;&gt;302 Found - HTTP | MDN&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;303-see-other&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/redirect/#303-see-other&#34;&gt;303 See Other&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リダイレクトが新しくアップロードされたリソースではなく、 (確認ページやアップロード進捗ページのような) 別なページにリンクすることを示す&lt;/li&gt;&#xA;&lt;li&gt;PUTやPOSTの結果として送り返される&lt;/li&gt;&#xA;&lt;li&gt;リダイレクト先の表示にはGETを使用する&lt;/li&gt;&#xA;&lt;li&gt;参考: &lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/HTTP/Status/303&#34;&gt;303 See Other - HTTP | MDN&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;307-temporary-redirect&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/redirect/#307-temporary-redirect&#34;&gt;307 Temporary Redirect&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リクエストされたリソースが&lt;strong&gt;一時的&lt;/strong&gt;にHTTPヘッダーのLocationで示されたURLに移動したことを示す&lt;/li&gt;&#xA;&lt;li&gt;リクエストメソッドと本文が変更されないことが保証される&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用されるメソッドをGETに変更したい場合は303を使用する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;参考: &lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/HTTP/Status/307&#34;&gt;307 Temporary Redirect - HTTP | MDN&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;308-permanent-redirect&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/redirect/#308-permanent-redirect&#34;&gt;308 Permanent Redirect&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リクエストされたリソースが&lt;strong&gt;完全&lt;/strong&gt;にHTTPヘッダーのLocationで示されたURLに移動したことを示す(301と同じ)&lt;/li&gt;&#xA;&lt;li&gt;リクエストメソッドと本文が変更されないことが保証される&lt;/li&gt;&#xA;&lt;li&gt;参考: &lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/HTTP/Status/308&#34;&gt;308 Permanent Redirect - HTTP | MDN&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ステータスコード別のユースケース&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/redirect/#%e3%82%b9%e3%83%86%e3%83%bc%e3%82%bf%e3%82%b9%e3%82%b3%e3%83%bc%e3%83%89%e5%88%a5%e3%81%ae%e3%83%a6%e3%83%bc%e3%82%b9%e3%82%b1%e3%83%bc%e3%82%b9&#34;&gt;ステータスコード別のユースケース&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ではどれを使えば良いのかというのを調べてみる&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;301-moved-permanently-1&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/redirect/#301-moved-permanently-1&#34;&gt;301 Moved Permanently&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サイトの移動&lt;/li&gt;&#xA;&lt;li&gt;GETリクエストを維持したい&lt;/li&gt;&#xA;&lt;li&gt;ex: コーポレートサイトのドメイン変更等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;302found&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/redirect/#302found&#34;&gt;302　Found&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一時的なページを表示する&lt;/li&gt;&#xA;&lt;li&gt;GETリクエストを維持したい&lt;/li&gt;&#xA;&lt;li&gt;ex: メンテナンスページを一時的に表示したい時等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;303-see-other-1&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/redirect/#303-see-other-1&#34;&gt;303 See Other&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一時的なページを表示する&lt;/li&gt;&#xA;&lt;li&gt;GET以外のリクエストを受け付けて、GETでリダイレクトさせる&lt;/li&gt;&#xA;&lt;li&gt;ex: POSTやPUTメソッドでフォーム送信やファイルアップロードを行い、その確認ページを表示したい時等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;307-temporary-redirect-1&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/redirect/#307-temporary-redirect-1&#34;&gt;307 Temporary Redirect&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一時的なリダイレクト処理&lt;/li&gt;&#xA;&lt;li&gt;GETメソッド以外で、そのメソッドを引き継ぎたい時&lt;/li&gt;&#xA;&lt;li&gt;ex: POSTメソッドで受け付けるAPIが一時的に別のAPIにPOSTメソッドでリダイレクトしたい場合&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;308-permanent-redirect-1&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/redirect/#308-permanent-redirect-1&#34;&gt;308 Permanent Redirect&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;恒久的なリダイレクト処理&lt;/li&gt;&#xA;&lt;li&gt;GETメソッド以外で、そのメソッドを引き継ぎたい時&lt;/li&gt;&#xA;&lt;li&gt;ex: POSTメソッドで受け付けるAPIが恒久的に別のAPIにPOSTメソッドでリダイレクトしたい場合&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;リダイレクト手法&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/redirect/#%e3%83%aa%e3%83%80%e3%82%a4%e3%83%ac%e3%82%af%e3%83%88%e6%89%8b%e6%b3%95&#34;&gt;リダイレクト手法&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;サーバー側でステータスコードとLocationヘッダーを設定する&lt;/li&gt;&#xA;&lt;li&gt;meta refreshを設置する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;refresh&amp;quot; content=&amp;quot;秒数;URL=URL&amp;quot;&amp;gt;&lt;/code&gt;というような書き方で実現可能&lt;/li&gt;&#xA;&lt;li&gt;よく「10秒後に移動します」みたいなサイトがあると思うが、多分この方法でリダイレクトさせているのではと思う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;JavaScriptで実装する(window.location.hrefなど)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ただしこれだとSEO観点で検索エンジンがURL変更を認識できず宜しくないらしい&#xA;&lt;ul&gt;&#xA;&lt;li&gt;canonicalタグで代替可能か？(&lt;code&gt;&amp;lt;meta&amp;gt;&amp;lt;link ref=&amp;quot;canonical&amp;quot; href=&amp;quot;new_url&amp;quot; /&amp;gt;...&amp;lt;/meta&amp;gt;&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;所感&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/redirect/#%e6%89%80%e6%84%9f&#34;&gt;所感&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;これまではtoBサービスを開発することが多かったので、SEOとかあまり気にしていなかったけど、toCサービスだとSEO観点も含めて実現方法を検討する必要があるんだと感じた。APIなら301リダイレクトで、静的なHTMLならmeta refreshで実装するのが良さそうなのかな。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Environments</title>
      <link>http://localhost:1313/posts/environments/</link>
      <pubDate>Fri, 16 Aug 2024 10:56:56 +0900</pubDate>
      <guid>http://localhost:1313/posts/environments/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;environmentsとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/environments/#environments%e3%81%a8%e3%81%af&#34;&gt;Environmentsとは&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GitHubActionsの機能であり、リポジトリに設定できるもの&lt;/li&gt;&#xA;&lt;li&gt;環境ごとにプロテクションルールや変数、シークレットを保持することができ、環境を指定して、ワークフローを指定することで、必要な権限のみでデプロイを実行できたりする&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.github.com/ja/actions/managing-workflow-runs-and-deployments/managing-deployments/managing-environments-for-deployment&#34;&gt;デプロイに環境の使用 - GitHub Docs&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;使い方&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/environments/#%e4%bd%bf%e3%81%84%e6%96%b9&#34;&gt;使い方&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Environmentsの設定自体はGitHubの管理画面のSettingsから設定が可能&lt;/li&gt;&#xA;&lt;li&gt;ワークフローからはenvironmentフィールドにEnvironmentsの環境名を指定する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ユースケース&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/environments/#%e3%83%a6%e3%83%bc%e3%82%b9%e3%82%b1%e3%83%bc%e3%82%b9&#34;&gt;ユースケース&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;環境ごとに必要な変数やシークレットを使用する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えば環境ごとに適切なAWSのロールを設定することで、セキュリティ性を向上させることができる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/environments/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://dev.classmethod.jp/articles/github-actions-environment-secrets-and-environment-variables/&#34;&gt;[GitHub Actions] ブランチごとにジョブの実行を制御できる Environments を試してみた | DevelopersIO&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Makefile</title>
      <link>http://localhost:1313/posts/makefile/</link>
      <pubDate>Fri, 16 Aug 2024 09:13:56 +0900</pubDate>
      <guid>http://localhost:1313/posts/makefile/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;makefileの基本&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/makefile/#makefile%e3%81%ae%e5%9f%ba%e6%9c%ac&#34;&gt;Makefileの基本&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全てはここに載っている：&lt;a href=&#34;https://www.gnu.org/software/make/manual/make.html&#34;&gt;GNU make&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;GNUというは「グヌー」というらしく、フリーソフトウェア（特に、オープンソースソフトウェア）のみでUNIX風のOSと関連するソフトウェア群を開発・公開するプロジェクト&lt;/li&gt;&#xA;&lt;li&gt;簡単に内容把握する:&lt;a href=&#34;https://zenn.dev/keitean/articles/aaef913b433677&#34;&gt;Makefileの基本&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;細かなtips&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/makefile/#%e7%b4%b0%e3%81%8b%e3%81%aatips&#34;&gt;細かなTips&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;nオプション&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/makefile/#n%e3%82%aa%e3%83%97%e3%82%b7%e3%83%a7%e3%83%b3&#34;&gt;nオプション&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;make -n xxx&lt;/code&gt;で実行されるコマンドを表示する（dry-run）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;phony&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/makefile/#phony&#34;&gt;.PHONY&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ターゲットと同名のファイルが実行ディレクトリ以下に存在していた場合、makeコマンドはターゲットに指定されているコマンドを実行しないというのがデフォルト&lt;/li&gt;&#xA;&lt;li&gt;.PHONYにターゲットを書くことで、ファイルの存在有無関係なく、コマンドを実行してくれる&lt;/li&gt;&#xA;&lt;li&gt;もし仮に同名のファイルが作成されてしまったためにmakeコマンドが実行されなくなってしまう等の問題を避けることを目的としている&lt;/li&gt;&#xA;&lt;li&gt;全てのターゲットは.PHONYに指定するで良さそう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;shell関数&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/makefile/#shell%e9%96%a2%e6%95%b0&#34;&gt;shell関数&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$(shell echo hoge)とかでシェルを実行する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;変数展開&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/makefile/#%e5%a4%89%e6%95%b0%e5%b1%95%e9%96%8b&#34;&gt;変数展開&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;即時展開(:=)と遅延展開(=)の2種類がある（本当はもっとある)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;即時展開(:=)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定義の段階で一度だけ即時で評価される&lt;/li&gt;&#xA;&lt;li&gt;常に結果を固定したい場合や計算コストが高い処理を一度だけ実行し、その値を使い回ししたい場合に使用する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;遅延展開(=)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用される度に右辺を評価される&lt;/li&gt;&#xA;&lt;li&gt;動的な値が必要な場合に使用する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;参考&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://weblog.grimoh.net/entry/2020/06/01/000000&#34;&gt;Makeの変数における代入タイプについて - Howdunnit&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>## オブザーバビリティ</title>
      <link>http://localhost:1313/posts/observerbility/</link>
      <pubDate>Wed, 14 Aug 2024 09:00:11 +0900</pubDate>
      <guid>http://localhost:1313/posts/observerbility/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;オブザーバビリティとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/observerbility/#%e3%82%aa%e3%83%96%e3%82%b6%e3%83%bc%e3%83%90%e3%83%93%e3%83%aa%e3%83%86%e3%82%a3%e3%81%a8%e3%81%af&#34;&gt;オブザーバビリティとは&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;以下の記事が最も腹落ちする説明だった。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://ymotongpoo.hatenablog.com/entry/2019/03/25/084500&#34;&gt;https://ymotongpoo.hatenablog.com/entry/2019/03/25/084500&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>LayerX Go勉強会 20240704</title>
      <link>http://localhost:1313/posts/20240704/</link>
      <pubDate>Fri, 09 Aug 2024 22:37:12 +0900</pubDate>
      <guid>http://localhost:1313/posts/20240704/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;差分テスト&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/20240704/#%e5%b7%ae%e5%88%86%e3%83%86%e3%82%b9%e3%83%88&#34;&gt;差分テスト&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;モノレポ構成でリポジトリが肥大するとテスト時間が長くなって辛いという話&lt;/li&gt;&#xA;&lt;li&gt;CIの中でGitHub CLIを使ってFile Changesを取得&lt;/li&gt;&#xA;&lt;li&gt;差分のあるパッケージを取得し、go testの引数に渡すことで差分があるパッケージのみをテスト対象として、CI実行時間を短縮した&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;aws-cliをラップするaws-slim&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/20240704/#aws-cli%e3%82%92%e3%83%a9%e3%83%83%e3%83%97%e3%81%99%e3%82%8baws-slim&#34;&gt;AWS CLIをラップするaws slim&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;あまり聞けなかったのでコード読む&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>基本情報技術者試験</title>
      <link>http://localhost:1313/posts/fundamental-engineer/</link>
      <pubDate>Wed, 31 Jul 2024 09:55:28 +0900</pubDate>
      <guid>http://localhost:1313/posts/fundamental-engineer/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;エンジニアとしての基礎が足りないと感じる点が多々あり、業務が忙しくないタイミングで勉強&amp;amp;受験してみた。その際の勉強になった点や中々覚えられなかった点をまとめた。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;結果&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e7%b5%90%e6%9e%9c&#34;&gt;結果&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;科目Aが760点、科目Bが650点で無事合格することができた。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;受験日: 2024/7/26&lt;/li&gt;&#xA;&lt;li&gt;勉強期間: 約1ヶ月(1日1~2時間)&lt;/li&gt;&#xA;&lt;li&gt;勉強方法:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;科目A&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://youtu.be/oqaBEnhIxk0?si=r98vsaFMIOgxjGsM&#34;&gt;【2024年】基本情報技術者試験の科目Aを12時間で完璧に理解&lt;/a&gt;を1周&lt;/li&gt;&#xA;&lt;li&gt;令和5,6年の公開問題/令和5年免除試験/令和元年秋過去問を1周した後、不正解問題のみもう1周&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;科目B&#xA;&lt;ul&gt;&#xA;&lt;li&gt;令和5,6年の公開問題の計26問を1周&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;感想&#xA;&lt;ul&gt;&#xA;&lt;li&gt;科目Aの学習の進め方は問題なかったと思う反面、科目Bは間違えた問題の復習くらいはしておいても良かったと思う&lt;/li&gt;&#xA;&lt;li&gt;エンジニア経験が複数年あれば、科目Bにそこまで時間を割く必要はないと思うが、割と早いペースで問題を解く必要があるので、そこは慣れておくと安心感がありそう&lt;/li&gt;&#xA;&lt;li&gt;計算問題に慣れるのが、文系出身の身としては少し辛かった..笑 解き方を習得した後は楽しかった。&lt;/li&gt;&#xA;&lt;li&gt;2進数・ビット・バイト・文字コード・暗号方式など、これまで何回も調べていたもの(毎度頭に残らない系)をガッツリ勉強できたおかげでそれらが身になった感があるのがとても良かった&lt;/li&gt;&#xA;&lt;li&gt;一方で、もう少しエンジニア経験が早い段階で受験しておくのが良かったと感じた&lt;/li&gt;&#xA;&lt;li&gt;業務とはあまり関係のないストラテジ系とかマネジメント系とかの学習にも一定時間割かなければいけない点は微妙であり、基本情報取ったら応用情報も取ってしまおうと思っていたが、応用情報の受験は見送ることにした&#xA;&lt;ul&gt;&#xA;&lt;li&gt;資格試験あるあるだが、どうしても資格取得のための勉強になってしまう点がある..&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;計算系&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e8%a8%88%e7%ae%97%e7%b3%bb&#34;&gt;計算系&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;n進数の計算&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#n%e9%80%b2%e6%95%b0%e3%81%ae%e8%a8%88%e7%ae%97&#34;&gt;n進数の計算&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;10→2&#xA;&lt;ul&gt;&#xA;&lt;li&gt;整数部分:2で割って余りを下から並べる&lt;/li&gt;&#xA;&lt;li&gt;少数部分:2でかけていってかけた結果の整数部分を上から並べる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;10→n:2進数に変換した後に、8なら3桁区切り、16なら4桁区切りで桁の数*桁の重み&lt;/li&gt;&#xA;&lt;li&gt;n→10:桁の数*桁の重みを足し合わせる&lt;/li&gt;&#xA;&lt;li&gt;負数を補数で表現する:ビット反転して+1する&lt;/li&gt;&#xA;&lt;li&gt;算術計算&#xA;&lt;img src=&#34;https://github.com/nyuusen/TIL/assets/56878203/95b14e97-c363-4d5c-9324-8cbd869716f6&#34; alt=&#34;IMG_5851&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;補数&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e8%a3%9c%e6%95%b0&#34;&gt;補数&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;補数は負の数を表すために使用する(引き算)&lt;/li&gt;&#xA;&lt;li&gt;補数には2つの種類がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;10進数でいう所の9の補数と10の補数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;具体的には、100という数字があった場合、9の補数は999-100=899で、10の補数は1000-100=900になる&lt;/li&gt;&#xA;&lt;li&gt;2進数では1の補数と2の補数があり、0011という4桁の2進数があった場合、1の補数は1111-0011=1100(ビット反転のみ)、2の補数は1111-0011+1=1101(ビット反転+1)となる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;固定小数点形式における補数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えば-5.625を8ビット/固定小数点形式(小数点位置は3と4ビット目の間)を2進数で表せという問題を解いてみる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;手順1: 正数として2進数に変換する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;5.625を2進数で表すと0101 1010となる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;手順2: ビット反転し、最下位ビットに1を加える&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ビット反転して1010 0101となり、1ビット目に+1をして1010 0110が答えとなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;注意ポイントとしては、&lt;strong&gt;小数点位置に関係なく、1ビット目を+1とすること&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;パリティチェック&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%83%91%e3%83%aa%e3%83%86%e3%82%a3%e3%83%81%e3%82%a7%e3%83%83%e3%82%af&#34;&gt;パリティチェック&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;データのビット誤りを検出する方法&lt;/li&gt;&#xA;&lt;li&gt;一定長のビット列ごとに1ビットの検査ビット(パリティビット)を付加する&lt;/li&gt;&#xA;&lt;li&gt;パリティビットも含め、1の数が奇数になるようにすることを「奇数パリティ」という&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;論理回路&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e8%ab%96%e7%90%86%e5%9b%9e%e8%b7%af&#34;&gt;論理回路&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;問題を解くコツとしては、&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ベン図をイメージ&lt;/li&gt;&#xA;&lt;li&gt;00 01 10 11が入力された時の値を比較する&lt;/li&gt;&#xA;&lt;li&gt;ドモルガンの法則等を駆使して条件式を簡略化する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;MIL記号の覚え方&#xA;&lt;ul&gt;&#xA;&lt;li&gt;論理積: 丸っこい&lt;/li&gt;&#xA;&lt;li&gt;論理和: ちょっと角張ってる&lt;/li&gt;&#xA;&lt;li&gt;否定: めっちゃ角張ってる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;NAND / NOR / XOR&#xA;&lt;ul&gt;&#xA;&lt;li&gt;NAND: AND以外が1&lt;/li&gt;&#xA;&lt;li&gt;NOR: OR以外が1&lt;/li&gt;&#xA;&lt;li&gt;XOR(EOR): 片方だけが1の場合に1(ひねくれ君)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ドモルガンの法則をわかりやすく理解する&#xA;&lt;img src=&#34;https://github.com/nyuusen/TIL/assets/56878203/6dd3f9ef-8d13-4972-9157-bd67b926f2b8&#34; alt=&#34;スクリーンショット 2024-07-05 11 45 55&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;加算器&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e5%8a%a0%e7%ae%97%e5%99%a8&#34;&gt;加算器&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンピューターが2進数を計算する時の回路の話&lt;/li&gt;&#xA;&lt;li&gt;半加算器と全加算器がある&lt;/li&gt;&#xA;&lt;li&gt;半加算器&#xA;&lt;ul&gt;&#xA;&lt;li&gt;下からの桁上がりに対応できない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;全加算器&#xA;&lt;ul&gt;&#xA;&lt;li&gt;下からの桁上がりに対応できる&lt;/li&gt;&#xA;&lt;li&gt;半加算器を組み合わせてできたもの&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;基本的には2進数を計算して、入力に対しての計算結果を見て、1桁目と2桁目がどうなるかを考えるだけで良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;確率と統計&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e7%a2%ba%e7%8e%87%e3%81%a8%e7%b5%b1%e8%a8%88&#34;&gt;確率と統計&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;正規分布&#xA;&lt;ul&gt;&#xA;&lt;li&gt;平均値を中心に左右対称の山のようなカーブを描く確率分布&lt;/li&gt;&#xA;&lt;li&gt;平均が60,標準偏差が10の正規分布図&#xA;&lt;img src=&#34;https://github.com/user-attachments/assets/69bc7094-1968-4c7b-b81e-b9ce46f5cd7d&#34; alt=&#34;スクリーンショット 2024-07-16 10 06 12&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;相関&#xA;&lt;ul&gt;&#xA;&lt;li&gt;相関係数とは「2種類のデータの関連性」を示すもの&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えば、xが2倍になるとyが2倍になる→正の相関がある&lt;/li&gt;&#xA;&lt;li&gt;相関係数は-1から1の値を取る&lt;/li&gt;&#xA;&lt;li&gt;相関関係がない場合は0になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;順列/組み合わせ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;並べる: 5枚のカードを1列に並べる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;5!=5x4x3x2x1=120通り&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;選ぶだけ: 5枚のカードからランダムに2つ選ぶ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;5C2=5x4/2x1=10通り&lt;/li&gt;&#xA;&lt;li&gt;ChoiceのCと覚える&lt;/li&gt;&#xA;&lt;li&gt;ABとBAは同じに捉えられるのでちょっと少なめになる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;選んで並べる: 5枚のカードから2つ選んで並べる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;5P2=5x4=20通り&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ビット操作とマスクパターン&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%83%93%e3%83%83%e3%83%88%e6%93%8d%e4%bd%9c%e3%81%a8%e3%83%9e%e3%82%b9%e3%82%af%e3%83%91%e3%82%bf%e3%83%bc%e3%83%b3&#34;&gt;ビット操作とマスクパターン&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンピューターが2進数を回路で計算できることはわかったが、引き算をする時に補数を算出するのはどうやってやるの？を解決するのがこのマスクパターン&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全部話がつながってて面白い..！&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ビット反転させる方法(補数の算出方法)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;反転させたいビット位置に1を入れたビット列を用意する&lt;/li&gt;&#xA;&lt;li&gt;上記と対象ビット数字を排他的論理和(ひねくれ君)をとると結果が得られる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;特定のビットを取り出す&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これも同じく取り出したいビット位置に1をを入れたビット列を用意する&lt;/li&gt;&#xA;&lt;li&gt;論理積&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ディジタルデータの表し方&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%83%87%e3%82%a3%e3%82%b8%e3%82%bf%e3%83%ab%e3%83%87%e3%83%bc%e3%82%bf%e3%81%ae%e8%a1%a8%e3%81%97%e6%96%b9&#34;&gt;ディジタルデータの表し方&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アナログデータとは、連続するデータ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アナログ時計は1分ごととかではなく、絶え間なく動き続いている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ディジタルデータとは、とびとびのデータ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一方デジタル時計は1分ごととかで時間表示が変わる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;コンピューターが処理する最小のデータ単位がビットであるが、8ビットを意味する1バイトがよく使われる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;なぜ8ビットなのかというと、Aとかの文字を表すのにちょうど良かったかららしい&lt;/li&gt;&#xA;&lt;li&gt;2進数の8乗なので256のデータを表現できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;文字コード&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e6%96%87%e5%ad%97%e3%82%b3%e3%83%bc%e3%83%89&#34;&gt;文字コード&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンピュータは文字という概念すら知らないため、2進数と文字を対応づけることでコンピュータが文字を表現することができる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;とは言っても、コンピュータは文字をただの図形くらいの認識でしかない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;様々な文字コード&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ASCII&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最も基本的な文字コード。1バイトでアルファベットの大文字小文字といくつかの記号を表現できる。正確には1ビットはパリティ用なので、7ビットで1文字を表現する。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Shift-JIS&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ASCII+日本語で、全角文字は2バイトで表現する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Unicode&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全世界の文字コードを一つに統一するために生まれた文字コード。あらとあらゆる言語の文字を表現できる。当初は2バイトで1文字を表現するつもりだったが、足りるはずもなく、3バイト..4バイトと拡張されていっている。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;EBCDIC&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IBM製。8ビットで文字を表現する。大型のコンピュータとかで使われる。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;EUC&#xA;&lt;ul&gt;&#xA;&lt;li&gt;拡張UNIXコードとも呼ばれる。UNIXでよく使われる日本語文字コード。1バイト〜3バイトで文字を表現する。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;画像&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e7%94%bb%e5%83%8f&#34;&gt;画像&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;画像データはビットマップ方式で表現する&lt;/li&gt;&#xA;&lt;li&gt;ドット数*1ドットあたりの色情報を保持するために必要なビット数で、画像データサイズを算出できる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えば、640*480ドットでフルカラー画像の場合、ドット数は640*480で307200個、フルカラーは24ビット必要なため、これをかけると7372800ビットとなり、8で割ると921600バイトとなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;音声&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e9%9f%b3%e5%a3%b0&#34;&gt;音声&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;音声データはPCM(Pulse Code Modulation)方式で表現する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;音声を一定時間ごとに区切り、その単位ごとの音程を数値化する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;PCM方式でのデータ化の手順&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1.標本化(サンプリング): 一定時間で区切り、その時間ごとの信号レベルを標本として抽出する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;どのような間隔で標本を得るかを示すのが「サンプリング周波数」&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えば音楽CDは、サンプリング周波数44.1kHz(441000Hz)の音声データが格納されており、これは1秒間に441000回標本を得るという意味なのである&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;2.量子化: 信号レベルを何段階で表現するかを定め、サンプリングしたデータをその段階するにあてはめて、整数値に置き換える処理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;標本化は横軸(時間)で、量子化は縦軸(音程)をデジタルデータにしている&lt;/li&gt;&#xA;&lt;li&gt;標本を何ビットのデータで表すかを示す段階数を「量子化ビット数」という&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えば8ビットなら、256段階になる(CDは16ビットなので65536段階)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;3.符号化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;省略&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h4 id=&#34;情報の単位&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e6%83%85%e5%a0%b1%e3%81%ae%e5%8d%98%e4%bd%8d&#34;&gt;情報の単位&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;キロ(10の3乗)→メガ(10の6乗)→ギガ(10の9乗)&lt;/li&gt;&#xA;&lt;li&gt;ミリ(10の-3乗)→マイクロ(10の-6乗)→ナノ(10の-9乗)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1秒=1000ミリ秒=1000000マイクロ秒&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ハードウェア&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%83%8f%e3%83%bc%e3%83%89%e3%82%a6%e3%82%a7%e3%82%a2&#34;&gt;ハードウェア&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;cpu&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#cpu&#34;&gt;CPU&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;性能評価方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クロック周波数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPUはオーケストラのように一定間隔で動作しており、間隔は電圧によって制御されている&lt;/li&gt;&#xA;&lt;li&gt;この電圧自体を制御するのがクロック信号であり、電圧の1つの波をクロック、1秒間あたりのクロック数をクロック周波数という&lt;/li&gt;&#xA;&lt;li&gt;高ければ高いほど性能が良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CPI(Clock cycles Per Instruction)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1命令あたり何クロック必要か&lt;/li&gt;&#xA;&lt;li&gt;1命令で2クロック必要なら、2CPIとなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;MIPS(Million Instructions Per Second)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1秒間で何回命令を実行できるか(百万単位)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;高速化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パイプライン処理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;さらに高速化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;スーパーパイプライン&#xA;&lt;ul&gt;&#xA;&lt;li&gt;もっと細分化&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;スーパースカラ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ユニットを複数個用意して多くの命令を処理する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;メモリ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%83%a1%e3%83%a2%e3%83%aa&#34;&gt;メモリ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;メモリにはRAMとROMがある&lt;/li&gt;&#xA;&lt;li&gt;RAMの種類&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DRAM(Dynamic RAM)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンデンサに電荷を蓄えてビット情報を記憶する&lt;/li&gt;&#xA;&lt;li&gt;コンデンサは放っておくと電荷が抜けるため定期的なリフレッシュが必要&lt;/li&gt;&#xA;&lt;li&gt;コンデンサ/リフレッシュが必要/速度は低速/集積度は高い/価格は安価/主記憶装置として使用される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SRAM&#xA;&lt;ul&gt;&#xA;&lt;li&gt;フリップフロップ回路を用いてビット情報を記憶する&lt;/li&gt;&#xA;&lt;li&gt;フリップフロップ回路/リフレッシュ不要/速度は高速/集積度は低い/価格は高価/キャッシュメモリ(CPUとメモリ間の速度差を埋めるために働くメモリのこと)として使s用される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ROMの種類&#xA;&lt;ul&gt;&#xA;&lt;li&gt;マスクROM&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ROMといったら大体これ&lt;/li&gt;&#xA;&lt;li&gt;製造時にデータを書き込み、以降は書き換えることはできない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;PROM(Programable ROM)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;書き換え可能なROM&lt;/li&gt;&#xA;&lt;li&gt;種類&#xA;&lt;ul&gt;&#xA;&lt;li&gt;EPROM(Erasable PROM)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;紫外線でデータ消去し書き換える&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;EEPROM(Electrically EPROM)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;電気でデータ消去し書き換える&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;フラッシュメモリ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;EEPROMの1種で、ブロック単位でデータ消去し書き換える&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;メモリアクセスの高速化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;メモリインターリーブ：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主記憶領域を論理的な領域(バンク)に分け、読み書きを並列で行う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;DMA&#xA;&lt;ul&gt;&#xA;&lt;li&gt;direct memory access&lt;/li&gt;&#xA;&lt;li&gt;入出力装置とメモリとの間でCPUを介さずに直接データを転送する方式&lt;/li&gt;&#xA;&lt;li&gt;CPUが入出力装置の制御を行わなくても良いため、データ転送中も別の処理が行うことが可能になり、効率化を図れる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;入出力&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e5%85%a5%e5%87%ba%e5%8a%9b&#34;&gt;入出力&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;デイジーチェーン接続&#xA;&lt;ul&gt;&#xA;&lt;li&gt;PCー周辺機器ー周辺機器といった具合でPCを起点にして複数の周辺機器を直列で数珠のように接続する方法&lt;/li&gt;&#xA;&lt;li&gt;パラレル転送規格のSCSIなどで用いられる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ソフトウェア&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%82%bd%e3%83%95%e3%83%88%e3%82%a6%e3%82%a7%e3%82%a2&#34;&gt;ソフトウェア&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;os&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#os&#34;&gt;OS&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リアルタイムOS&#xA;&lt;ul&gt;&#xA;&lt;li&gt;優先度が高いAと低いBがある場合&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Bの実行中にAに起動がかかると、Bを実行可能状態にしてAを実行する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ファイルシステム&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%83%95%e3%82%a1%e3%82%a4%e3%83%ab%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0&#34;&gt;ファイルシステム&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;バックアップ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;フル→差分→増分&lt;/li&gt;&#xA;&lt;li&gt;増分＝incremental backupと英語表現で見てみると、前回から増えた分だけちょこっとバックアップすると覚えられそう？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;スタッシュキュー&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%82%b9%e3%82%bf%e3%83%83%e3%82%b7%e3%83%a5%e3%82%ad%e3%83%a5%e3%83%bc&#34;&gt;スタッシュ/キュー&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;スタッシュ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;スタッシュ問題が出たら、スタッシュとポップを交互に行っても問題ない&#xA;&lt;ul&gt;&#xA;&lt;li&gt;スタッシュしきってから、まとめてポップしなくて良いという意味&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;データベース&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%83%87%e3%83%bc%e3%82%bf%e3%83%99%e3%83%bc%e3%82%b9&#34;&gt;データベース&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;関係モデル&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e9%96%a2%e4%bf%82%e3%83%a2%e3%83%87%e3%83%ab&#34;&gt;関係モデル&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/user-attachments/assets/d2bf1f0b-2c3c-418a-a657-433c26e39d39&#34; alt=&#34;スクリーンショット 2024-07-22 11 14 03&#34;&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;トランザクション&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%83%88%e3%83%a9%e3%83%b3%e3%82%b6%e3%82%af%e3%82%b7%e3%83%a7%e3%83%b3&#34;&gt;トランザクション&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2相ロッキングプロトコル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;トランザクション処理で読み書きが必要になったデータにその都度ロックをかけていき、全てのロックを獲得した後にだけロックの解除を行うルールを課すロック方式&lt;/li&gt;&#xA;&lt;li&gt;つまり、ロックが解除されるのはトランザクションの終了時となる&lt;/li&gt;&#xA;&lt;li&gt;トランザクション内の各処理が終わる度に解除するわけではないので注意&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;デッドロックの回避&#xA;&lt;ul&gt;&#xA;&lt;li&gt;各トランザクションでロックをかける順番を統一する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;実務でも大事&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ユーザーインターフェイス&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%83%a6%e3%83%bc%e3%82%b6%e3%83%bc%e3%82%a4%e3%83%b3%e3%82%bf%e3%83%bc%e3%83%95%e3%82%a7%e3%82%a4%e3%82%b9&#34;&gt;ユーザーインターフェイス&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;uxuiデザイン&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#uxui%e3%83%87%e3%82%b6%e3%82%a4%e3%83%b3&#34;&gt;UX/UIデザイン&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;表意コード&#xA;&lt;ul&gt;&#xA;&lt;li&gt;値から対象のデータが容易に連想できる英数字・記号の組み合わせであるコード&lt;/li&gt;&#xA;&lt;li&gt;桁数が多くなるが、利用者が記憶しやすい利点がある&lt;/li&gt;&#xA;&lt;li&gt;BK:黒, WH:白など&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;区分コード&#xA;&lt;ul&gt;&#xA;&lt;li&gt;グループごとに定められた範囲でコードを割り当てる&lt;/li&gt;&#xA;&lt;li&gt;例: 営業部は1000~1999とか&lt;/li&gt;&#xA;&lt;li&gt;上位コードを見るだけで、どのグループに所属しているかを判別しやすい利点がある&lt;/li&gt;&#xA;&lt;li&gt;ブロックコードともいう&lt;/li&gt;&#xA;&lt;li&gt;エラーコードもこれを使うことが多い気がする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;桁別コード&#xA;&lt;ul&gt;&#xA;&lt;li&gt;各桁に分類状の意味を持たせたコード体系&lt;/li&gt;&#xA;&lt;li&gt;免許証とかがこれに当たる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ネットワーク&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%83%8d%e3%83%83%e3%83%88%e3%83%af%e3%83%bc%e3%82%af&#34;&gt;ネットワーク&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;osi基本参照モデル&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#osi%e5%9f%ba%e6%9c%ac%e5%8f%82%e7%85%a7%e3%83%a2%e3%83%87%e3%83%ab&#34;&gt;OSI基本参照モデル&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1.物理層&#xA;&lt;ul&gt;&#xA;&lt;li&gt;リピータが信号を増幅し、伝送距離を延長する&lt;/li&gt;&#xA;&lt;li&gt;リピータハブが入力信号を全てのLANポートに中継する&lt;/li&gt;&#xA;&lt;li&gt;メディアコンバータが異なる伝送媒体を接続し、信号を相互に変換する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;2.データリンク層&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ブリッジがMACアドレスを基に通信を中継する&lt;/li&gt;&#xA;&lt;li&gt;ハブ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;3.ネットワーク層&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ルーターがIPアドレスを基に通信制御を行う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;4~7&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ゲートウェイ主に3層以上(ゲートウェイ自体は7層全てで接続を行う)でデータ形式やプロトコルの変換を行う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;サブネットマスク&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%82%b5%e3%83%96%e3%83%8d%e3%83%83%e3%83%88%e3%83%9e%e3%82%b9%e3%82%af&#34;&gt;サブネットマスク&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IPアドレスからネットワーク部アドレスとホスト部アドレスを識別する数値&#xA;&lt;ul&gt;&#xA;&lt;li&gt;具体的には、11110000のような形で最初に1が続き、その後に0が続く&lt;/li&gt;&#xA;&lt;li&gt;IPアドレスとサブネットマスク値の論理積を算出することで、ネットワークアドレスを特定することができる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;データ通信制御&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%83%87%e3%83%bc%e3%82%bf%e9%80%9a%e4%bf%a1%e5%88%b6%e5%be%a1&#34;&gt;データ通信/制御&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ポート番号&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プロキシサーバーは代替HTTPポートである8080で待ち受けることが多い&lt;/li&gt;&#xA;&lt;li&gt;サーバーがクライアントに応答する時、サービスを要求してきたクライアントのポート番号を設定する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例えば、クライアントからプロキシの8080宛にリクエストを送ったら、クライアントが設定してきた任意のポート番号宛にレスポンスが返却される&lt;/li&gt;&#xA;&lt;li&gt;プロキシからサーバーに80宛にリクエストを送ったら、プロキシ設定してきた任意のポート番号宛にレスポンスが返却される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;CSMA/CD方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;各ノードが伝送媒体が使用中かを調べ、使用中でなければ送信を行う&lt;/li&gt;&#xA;&lt;li&gt;衝突を検出したら、ランダムな時間経過後に再度送信を行う&lt;/li&gt;&#xA;&lt;li&gt;CD=Collision Detectionなので衝突検出と覚えると良さそう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;データ構造&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%83%87%e3%83%bc%e3%82%bf%e6%a7%8b%e9%80%a0&#34;&gt;データ構造&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;木構造&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e6%9c%a8%e6%a7%8b%e9%80%a0&#34;&gt;木構造&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2分木&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全ての枝の分岐が2つ以下である木構造&lt;/li&gt;&#xA;&lt;li&gt;2分木にもいくつか種類がある&#xA;&lt;ul&gt;&#xA;&lt;li&gt;完全2分木&#xA;&lt;ul&gt;&#xA;&lt;li&gt;根から葉までの深さが全て等しい2分木&lt;/li&gt;&#xA;&lt;li&gt;ただし左部分木に深さ1がはみ出ている場合も例外として完全2分木となる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;2分探索木&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全ての節において、左の子＜親＜右の子という関係を持った2分木&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ヒープ木&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全ての節において、親＜子 or 子＜親 という関係を持った2分木&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;セキュリティ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%82%bb%e3%82%ad%e3%83%a5%e3%83%aa%e3%83%86%e3%82%a3&#34;&gt;セキュリティ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;暗号化&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e6%9a%97%e5%8f%b7%e5%8c%96&#34;&gt;暗号化&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;共通鍵暗号方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;暗号化も復号も共通の鍵を使用する&lt;/li&gt;&#xA;&lt;li&gt;処理速度は速いが、鍵の管理や配送が手間&#xA;&lt;ul&gt;&#xA;&lt;li&gt;相手の数の分だけ鍵が必要になり、それを管理する必要がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;AES, DES, RC4&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;公開鍵暗号方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;受信者が秘密鍵と公開鍵を作成し、送信者は受信者側が作成した公開鍵を用いて暗号化し、受信者は自身の秘密鍵で復号する&lt;/li&gt;&#xA;&lt;li&gt;処理速度は遅いが、鍵の配送が不要&lt;/li&gt;&#xA;&lt;li&gt;RSA, 楕円曲線暗号&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;デジタル署名&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%83%87%e3%82%b8%e3%82%bf%e3%83%ab%e7%bd%b2%e5%90%8d&#34;&gt;デジタル署名&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;デジタル署名の生成と検証手順&#xA;&lt;ul&gt;&#xA;&lt;li&gt;送信者&#xA;&lt;ul&gt;&#xA;&lt;li&gt;メッセージをハッシュ関数にかけてメッセージダイジェスト(ハッシュ値)を取得&lt;/li&gt;&#xA;&lt;li&gt;メッセージダイジェストを&lt;strong&gt;送信者の秘密鍵&lt;/strong&gt;で暗号化してデジタル署名を生成&#xA;&lt;ul&gt;&#xA;&lt;li&gt;公開鍵方式では受信者側が秘密鍵を用意するが、デジタル署名は送信者側が秘密鍵を用意する&lt;/li&gt;&#xA;&lt;li&gt;これはなぜかというと、送信者が自分が送信者であるためであり、こうすることでなりすましを防いでる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;デジタル署名とメッセージを一緒に送信する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;受信者&#xA;&lt;ul&gt;&#xA;&lt;li&gt;デジタル署名を送信者の公開鍵で復号し、メッセージダイジェストを取得&lt;/li&gt;&#xA;&lt;li&gt;受信したメッセージを送信者と同じハッシュ関数でハッシュ化し、メッセージダイジェストと比較する&lt;/li&gt;&#xA;&lt;li&gt;比較した結果、同じであるなら通信内容が改ざんされていないことを確認できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;メール&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%83%a1%e3%83%bc%e3%83%ab&#34;&gt;メール&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SMTP-AUTH&#xA;&lt;ul&gt;&#xA;&lt;li&gt;送信側ドメインでユーザー認証を行う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;APOP&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Authenticated POP&lt;/li&gt;&#xA;&lt;li&gt;受信時にユーザー名とパスワードの認証情報がネットワークに流れるのを防止するプロトコル&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;POP3S&#xA;&lt;ul&gt;&#xA;&lt;li&gt;POP3 over TS&lt;/li&gt;&#xA;&lt;li&gt;セキュアな通信路上でPOP通信を行う&lt;/li&gt;&#xA;&lt;li&gt;POP3SのSは、HTTPSのSと同じ意味(over TLS)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;攻撃手法&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e6%94%bb%e6%92%83%e6%89%8b%e6%b3%95&#34;&gt;攻撃手法&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パスワードリスト攻撃&#xA;&lt;ul&gt;&#xA;&lt;li&gt;あるサイトで入手したIDパスワードを用いて他のサイトでログインを試みる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ブルートフォース攻撃&#xA;&lt;ul&gt;&#xA;&lt;li&gt;特定のIDに対し、パスワードをぶん回す&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;リバースブルートフォース攻撃&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パスワードを固定にし、IDをぶん回す&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;辞書攻撃&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一般的な単語や人名からパスワードのリストを作成し、ログインを試みる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ドライブバイダウンロード&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Webサイトに悪意のあるプログラムを埋め込んでおき、ブラウザ経由で利用者に勝手にダウンロードさせたり、実行させたりする攻撃のこと&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;トロイの木馬&#xA;&lt;ul&gt;&#xA;&lt;li&gt;無償で配布するソフトウェアに悪意あるプログラムを埋め込むなりする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;その他用語集&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%81%9d%e3%81%ae%e4%bb%96%e7%94%a8%e8%aa%9e%e9%9b%86&#34;&gt;その他用語集&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;シャドーIT&#xA;&lt;ul&gt;&#xA;&lt;li&gt;組織の公式な手順を経ずに、使用されているIT機器等のこと&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;システム開発技術&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e9%96%8b%e7%99%ba%e6%8a%80%e8%a1%93&#34;&gt;システム開発技術&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;テストケースの網羅性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;命令網羅&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全ての命令を少なくとも1回実行する&lt;/li&gt;&#xA;&lt;li&gt;最も網羅性が低い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;判定条件網羅&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全ての分岐の分岐先の経路を少なくとも1回実行する&lt;/li&gt;&#xA;&lt;li&gt;判定の中身の組み合わせはどうでも良い&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;条件網羅&#xA;&lt;ul&gt;&#xA;&lt;li&gt;個々の条件を最低1回は満たす&lt;/li&gt;&#xA;&lt;li&gt;例えばAかつBという条件があった時、Aがtrue/false・Bがtrue/falseであることをテストする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;複数条件網羅&#xA;&lt;ul&gt;&#xA;&lt;li&gt;想定される条件の組み合わせをすべて網羅する&lt;/li&gt;&#xA;&lt;li&gt;例えばAかつBという条件があった時、11 01 10 00という全ての組み合わせをテストする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;システムテストを監査する時の観点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;テストケースがきちんと網羅されているかが重要&lt;/li&gt;&#xA;&lt;li&gt;本番環境と隔離された環境でテスト実施する必要がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;マネジメント&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%83%9e%e3%83%8d%e3%82%b8%e3%83%a1%e3%83%b3%e3%83%88&#34;&gt;マネジメント&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;プロジェクトマネジメント&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%83%97%e3%83%ad%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88%e3%83%9e%e3%83%8d%e3%82%b8%e3%83%a1%e3%83%b3%e3%83%88&#34;&gt;プロジェクトマネジメント&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;アローダイアグラム&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最短所要日数は？という問いに対しての回答は「最低限必要な日数」を回答する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;EVM&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Earned Value Management&lt;/li&gt;&#xA;&lt;li&gt;プロジェクトにおける作業を金銭の価値に置き換えて、定量的に実績管理をする進捗管理手法&lt;/li&gt;&#xA;&lt;li&gt;要素&#xA;&lt;ul&gt;&#xA;&lt;li&gt;PV PlannedValue&lt;/li&gt;&#xA;&lt;li&gt;EV EarnedValue: 現時点までに完了した作業に割り当てられていた予算&lt;/li&gt;&#xA;&lt;li&gt;AC ActualCost: 現時点までに完了した作業に対して投入したコスト&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;サービスマネジメント&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%82%b5%e3%83%bc%e3%83%93%e3%82%b9%e3%83%9e%e3%83%8d%e3%82%b8%e3%83%a1%e3%83%b3%e3%83%88&#34;&gt;サービスマネジメント&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ベンチマーキング&#xA;&lt;ul&gt;&#xA;&lt;li&gt;自社の製品・サービスなどを定量的・定性的に測定し、それを同じプロセスに関する業界内外の成功事例（ベストプラクティス）と比較することで、自社の良い点と悪い点を評価する分析手法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;縮退運用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;障害箇所を切り離し、機能または性能が低下してもシステムを稼働し続けること&lt;/li&gt;&#xA;&lt;li&gt;フォールバックともいう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;システム監査&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e7%9b%a3%e6%9f%bb&#34;&gt;システム監査&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コントロールトータルチェック&#xA;&lt;ul&gt;&#xA;&lt;li&gt;入力値と出力値を都度照合することでデータ処理の完全性を高める機能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ストラテジ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%82%b9%e3%83%88%e3%83%a9%e3%83%86%e3%82%b8&#34;&gt;ストラテジ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;システム&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0&#34;&gt;システム&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;システム化構想の立案でやること&#xA;&lt;ul&gt;&#xA;&lt;li&gt;情報技術動向の分析&lt;/li&gt;&#xA;&lt;li&gt;各部門の役割分担を明確にし、費用の検討を行う&lt;/li&gt;&#xA;&lt;li&gt;要件定義などはこの後のフェーズで行う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;セル生産方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;製造業における生産方法の1つで、1人もしくは少人数のチームで組立工程を完成まで行うこと&lt;/li&gt;&#xA;&lt;li&gt;多品種を生産するとき、フレキシブルな切り替え可能なのが特徴&lt;/li&gt;&#xA;&lt;li&gt;ここでいうセルは細胞の意味で、作業者を作業台などのコの字型に囲む様子からセルと名付けられた&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ビジネス戦略&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e3%83%93%e3%82%b8%e3%83%8d%e3%82%b9%e6%88%a6%e7%95%a5&#34;&gt;ビジネス戦略&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;PPM&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Product Portfolio Management&lt;/li&gt;&#xA;&lt;li&gt;市場の成長率と自社のシェアから、今後の方針を検討すること&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;バランススコアカード&#xA;&lt;ul&gt;&#xA;&lt;li&gt;企業のビジョンと戦略を実現するために、財務・顧客・業務プロセス・学習成長という4つの視点から、業績を評価・分析する手法&lt;/li&gt;&#xA;&lt;li&gt;バランス＝複数の視点から評価するというふうに覚える&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;バスタブ曲線&#xA;&lt;ul&gt;&#xA;&lt;li&gt;故障率曲線のことで、初期は初期不良のおける故障が多く、中期は故障が少なく、後期は摩耗による故障が多くなることを図に示すと、バスタブのような曲線を描く&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;法務&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e6%b3%95%e5%8b%99&#34;&gt;法務&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;産業財産権&#xA;&lt;ul&gt;&#xA;&lt;li&gt;知的財産権のうち、特許庁への申請・登録が必要なもの&lt;/li&gt;&#xA;&lt;li&gt;特許権、実用新案権、意匠権、商標権がある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;偽装請負&#xA;&lt;ul&gt;&#xA;&lt;li&gt;始業就業や休憩、勤務日等の勤務形態は受託者側で自社の従業員に指示する&lt;/li&gt;&#xA;&lt;li&gt;これを発注者側が行うと偽造請負になってしまう&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;会計&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/fundamental-engineer/#%e4%bc%9a%e8%a8%88&#34;&gt;会計&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;売上&#xA;&lt;ul&gt;&#xA;&lt;li&gt;minus 原価 = 売上総利益(粗利)&lt;/li&gt;&#xA;&lt;li&gt;minus 販管費 = 営業利益&lt;/li&gt;&#xA;&lt;li&gt;plusminus 営業外利益損失 = 経常利益&lt;/li&gt;&#xA;&lt;li&gt;plusminus 特別利益損失 = 当期純利益税引前&lt;/li&gt;&#xA;&lt;li&gt;minus 法人税 = 当期純利益&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>OpenAPI仕様書生成&amp;デプロイ</title>
      <link>http://localhost:1313/posts/publish-open-api-document/</link>
      <pubDate>Sun, 16 Jun 2024 00:07:56 +0900</pubDate>
      <guid>http://localhost:1313/posts/publish-open-api-document/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;概要&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/publish-open-api-document/#%e6%a6%82%e8%a6%81&#34;&gt;概要&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;以下を実現するGitHub Actionsのワークフローを作成した。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OpenAPIで記述されたyamlファイルをredocly(npmパッケージ)でhtmlを生成&lt;/li&gt;&#xA;&lt;li&gt;gh-pagesブランチにコミット&amp;amp;プッシュするワークフローを作成&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;前提として、gh-pagesブランチへのコミット&amp;amp;プッシュされることでGitHubPagesにデプロイされる設定をしている&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/nyuusen/TIL/assets/56878203/766a5143-e72f-43fb-82c6-313b1255d19d&#34; alt=&#34;スクリーンショット 2024-05-20 12 11 10&#34;&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;実装したコード&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/publish-open-api-document/#%e5%ae%9f%e8%a3%85%e3%81%97%e3%81%9f%e3%82%b3%e3%83%bc%e3%83%89&#34;&gt;実装したコード&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;実装したコードの最終形は以下。&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yml&#34; data-lang=&#34;yml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Publish API doc&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# トリガーは以下の1もしくは2どちらかを有効(コメント解除)する&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 1.手動実行のトリガーを設定&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;on&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;workflow_dispatch&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 2.mainへのmergeとopenapi.ymlの変更があれば実行されるトリガーを設定&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# on:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#   push:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#     branches:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#       - main&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#     paths:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#       - &amp;#39;openapi.yml&amp;#39;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;jobs&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;publish-api-docs&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;runs-on&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;ubuntu-latest&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;steps&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Checkout branch&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;uses&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;actions/checkout@v4&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Setup node&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;uses&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;actions/setup-node@v4&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Generate API doc&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;run&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;npx @redocly/cli build-docs ./openapi.yml -o docs/api.html&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Publish API doc&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;run&lt;/span&gt;: |&lt;span style=&#34;color:#e6db74&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;          git config user.name &amp;#34;github-actions[bot]&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;          git config user.email &amp;#34;github-actions[bot]@users.noreply.github.com&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;          git checkout -b gh-pages&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;          git add -f ./docs/api.html&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;          git commit -m &amp;#34;publish api doc&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;          git push -f -u origin gh-pages&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;p&gt;※本コードを実装したリポジトリ: &lt;a href=&#34;https://github.com/nyuusen/udemy-github-actions&#34;&gt;udemy-github-actions&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ポイント&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/publish-open-api-document/#%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88&#34;&gt;ポイント&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;npxでredoclycliコマンドを実行する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/publish-open-api-document/#npx%e3%81%a7redoclycli%e3%82%b3%e3%83%9e%e3%83%b3%e3%83%89%e3%82%92%e5%ae%9f%e8%a1%8c%e3%81%99%e3%82%8b&#34;&gt;npxでredocly@cliコマンドを実行する&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;package.jsonが存在しないプロジェクトであることもあり、node環境をセットアップし、npxコマンドで実行するようにした&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;コミットするgitユーザーどうしようか問題&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/publish-open-api-document/#%e3%82%b3%e3%83%9f%e3%83%83%e3%83%88%e3%81%99%e3%82%8bgit%e3%83%a6%e3%83%bc%e3%82%b6%e3%83%bc%e3%81%a9%e3%81%86%e3%81%97%e3%82%88%e3%81%86%e3%81%8b%e5%95%8f%e9%a1%8c&#34;&gt;コミットするgitユーザーどうしようか問題&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;前提として、自動ビルドしたhtmlをコミットするので、特定の実ユーザーではなく、bot等にコミットさせたい(同時にunknownユーザー等になってしまうことも避けたい)&lt;br&gt;&#xA;結論、GitHub側で用意しているbotユーザーを使用することにした&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git config user.name &amp;#34;github-actions[bot]&amp;#34;&#xA;git config user.email &amp;#34;github-actions[bot]@users.noreply.github.com&amp;#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/nyuusen/TIL/assets/56878203/d187f210-1d40-4fe1-a325-6edc1769b1c0&#34; alt=&#34;スクリーンショット 2024-05-20 11 29 12&#34;&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;git-push時に403エラーが発生する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/publish-open-api-document/#git-push%e6%99%82%e3%81%ab403%e3%82%a8%e3%83%a9%e3%83%bc%e3%81%8c%e7%99%ba%e7%94%9f%e3%81%99%e3%82%8b&#34;&gt;git push時に403エラーが発生する&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;ワークフロー内で実行されるgit push時に以下のエラーが発生する&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Permission to nyuusen/udemy-github-actions.git denied to github-actions[bot].&#xA;fatal: unable to access &amp;#39;https://github.com/nyuusen/udemy-github-actions/&amp;#39;: The requested URL returned error: 403&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;GUI上から以下で権限付与することで解決した&lt;br&gt;&#xA;&lt;code&gt;settings -&amp;gt; Actions -&amp;gt; General -&amp;gt; Workflow permissions -&amp;gt; Read and write permissionsにチェックを入れる&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;ワークフロー毎に権限を付与することも可能らしい&lt;br&gt;&#xA;参考: &lt;a href=&#34;https://docs.github.com/ja/enterprise-cloud@latest/actions/using-jobs/assigning-permissions-to-jobs&#34;&gt;権限をジョブに割り当てる - GitHub Enterprise Cloud Docs&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;git-push時にリモートにある変更がローカルにないエラーが発生する&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/publish-open-api-document/#git-push%e6%99%82%e3%81%ab%e3%83%aa%e3%83%a2%e3%83%bc%e3%83%88%e3%81%ab%e3%81%82%e3%82%8b%e5%a4%89%e6%9b%b4%e3%81%8c%e3%83%ad%e3%83%bc%e3%82%ab%e3%83%ab%e3%81%ab%e3%81%aa%e3%81%84%e3%82%a8%e3%83%a9%e3%83%bc%e3%81%8c%e7%99%ba%e7%94%9f%e3%81%99%e3%82%8b&#34;&gt;git push時にリモートにある変更がローカルにないエラーが発生する&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;エラー全文は下記の通り。&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;To https://github.com/nyuusen/udemy-github-actions&#xA; ! [rejected]        gh-pages -&amp;gt; gh-pages (fetch first)&#xA;error: failed to push some refs to &amp;#39;https://github.com/nyuusen/udemy-github-actions&amp;#39;&#xA;hint: Updates were rejected because the remote contains work that you do not&#xA;hint: have locally. This is usually caused by another repository pushing to&#xA;hint: the same ref. If you want to integrate the remote changes, use&#xA;hint: &amp;#39;git pull&amp;#39; before pushing again.&#xA;hint: See the &amp;#39;Note about fast-forwards&amp;#39; in &amp;#39;git push --help&amp;#39; for details.&#xA;Error: Process completed with exit code 1.&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;gh-pagesブランチは、GitHubActionsワークフローからしかコミットされないため、&lt;br&gt;&#xA;コマンドを&lt;code&gt;git push origin gh-pages&lt;/code&gt;から&lt;code&gt;git push -f -u origin gh-pages&lt;/code&gt;に変更することで解決。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>CloudRunデプロイ</title>
      <link>http://localhost:1313/posts/build-and-deploy-cloud-run/</link>
      <pubDate>Sun, 16 Jun 2024 00:00:08 +0900</pubDate>
      <guid>http://localhost:1313/posts/build-and-deploy-cloud-run/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/build-and-deploy-cloud-run/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;個人で開発したCloud Runで動いているGoアプリケーションデプロイをGitHub Actionsでパイプラインを構築し、&#xA;デプロイ作業を簡略化したい&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;デプロイの流れ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/build-and-deploy-cloud-run/#%e3%83%87%e3%83%97%e3%83%ad%e3%82%a4%e3%81%ae%e6%b5%81%e3%82%8c&#34;&gt;デプロイの流れ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Google Cloud認証&lt;/li&gt;&#xA;&lt;li&gt;Google Cloud SDKセットアップ&lt;/li&gt;&#xA;&lt;li&gt;最新のコミットハッシュを取得(①)&lt;/li&gt;&#xA;&lt;li&gt;Dockerイメージビルド(タグ名に①を埋め込む)&amp;amp;ArtifactRegistryへイメージプッシュ&lt;/li&gt;&#xA;&lt;li&gt;Cloud Runでプッシュされたイメージ(タグ名)を指定してデプロイ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;手順毎に調べながら進める&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/build-and-deploy-cloud-run/#%e6%89%8b%e9%a0%86%e6%af%8e%e3%81%ab%e8%aa%bf%e3%81%b9%e3%81%aa%e3%81%8c%e3%82%89%e9%80%b2%e3%82%81%e3%82%8b&#34;&gt;手順毎に調べながら進める&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;google-cloud認証&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/build-and-deploy-cloud-run/#google-cloud%e8%aa%8d%e8%a8%bc&#34;&gt;Google Cloud認証&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;以前はデプロイロールを紐づけたサービスアカウントを作成し、サービスアカウントキーを発行するのが一般的だったみたいだが、&#xA;サービスアカウントキーは強力な認証を持つため漏洩時のリスクが大きいという課題があるらしく、&#xA;Workload Identity連携で行うのが推奨とされているらしい。&lt;/p&gt;&#xA;&lt;p&gt;以下の記事の通りに進めた。&lt;br&gt;&#xA;&lt;a href=&#34;https://zenn.dev/cloud_ace/articles/7fe428ac4f25c8&#34;&gt;Workload Identity 連携を利用して GitHub Actions を動かす&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;(そもそも)サービスアカウントとは？&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;人以外のリソース（CloudRun等）が使用するアカウントであり、そのリソースが持つ認証情報である&lt;/li&gt;&#xA;&lt;li&gt;リソースにサービスアカウントをアタッチして、そのサービスアカウントに色々なロールをすることで、Google Cloud内部の他リソースに対するAPI等を実行することができるようになる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;Workload Identity連携とは？&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Workload Identity 連携は、外部サービスとの認証方法の1つ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SAMLとOIDCをサポートしている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;サービスアカウントキーを使用する方法よりセキュアである&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Workload Identity プールは、外部IDを管理するエンティティ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;GitHubと連携したい場合は、Workload Identity プール プロバイダとしてGitHubを選択する&lt;/li&gt;&#xA;&lt;li&gt;参考&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/iam/docs/workload-identity-federation?hl=ja&#34;&gt;Workload Identity 連携  |  IAM のドキュメント  |  Google Cloud&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt; &lt;br&gt;&#xA;&lt;a href=&#34;https://cloud.google.com/iam/docs/workload-identity-federation-with-deployment-pipelines?hl=ja#impersonation&#34;&gt;デプロイメント パイプラインとの Workload Identity 連携を構成する&lt;/a&gt;&lt;br&gt;&#xA;&lt;a href=&#34;https://docs.github.com/ja/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-google-cloud-platform#adding-a-google-cloud-workload-identity-provider&#34;&gt;Google Cloud Platform での OpenID Connect の構成 - GitHub Docs&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;google-cloud-sdkセットアップ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/build-and-deploy-cloud-run/#google-cloud-sdk%e3%82%bb%e3%83%83%e3%83%88%e3%82%a2%e3%83%83%e3%83%97&#34;&gt;Google Cloud SDKセットアップ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;google-github-actions/setup-gcloud@v1&lt;/code&gt;が使える&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;最新のコミットハッシュを取得&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/build-and-deploy-cloud-run/#%e6%9c%80%e6%96%b0%e3%81%ae%e3%82%b3%e3%83%9f%e3%83%83%e3%83%88%e3%83%8f%e3%83%83%e3%82%b7%e3%83%a5%e3%82%92%e5%8f%96%e5%be%97&#34;&gt;最新のコミットハッシュを取得&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;以下のコマンドで取得できる&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git log --pretty&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;%H -1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;p&gt;$GITHUB_ENVにセットすることで変数として以降のステップで使用可能になる&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;image_hash=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;git log --pretty&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;%H -1&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; &amp;gt;&amp;gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$GITHUB_ENV&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;dockerイメージビルドartifactregistryへイメージプッシュ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/build-and-deploy-cloud-run/#docker%e3%82%a4%e3%83%a1%e3%83%bc%e3%82%b8%e3%83%93%e3%83%ab%e3%83%89artifactregistry%e3%81%b8%e3%82%a4%e3%83%a1%e3%83%bc%e3%82%b8%e3%83%97%e3%83%83%e3%82%b7%e3%83%a5&#34;&gt;Dockerイメージビルド&amp;amp;ArtifactRegistryへイメージプッシュ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;ローカルで使用したコマンドを指定すれば良いが、プロジェクトID等の情報はGitHubのSecretsで管理する&#xA;(正直な所、どの値をSecretsで管理すれば良いか分かっていないので過剰にSecretsで管理しすぎている感がある)&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yml&#34; data-lang=&#34;yml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;- &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Docker build and push&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;run&lt;/span&gt;: |&lt;span style=&#34;color:#e6db74&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    docker build -t asia-northeast1-docker.pkg.dev/${{ secrets.PROJECT_ID }}/${{ secrets.REPOSITORY_NAME }}/api:${image_hash} -f deploy/api/Dockerfile --platform linux/amd64 .&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    docker push asia-northeast1-docker.pkg.dev/${{ secrets.PROJECT_ID }}/${{ secrets.REPOSITORY_NAME }}/api:${image_hash}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;p&gt;上記のコードで以下のエラーが発生した。&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;denied: Unauthenticated request. Unauthenticated requests &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt; not have permission &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;artifactregistry.repositories.uploadArtifacts&amp;#34;&lt;/span&gt; on resource &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;projects/***/locations/asia-northeast1/repositories/***&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;or it may not exist&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;p&gt;リソースが存在していない？&lt;br&gt;&#xA;→ローカル実行すると通るので存在してそう&lt;/p&gt;&#xA;&lt;p&gt;アタッチしているIAMの問題か？&lt;br&gt;&#xA;→該当IAMには&lt;code&gt;artifactregistry.repositories.uploadArtifacts&lt;/code&gt;の権限が付与されていることを確認&lt;/p&gt;&#xA;&lt;p&gt;雑にエラー文でググってみたら以下の記事がヒットし、同じ方法で解決&lt;br&gt;&#xA;&lt;a href=&#34;https://yunabe.hatenablog.com/entry/2023/06/04/220618&#34;&gt;コンテナをpushすると発生した denied: Permission &amp;ldquo;artifactregistry.repositories.uploadArtifacts&amp;rdquo; denied on resource - show log include yuh&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;具体的には、docker push前に以下のコードを追加した&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yml&#34; data-lang=&#34;yml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;- &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Configure Docker&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;run&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;gcloud auth configure-docker asia-northeast1-docker.pkg.dev&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;p&gt;恐らくだが、ログイン済のgloudユーザーとdockerの紐付け？設定？が必要だったのかなと思われる&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;cloud-runでプッシュされたイメージを指定してデプロイ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/build-and-deploy-cloud-run/#cloud-run%e3%81%a7%e3%83%97%e3%83%83%e3%82%b7%e3%83%a5%e3%81%95%e3%82%8c%e3%81%9f%e3%82%a4%e3%83%a1%e3%83%bc%e3%82%b8%e3%82%92%e6%8c%87%e5%ae%9a%e3%81%97%e3%81%a6%e3%83%87%e3%83%97%e3%83%ad%e3%82%a4&#34;&gt;Cloud Runでプッシュされたイメージを指定してデプロイ&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;gcloud run deployコマンドを実行するだけ。&lt;br&gt;&#xA;&lt;a href=&#34;https://cloud.google.com/sdk/gcloud/reference/run/deploy&#34;&gt;gcloud run deploy  |  Google Cloud CLI Documentation&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>GitHub Actionsに関する調べたことを雑に書く</title>
      <link>http://localhost:1313/posts/memo/</link>
      <pubDate>Sun, 16 Jun 2024 00:00:08 +0900</pubDate>
      <guid>http://localhost:1313/posts/memo/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;github_output-vs-github_env&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/memo/#github_output-vs-github_env&#34;&gt;$GITHUB_OUTPUT vs $GITHUB_ENV&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;$GITHUB_OUTPUT&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;特定のステップで使用する等出力先を細かく指定したい場合に使用する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;$GITHUB_ENV&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;後続の(複数の)ステップで値を参照できるようにしたい場合に使用する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;基本的には$GITHUB_ENVを使用するで良いらしい&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;参考&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#setting-an-environment-variable&#34;&gt;Workflow commands for GitHub Actions - GitHub Docs&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/orgs/community/discussions/55294&#34;&gt;Difference between environment variable and output parameters · community · Discussion #55294&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>OpenID Connect</title>
      <link>http://localhost:1313/posts/oidc/</link>
      <pubDate>Sun, 16 Jun 2024 00:00:08 +0900</pubDate>
      <guid>http://localhost:1313/posts/oidc/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;登場人物&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/oidc/#%e7%99%bb%e5%a0%b4%e4%ba%ba%e7%89%a9&#34;&gt;登場人物&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ユーザー&lt;/li&gt;&#xA;&lt;li&gt;クライアントアプリ&lt;/li&gt;&#xA;&lt;li&gt;OpenIDプロバイダ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;openid-connectとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/oidc/#openid-connect%e3%81%a8%e3%81%af&#34;&gt;OpenID Connectとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クライアントアプリとOpenIDプロバイダ間の&lt;strong&gt;IDトークンの要求と応答&lt;/strong&gt;を標準化したもの&lt;/li&gt;&#xA;&lt;li&gt;OIDCと略される&lt;/li&gt;&#xA;&lt;li&gt;OAuth2.0の拡張仕様である&#xA;&lt;ul&gt;&#xA;&lt;li&gt;そのため処理フローが似ている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;oidcとoauth20の違い&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/oidc/#oidc%e3%81%a8oauth20%e3%81%ae%e9%81%95%e3%81%84&#34;&gt;OIDCとOAuth2.0の違い&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OIDCは人がシステムにログインするための仕組み(目的がログイン=認証)&lt;/li&gt;&#xA;&lt;li&gt;OAuth2.0はシステムがシステムにアクセスするための仕組み(目的がリソースアクセス＝認可)&lt;/li&gt;&#xA;&lt;li&gt;OAuth2.0のIdentityレイヤーを追加したもの(ログイン要件を満たすために)がOIDC&#xA;&lt;ul&gt;&#xA;&lt;li&gt;具体的にはIDトークンの発行する/しないが違う部分になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;idトークンとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/oidc/#id%e3%83%88%e3%83%bc%e3%82%af%e3%83%b3%e3%81%a8%e3%81%af&#34;&gt;IDトークンとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以下のような&lt;code&gt;ヘッダー.ペイロード.署名&lt;/code&gt;で構成されている&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  eyJraWQiOiIxZTlnZGs3IiwiYWxnIjoiUlMyNTYifQ.ewogImlz&#xA;  cyI6ICJodHRwOi8vc2VydmVyLmV4YW1wbGUuY29tIiwKICJzdWIiOiAiMjQ4&#xA;  Mjg5NzYxMDAxIiwKICJhdWQiOiAiczZCaGRSa3F0MyIsCiAibm9uY2UiOiAi&#xA;  bi0wUzZfV3pBMk1qIiwKICJleHAiOiAxMzExMjgxOTcwLAogImlhdCI6IDEz&#xA;  MTEyODA5NzAsCiAibmFtZSI6ICJKYW5lIERvZSIsCiAiZ2l2ZW5fbmFtZSI6&#xA;  ICJKYW5lIiwKICJmYW1pbHlfbmFtZSI6ICJEb2UiLAogImdlbmRlciI6ICJm&#xA;  ZW1hbGUiLAogImJpcnRoZGF0ZSI6ICIwMDAwLTEwLTMxIiwKICJlbWFpbCI6&#xA;  ICJqYW5lZG9lQGV4YW1wbGUuY29tIiwKICJwaWN0dXJlIjogImh0dHA6Ly9l&#xA;  eGFtcGxlLmNvbS9qYW5lZG9lL21lLmpwZyIKfQ.rHQjEmBqn9Jre0OLykYNn&#xA;  spA10Qql2rvx4FsD00jwlB0Sym4NzpgvPKsDjn_wMkHxcp6CilPcoKrWHcip&#xA;  R2iAjzLvDNAReF97zoJqq880ZD1bwY82JDauCXELVR9O6_B0w3K-E7yM2mac&#xA;  AAgNCUwtik6SjoSUZRcf-O5lygIyLENx882p6MtmwaL1hd6qn5RZOQ0TLrOY&#xA;  u0532g9Exxcm-ChymrB4xLykpDj3lUivJt63eEGGN6DH5K6o33TcxkIjNrCD&#xA;  4XB1CKKumZvCedgHHF3IAK4dVEDSUoGlH9z4pP_eWYNXvqQOjGs-rDaQzUHl&#xA;  6cQQWNiDpWOl_lxXjQEvQ&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;これはJSON Web Signature(JWS)形式で、3項目をそれぞれBase64エンコードした値&#xA;&lt;ul&gt;&#xA;&lt;li&gt;なのでそれぞれをBase64デコードする値が確認できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ヘッダー&lt;/li&gt;&#xA;&lt;li&gt;ペイロード&lt;/li&gt;&#xA;&lt;li&gt;署名&lt;/li&gt;&#xA;&lt;li&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;わかりやすい記事&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://qiita.com/TakahikoKawasaki/items/8f0e422c7edd2d220e06&#34;&gt;IDトークンが分かれば OpenID Connect が分かる #OAuth - Qiita&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;流れ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/oidc/#%e6%b5%81%e3%82%8c&#34;&gt;流れ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クライアントアプリが署名付きの認証情報をOpenIDプロバイダに渡す&lt;/li&gt;&#xA;&lt;li&gt;OpenIDプロバイダが署名付きの認証情報の発行元に公開鍵を依頼し、署名を検証する&lt;/li&gt;&#xA;&lt;li&gt;検証に成功したら、OpenIDプロバイダがIDトークンをクライアントアプリに発行する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;発行時にOpenIDプロバイダからユーザーに「本人ですか？発行しますか？」の確認を行う(=認証)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;samlとの違い&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/oidc/#saml%e3%81%a8%e3%81%ae%e9%81%95%e3%81%84&#34;&gt;SAMLとの違い&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;感想&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/oidc/#%e6%84%9f%e6%83%b3&#34;&gt;感想&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/oidc/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://qiita.com/TakahikoKawasaki/items/498ca08bbfcc341691fe&#34;&gt;一番分かりやすい OpenID Connect の説明 #OAuth - Qiita&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>ブランチとHEADを理解する</title>
      <link>http://localhost:1313/posts/understand-branch-and-head/</link>
      <pubDate>Sun, 16 Jun 2024 00:00:08 +0900</pubDate>
      <guid>http://localhost:1313/posts/understand-branch-and-head/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/understand-branch-and-head/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;雰囲気の理解で使っていたブランチ及びHEADを理解する&lt;br&gt;&#xA;ちょっと調べた所、見事に自分が浮かべていたイメージと異なっていたので、調べたことをメモ&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;ブランチとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/understand-branch-and-head/#%e3%83%96%e3%83%a9%e3%83%b3%e3%83%81%e3%81%a8%e3%81%af&#34;&gt;ブランチとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;単なるコミットを指すポインタ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;派生元から最新の履歴までの枝全体を指すものではない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;headとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/understand-branch-and-head/#head%e3%81%a8%e3%81%af&#34;&gt;HEADとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Gitが今のブランチを把握するためのもの&lt;/li&gt;&#xA;&lt;li&gt;特定のコミットを指すブランチを指すポインタ&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ポインタのポインタ&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Gitの中唯一の存在&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ポインタはコミットの数だけ存在するが、HEADは「自分が今作業しているブランチ」を指すので、唯一であるという意&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;新しいコミットが発生すると自動的にブランチのポインタが進む→HEADの値も追尾する&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;git reflog&lt;/code&gt;でHEADの位置を確認できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;tips&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/understand-branch-and-head/#tips&#34;&gt;tips&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;git v1.8.5からは「@」がHEADのエイリアスとして使えるようになった&lt;/li&gt;&#xA;&lt;li&gt;例えば、以下2つのコマンドは同じ結果が出力される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git show HEAD~&#xA;&#xA;git show @~&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/understand-branch-and-head/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://qiita.com/ymzkjpx/items/00ff664da60c37458aaa&#34;&gt;GitのHEADとは何者なのか #Git - Qiita&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>暗号化</title>
      <link>http://localhost:1313/posts/encrypt/</link>
      <pubDate>Sun, 16 Jun 2024 00:00:08 +0900</pubDate>
      <guid>http://localhost:1313/posts/encrypt/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;はじめに&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/encrypt/#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab&#34;&gt;はじめに&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;業務で暗号化に触れる機会があったので基本から調べてみた。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;暗号化とは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/encrypt/#%e6%9a%97%e5%8f%b7%e5%8c%96%e3%81%a8%e3%81%af&#34;&gt;暗号化とは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;データを第三者が理解できない形式に変換するプロセスのこと。&lt;br&gt;&#xA;暗号化の目的は、機密性を保護し、不正アクセスを防ぐことである。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;暗号方式の種類&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/encrypt/#%e6%9a%97%e5%8f%b7%e6%96%b9%e5%bc%8f%e3%81%ae%e7%a8%ae%e9%a1%9e&#34;&gt;暗号方式の種類&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;現代の（コンピュータを用いる）暗号方式は、共通鍵暗号方式と公開鍵暗号方式の2つに大別される。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;共通鍵暗号方式（対称鍵暗号方式）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;暗号化と復号化に同じ鍵を使用する&lt;/li&gt;&#xA;&lt;li&gt;例: AES, DES, 3DES (Triple DES)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;公開鍵暗号方式（非対称鍵暗号方式）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;暗号化と復号化に異なる鍵（公開鍵と秘密鍵）を使用する&lt;/li&gt;&#xA;&lt;li&gt;例: RSA, ECC&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Gitコマンド集</title>
      <link>http://localhost:1313/posts/commands/</link>
      <pubDate>Fri, 14 Jun 2024 17:08:46 +0900</pubDate>
      <guid>http://localhost:1313/posts/commands/</guid>
      <description>&lt;p&gt;ペア/モブプログラミングする時はコマンドの方がわかり良いのでコマンドを&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;git-diff&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/commands/#git-diff&#34;&gt;git diff&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;コミット間の差分を確認する&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git diff &amp;lt;commit_hash_A&amp;gt; &amp;lt;commit_hash_B&amp;gt;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;現在ブランチとの差分を確認する&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git diff &amp;lt;commit_hash&amp;gt;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;ファイル一覧のみを表示する&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git diff --name-only&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;git-push&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/commands/#git-push&#34;&gt;git push&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;-uオプションは、&amp;ndash;set-upstreamの省略形(upstreamは上流という意味)&lt;br&gt;&#xA;現在ブランチを指定したリモートブランチに紐付けするという意味&lt;/p&gt;&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// (一度のみ実行)-uでリモートブランチを紐付けする&#xA;git push -u origin hogehoge&#xA;&#xA;// 以降はgit pushのみで紐付けしたリモートブランチにプッシュできる&#xA;git push&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>イベント駆動型アーキテクチャ</title>
      <link>http://localhost:1313/posts/event-driven/</link>
      <pubDate>Tue, 11 Jun 2024 21:18:58 +0900</pubDate>
      <guid>http://localhost:1313/posts/event-driven/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;イベント駆動型アーキテクチャとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/event-driven/#%e3%82%a4%e3%83%99%e3%83%b3%e3%83%88%e9%a7%86%e5%8b%95%e5%9e%8b%e3%82%a2%e3%83%bc%e3%82%ad%e3%83%86%e3%82%af%e3%83%81%e3%83%a3%e3%81%a8%e3%81%af&#34;&gt;イベント駆動型アーキテクチャとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;イベントの発生に基づいて動作するシステム&lt;/li&gt;&#xA;&lt;li&gt;あるコンポーネントからコンポーネントに非同期でイベントが通知される&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;メッセージ駆動アーキテクチャとの違い&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/event-driven/#%e3%83%a1%e3%83%83%e3%82%bb%e3%83%bc%e3%82%b8%e9%a7%86%e5%8b%95%e3%82%a2%e3%83%bc%e3%82%ad%e3%83%86%e3%82%af%e3%83%81%e3%83%a3%e3%81%a8%e3%81%ae%e9%81%95%e3%81%84&#34;&gt;メッセージ駆動アーキテクチャとの違い&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;送信者が宛先を知っているかどうか&#xA;&lt;ul&gt;&#xA;&lt;li&gt;イベント駆動型アーキテクチャはイベントを発行するのみなので疎結合&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;イベント駆動型アーキテクチャにおけるイベント検知&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/event-driven/#%e3%82%a4%e3%83%99%e3%83%b3%e3%83%88%e9%a7%86%e5%8b%95%e5%9e%8b%e3%82%a2%e3%83%bc%e3%82%ad%e3%83%86%e3%82%af%e3%83%81%e3%83%a3%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8b%e3%82%a4%e3%83%99%e3%83%b3%e3%83%88%e6%a4%9c%e7%9f%a5&#34;&gt;イベント駆動型アーキテクチャにおけるイベント検知&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;イベントブローカー(バス)というイベントを仲介するコンポーネントを構成する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;パブリッシュ・サブスクライブモデル&#xA;&lt;ul&gt;&#xA;&lt;li&gt;いわゆるPub/Sub&lt;/li&gt;&#xA;&lt;li&gt;AWS SNSが該当する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;受信者が一定間隔でチェックするポーリング&lt;/li&gt;&#xA;&lt;li&gt;メッセージキュー&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/event-driven/#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://findy-tools.io/articles/architecture1/11&#34;&gt;https://findy-tools.io/articles/architecture1/11&lt;/a&gt;&#xA;&lt;a href=&#34;https://aws.amazon.com/jp/serverless/patterns/eda/&#34;&gt;https://aws.amazon.com/jp/serverless/patterns/eda/&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>SourceMap</title>
      <link>http://localhost:1313/posts/sourcemap/</link>
      <pubDate>Tue, 11 Jun 2024 17:28:05 +0900</pubDate>
      <guid>http://localhost:1313/posts/sourcemap/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;sourcemapとは&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/sourcemap/#sourcemap%e3%81%a8%e3%81%af&#34;&gt;SourceMapとは？&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;コンパイル前とコンパイル後の対応関係を示すJSON形式のファイル&lt;/li&gt;&#xA;&lt;li&gt;.mapというファイル&lt;/li&gt;&#xA;&lt;li&gt;具体的には、元のソースコードのファイル名や行列情報が含まれている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;必要性&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/sourcemap/#%e5%bf%85%e8%a6%81%e6%80%a7&#34;&gt;必要性&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;デバッグ効率を上げるため&#xA;&lt;ul&gt;&#xA;&lt;li&gt;元のソースコードをコンパイルしてミニファイしてバンドルして1つのファイルの結合した後でもマップしてくれる&lt;/li&gt;&#xA;&lt;li&gt;これによりDevToolsでは、読みづらいコードではなく、元のソースコードを読み取ってデバッグが可能になる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;生成方法&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/sourcemap/#%e7%94%9f%e6%88%90%e6%96%b9%e6%b3%95&#34;&gt;生成方法&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;以下のビルドツール等で生成可能&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;TypeScriptコンパイラ&lt;/li&gt;&#xA;&lt;li&gt;SASSやPostCSS&lt;/li&gt;&#xA;&lt;li&gt;Babel: CSSとJavaScriptの両方のソースマップを生成できる&lt;/li&gt;&#xA;&lt;li&gt;WebpackやVite&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;解釈する手順&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/sourcemap/#%e8%a7%a3%e9%87%88%e3%81%99%e3%82%8b%e6%89%8b%e9%a0%86&#34;&gt;解釈する手順&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ブラウザが実行するJSやCSSファイルの末尾に以下のようなソースマップへの参照が含まれている&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//# sourceMappingURL=example.min.js.map&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ブラウザはこのコメント行を見つけると、指定されたURL(上で言うexample.min.js.map)からソースマップファイルを取得する&lt;/li&gt;&#xA;&lt;li&gt;この.mapファイルを解析し、ミニファイ後のコードと元のソースコードの対応関係を把握する&lt;/li&gt;&#xA;&lt;li&gt;これにより、開発者ツールで元のソースコードをもとにデバッグできる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;補足&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/sourcemap/#%e8%a3%9c%e8%b6%b3&#34;&gt;補足&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;元のソースコードが外部に漏れる可能性があるので、あえてソースマップ生成はしないこともあったりする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>SAML</title>
      <link>http://localhost:1313/posts/saml/</link>
      <pubDate>Fri, 31 May 2024 21:54:30 +0900</pubDate>
      <guid>http://localhost:1313/posts/saml/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;概要&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/saml/#%e6%a6%82%e8%a6%81&#34;&gt;概要&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Security Assertion Markup Languageの略&lt;/li&gt;&#xA;&lt;li&gt;異なるドメイン間でユーザー認証を実現するXMLベースの標準規格&#xA;&lt;ul&gt;&#xA;&lt;li&gt;異なるドメイン間で認証に関する情報をXML文書でやり取りするためのルール&#xA;&lt;ul&gt;&#xA;&lt;li&gt;プラメクーポンの例：プラメクーポン(管理画面)とAzureAD間で認証情報をXMLでやり取りしています&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;2002年に策定、2005年に2.0がリリースされている&#xA;&lt;ul&gt;&#xA;&lt;li&gt;現在は2.0が主流&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;処理の流れ&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/saml/#%e5%87%a6%e7%90%86%e3%81%ae%e6%b5%81%e3%82%8c&#34;&gt;処理の流れ&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;登場人物&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/saml/#%e7%99%bb%e5%a0%b4%e4%ba%ba%e7%89%a9&#34;&gt;登場人物&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;クライアント&#xA;&lt;ul&gt;&#xA;&lt;li&gt;認証させたいアプリケーション&lt;/li&gt;&#xA;&lt;li&gt;大体は私たちが開発しているアプリケーションを指す&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;IdP&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Identity Providerの略&lt;/li&gt;&#xA;&lt;li&gt;認証機能を提供するサービス&lt;/li&gt;&#xA;&lt;li&gt;具体的にはGoogleやAzureAD,Okta等が該当する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SP&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Service Providerの略&lt;/li&gt;&#xA;&lt;li&gt;ユーザーが利用するサービス&lt;/li&gt;&#xA;&lt;li&gt;大体は私たちが開発しているアプリケーションを利用するユーザーを指す&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;フロー&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/saml/#%e3%83%95%e3%83%ad%e3%83%bc&#34;&gt;フロー&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;&#xA;sequenceDiagram&#xA;participant client as ユーザー&#xA;participant idp as IdP(AzureAD,Google等)&#xA;participant sp as SP(アプリケーション)&#xA;    client -&amp;gt;&amp;gt; sp: 利用者がSPのログインURLにアクセス(GET)&#xA;    Note right of sp:SAMLフロー開始&#xA;    sp --&amp;gt;&amp;gt; client: IdPにリダイレクト(SAMLリクエスト)&#xA;    client -&amp;gt;&amp;gt; idp: &#xA;    idp --&amp;gt;&amp;gt; client: IdP未ログインの場合、IdPログインを要求&#xA;    client -&amp;gt;&amp;gt;+ idp: 利用者がIdPにログイン&#xA;     Note right of idp: IdPログイン&#xA;    idp --&amp;gt;&amp;gt;- client: &#xA;    client -&amp;gt;&amp;gt;+ sp: SPにリダイレクト(POST)&#xA;    Note left of sp: SAMLアサーション連携(SAMLレスポンス)&#xA;    Note right of sp: SP側でSAMLアサーションを検証後、認証完了&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;認証フローの種類&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/saml/#%e8%aa%8d%e8%a8%bc%e3%83%95%e3%83%ad%e3%83%bc%e3%81%ae%e7%a8%ae%e9%a1%9e&#34;&gt;認証フローの種類&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SAMLの認証フローは2種類ある&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;SP initiated SSO&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SP→IdPにアクセスする&lt;/li&gt;&#xA;&lt;li&gt;例：アプリケーションのログイン画面にメールアドレスを入力し、Googleリダイレクト→Googleログインを経由し、アプリケーションにログインする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;IdP initiated SSO&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IdP→SPにアクセスする&lt;/li&gt;&#xA;&lt;li&gt;Googleトップ画面やAzureADのアプリ一覧に表示されているアプリケーションを選択し、アプリケーションにログインする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;※SSO＝シングルサインオン&lt;/p&gt;&#xA;&lt;p&gt;※起点が異なるだけで、基本的にやっていることは同じ&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;samlが解決していること&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/saml/#saml%e3%81%8c%e8%a7%a3%e6%b1%ba%e3%81%97%e3%81%a6%e3%81%84%e3%82%8b%e3%81%93%e3%81%a8&#34;&gt;SAMLが解決していること&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;利便性の向上&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1サービスへのログインで複数サービスへの利用が可能(シングルサインオン)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;セキュリティ性の向上&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ユーザー的には複数のIDパスワードを管理しなくて良くなる&lt;/li&gt;&#xA;&lt;li&gt;アプリケーション的には、自前で認証機能を持たなくて良くなる&#xA;&lt;ul&gt;&#xA;&lt;li&gt;開発工数も削減できる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>MySQL</title>
      <link>http://localhost:1313/posts/mysql/</link>
      <pubDate>Wed, 22 May 2024 20:52:30 +0900</pubDate>
      <guid>http://localhost:1313/posts/mysql/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h2 id=&#34;コマンド&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/mysql/#%e3%82%b3%e3%83%9e%e3%83%b3%e3%83%89&#34;&gt;コマンド&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;確認調査系&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/mysql/#%e7%a2%ba%e8%aa%8d%e8%aa%bf%e6%9f%bb%e7%b3%bb&#34;&gt;確認・調査系&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;該当テーブルのカラムの詳細情報&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;show columns from [table_name];&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;該当テーブルのカラムのより詳細な情報(コメントとか&lt;br&gt;&#xA;\Gをつけることで行表示になり見やすくなる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;select * from INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME=&amp;#39;[table_name]&amp;#39;\G&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;テーブルの情報からCREATE文を生成する&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;  &#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;show create table [table_name];&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h3 id=&#34;ddl&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/mysql/#ddl&#34;&gt;DDL&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;</description>
    </item>
  </channel>
</rss>
